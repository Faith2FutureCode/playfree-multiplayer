<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Plumber Platformer (SMB3-inspired)</title>
  <style>
    html, body {
      margin:0;
      height:100%;
      background:#0b1020;
      overflow:hidden;
      position: relative;
    }
    :root {
      --frame-width: 960px;
      --frame-height: 720px;
      --canvas-width: 960px;
      --canvas-height: 720px;
      --editor-width: 0px;
      --editor-scale: 1;
      --tile: 16px;
    }
    canvas { display:block; margin:0 auto; image-rendering: pixelated; image-rendering: crisp-edges; }
    .game-shell {
      position: relative;
      width: var(--frame-width);
      height: var(--frame-height);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .tileset-preview {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(5, 8, 16, 0.65);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
      z-index: 2;
    }
    .tileset-preview.visible { display: flex; }
    .tileset-preview.panning { cursor: grabbing; }
    .tileset-preview-sidebar {
      position: fixed;
      left: 50%;
      top: 12px;
      right: auto;
      transform: translateX(-50%);
      width: var(--canvas-width);
      height: var(--canvas-height);
      overflow: hidden;
      background: #0a0f1f;
      border: 2px solid rgba(255,255,255,0.08);
      padding: 10px;
      color: #e6ebff;
      font: 12px/1.4 "VT323", monospace;
      box-sizing: border-box;
      z-index: 1000;
      display: none;
      text-align: center;
    }
    body.tileset-open .tileset-preview-sidebar { display: block; }
    .tileset-tools {
      background: #0f182a;
      border: 2px solid #000;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
      padding: 6px;
      color: #dfe7ff;
    }
    .tileset-tools-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-weight: 700;
      margin-bottom: 6px;
    }
    .tileset-tools-close {
      width: 14px;
      height: 14px;
      border: 2px solid #000;
      background: #253252;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      line-height: 1;
    }
    .tileset-tools-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      align-items: start;
      gap: 8px 10px;
    }
    .tileset-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: stretch;
    }
    .tileset-field-actions {
      gap: 6px;
    }
    .tileset-tools-grid input {
      width: 100%;
      min-width: 0;
      border: 2px solid #000;
      background: #0b1222;
      padding: 2px 6px;
      font: 14px/1.1 "VT323", monospace;
      color: #dfe7ff;
      text-align: right;
      box-sizing: border-box;
    }
    .tileset-tools-grid label,
    .tileset-tools-grid span {
      white-space: nowrap;
    }
    .tileset-tools-grid input,
    .tileset-tools-grid button,
    .tileset-color-field {
      width: 100%;
    }
    .tileset-color-field {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .tileset-eye-dropper {
      width: 52px;
      text-align: center;
    }
    .tileset-field-actions .tileset-tools-button {
      text-align: center;
    }
    .custom-palette-section { display: none; }
    body.author.has-custom-tiles .custom-palette-section { display: block; }
    .tileset-tools-button {
      width: 100%;
      border: 2px solid #000;
      background: #1a2640;
      color: #dfe7ff;
      font: 12px/1.2 "VT323", monospace;
      padding: 4px 6px;
      text-align: left;
      cursor: pointer;
    }
    .tileset-tools-divider {
      margin-top: 8px;
      height: 0;
      border-top: 2px dotted #5a6b7a;
    }
    .tileset-group-builder {
      margin-top: 10px;
      padding: 6px;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 6px;
      background: rgba(15,24,42,0.85);
    }
    .tileset-group-builder-header {
      font-size: 12px;
      letter-spacing: 1px;
      margin-bottom: 6px;
      text-transform: uppercase;
    }
    .tileset-group-meta {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(84px, 1fr));
      gap: 6px;
    }
    .tileset-group-meta label {
      font-size: 11px;
    }
    .tileset-group-meta input {
      border-radius: 4px;
    }
    .tileset-group-list-label {
      margin-top: 6px;
      font-size: 11px;
      letter-spacing: 1px;
      text-transform: uppercase;
      color: #9fb3ff;
    }
    .tileset-group-list {
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 11px;
    }
    .tileset-group-entry {
      display: flex;
      flex-direction: column;
      padding: 6px;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 6px;
      background: rgba(255,255,255,0.03);
    }
    .tileset-group-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 4px;
    }
    .tileset-group-detail {
      font-size: 10px;
      color: rgba(255,255,255,0.8);
    }
    .tileset-group-entry {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 4px 6px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(255,255,255,0.04);
    }
    .tileset-group-entry span:first-child {
      font-weight: 700;
    }
    .tileset-group-remove {
      border: none;
      background: #ff6b6b;
      color: #0b0f1f;
      font-weight: 700;
      width: 18px;
      height: 18px;
      padding: 0;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.3);
    }
    .custom-palette-group {
      margin-top: 10px;
      border: 1px dotted rgba(255,255,255,0.2);
      padding: 6px 6px 10px;
      border-radius: 6px;
      overflow-x: auto;
    }
    .custom-palette-sheet {
      display: none;
      margin: 10px 0 6px;
      padding: 6px;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 6px;
      background: rgba(10,16,32,0.6);
    }
    body.author.has-custom-tiles .custom-palette-sheet.has-preview {
      display: block;
    }
    .custom-palette-sheet-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 10px;
      letter-spacing: 1px;
      color: #9fb3ff;
      margin-bottom: 4px;
    }
    .custom-palette-sheet-zoom {
      color: rgba(255,255,255,0.7);
      font-weight: 700;
    }
    .custom-palette-sheet-frame {
      background: #0b1629;
      border: 1px dashed rgba(255,255,255,0.12);
      padding: 6px;
      display: flex;
      justify-content: center;
      align-items: center;
      max-height: 220px;
      overflow: auto;
    }
    .custom-palette-sheet-frame img {
      display: block;
      image-rendering: pixelated;
      max-width: 100%;
      max-height: 208px;
    }
    #custom-palette-grid {
      overflow-x: auto;
    }
    .custom-palette-group .editor-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(32px, 1fr));
      grid-auto-flow: row;
      gap: 8px;
    }
    .custom-palette-group-header {
      font-size: 11px;
      letter-spacing: 1px;
      margin-bottom: 6px;
      color: #9fb3ff;
      text-transform: uppercase;
    }
    .tileset-preview-stage {
      position: relative;
      width: 100%;
      height: calc(100% - 118px);
      transform-origin: 0 0;
      background: transparent;
    }
  .tileset-preview-grid {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 2;
  }
  .tileset-selection {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 3;
  }
    .tileset-preview img {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
      object-position: center;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      z-index: 1;
    }
    body.tileset-open .game-shell canvas { visibility: hidden; }
    .app-shell {
      position: absolute;
      left: 50%;
      top: 0;
      bottom: 0;
      transform: translateX(-50%);
      display: block;
      margin: 0;
      width: var(--frame-width);
      transition: width 0.15s ease;
    }
    .editor-panel {
      position: absolute;
      left: 0;
      top: 0;
      z-index: 3;
      width: calc(var(--editor-width) / var(--editor-scale));
      max-width: 360px;
      height: var(--frame-height);
      background: #0a0f1f;
      border-right: 3px solid #000;
      box-shadow: inset -4px 0 0 rgba(255,255,255,0.08);
      color: #dfe7ff;
      font: 12px/1.3 "Press Start 2P", "VT323", monospace;
      display: none;
      padding: 10px;
      box-sizing: border-box;
      image-rendering: pixelated;
      overflow-y: auto;
      transform: scale(var(--editor-scale));
      transform-origin: top left;
    }
    .custom-palette-section {
      max-height: 45vh;
      overflow-y: auto;
      padding-right: 4px;
    }
    #custom-palette-grid {
      grid-auto-rows: minmax(32px, auto);
    }
    body.editor-open .editor-panel { display: block; }
    .editor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 12px;
      letter-spacing: 1px;
    }
    .editor-section {
      margin-bottom: 12px;
    }
    .author-only { display: none; }
    body.author .author-only { display: block; }
    .editor-section h4 {
      margin: 0 0 6px 0;
      font-size: 11px;
      letter-spacing: 1px;
      color: #9fb3ff;
    }
    .editor-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(32px, 1fr));
      gap: 8px;
    }
    .editor-tile {
      width: 38px;
      height: 38px;
      border: 2px solid #000;
      background: #123;
      display: grid;
      place-items: center;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
      position: relative;
      cursor: pointer;
    }
    .editor-tile.selected {
      box-shadow:
        inset 0 0 0 2px rgba(255,255,255,0.08),
        0 0 0 2px #f6d341;
    }
    .tile-preview {
      width: 24px;
      height: 24px;
      image-rendering: pixelated;
      border: 1px solid rgba(0,0,0,0.35);
      background: #0b1629;
    }
    .editor-field {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 11px;
      color: #dfe7ff;
    }
    .editor-field input {
      background: #0f182a;
      border: 2px solid #000;
      color: #dfe7ff;
      padding: 6px 8px;
      font: 12px "Press Start 2P", "VT323", monospace;
      outline: none;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
    }
    .editor-actions {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 11px;
      color: #dfe7ff;
    }
    .editor-actions button {
      background: #123;
      border: 2px solid #000;
      color: #f6d341;
      padding: 6px 8px;
      font: 12px "Press Start 2P", "VT323", monospace;
      cursor: pointer;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
    }
    .editor-actions button.active {
      background: #1c2f55;
      color: #fff;
      box-shadow: inset 0 0 0 2px #f6d341;
    }
    .editor-hint { margin-top: 10px; font-size: 10px; color: #9fb3ff; }
    body.editor-open .game-shell canvas { cursor: none; }
    /* HUD now rendered on canvas; hide DOM HUD shell */
    .hud { display:none; }
    .hud-icon-coin {
      width: 10px; height: 14px;
      background:#f5d000;
      box-shadow: -1px 2px 0 #000, 1px 2px 0 #000;
    }
    .hud-block { display:flex; align-items:center; gap:6px; }
    .hud small { font-size:10px; }
    .hud-pmeter { display:flex; align-items:center; gap:6px; }
    .pmeter-label { letter-spacing:1px; }
    .pmeter-bar { display:flex; gap:2px; }
    .pmeter-seg {
      width: 10px; height: 12px;
      background:#000;
      box-shadow: inset 0 0 0 2px #fff;
      transition: background 0.12s;
    }
    .pmeter-seg.filled { background:#ffb347; box-shadow: inset 0 0 0 2px #000; }
    .hud-speed-chip {
      display: flex;
      align-items: center;
      gap: 6px;
      background: #b8e8ff;
      border: 4px solid #000;
      padding: 4px 10px;
      box-shadow: inset 0 0 0 3px #7fb7d6;
    }
    .hint-toggle {
      position: fixed;
      top: 12px;
      right: 12px;
      width: 32px;
      height: 32px;
      border: 2px solid #000;
      border-radius: 8px;
      background: #1a2640;
      color: #dfe7ff;
      font: 16px/1 "VT323", monospace;
      display: grid;
      place-items: center;
      cursor: pointer;
      z-index: 1001;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
    }
    .hint-panel {
      position: fixed;
      top: 52px;
      right: 12px;
      color: #cbd5e1;
      font: 12px/1.3 system-ui, sans-serif;
      opacity: .95;
      background: rgba(0,0,0,.65);
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.08);
      max-width: 520px;
      display: none;
      z-index: 1001;
    }
    .hint-panel.open { display: block; }
    .hint-panel b { color:#fff; }
    .debug-panel {
      position: fixed; top: 12px; left: 12px;
      background: rgba(0,0,0,0.6);
      color: #dce4ff;
      font: 12px/1.4 "VT323", monospace;
      padding: 8px 10px;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 8px;
      min-width: 120px;
      pointer-events: none;
    }
    .debug-panel div { display:flex; justify-content: space-between; gap: 8px; }

    /* Inventory overlay (SMB3-style) */
    .inventory-overlay {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(0, 0, 0, 0.6);
      z-index: 200;
      image-rendering: pixelated;
      font-family: "Press Start 2P", "VT323", monospace;
    }
    .inventory-overlay.open { display: grid; }
    .inventory-panel {
      background: #0b74c5;
      border: 4px solid #fff;
      box-shadow:
        inset 0 0 0 3px #000,
        0 0 0 2px #000,
        0 0 12px rgba(0,0,0,0.45);
      padding: 10px 12px 12px;
      width: 560px;
    }
    .inventory-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      color: #ffe28a;
      text-shadow: 1px 0 #000, -1px 0 #000, 0 1px #000, 0 -1px #000;
      font-size: 13px;
    }
    .inventory-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 6px;
    }
    .inventory-slot {
      position: relative;
      background: #0f6cb6;
      border: 3px solid #fff;
      box-shadow: inset 0 0 0 2px #000;
      height: 62px;
      color: #ffe28a;
      display: grid;
      place-items: center;
      text-shadow: 1px 0 #000, -1px 0 #000, 0 1px #000, 0 -1px #000;
    }
    .inventory-slot.empty { background: #0d64a9; color: #2c4f73; }
    .inventory-slot.selected {
      box-shadow:
        inset 0 0 0 2px #000,
        0 0 0 3px #f6d341;
    }
    .inventory-icon {
      font-size: 28px;
      line-height: 1;
      pointer-events: none;
    }
    .inventory-count {
      position: absolute;
      bottom: 4px;
      right: 6px;
      font-size: 11px;
    }
    .inventory-footer {
      margin-top: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #ffe28a;
      text-shadow: 1px 0 #000, -1px 0 #000, 0 1px #000, 0 -1px #000;
      font-size: 12px;
    }
    .inventory-hint {
      color: #fff;
      font-size: 11px;
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <div class="tileset-preview-sidebar">
      <div class="tileset-tools" aria-label="Grid settings">
        <div class="tileset-tools-header">
          <span>Grid Settings</span>
          <span class="tileset-tools-close" aria-hidden="true">X</span>
        </div>
        <div class="tileset-tools-grid">
          <div class="tileset-field">
            <label for="tileset-grid-x">X</label>
            <input id="tileset-grid-x" type="text" value="0" inputmode="numeric"/>
          </div>
          <div class="tileset-field">
            <label for="tileset-grid-y">Y</label>
            <input id="tileset-grid-y" type="text" value="0" inputmode="numeric"/>
          </div>
          <div class="tileset-field">
            <label for="tileset-grid-w">Width</label>
            <input id="tileset-grid-w" type="text" value="16" inputmode="numeric"/>
          </div>
          <div class="tileset-field">
            <label for="tileset-grid-h">Height</label>
            <input id="tileset-grid-h" type="text" value="16" inputmode="numeric"/>
          </div>
          <div class="tileset-field">
            <label for="tileset-grid-padx">Pad X</label>
            <input id="tileset-grid-padx" type="text" value="0" inputmode="numeric"/>
          </div>
          <div class="tileset-field">
            <label for="tileset-grid-pady">Pad Y</label>
            <input id="tileset-grid-pady" type="text" value="0" inputmode="numeric"/>
          </div>
          <div class="tileset-field">
            <label for="tileset-remove-color">Remove BG</label>
            <div class="tileset-color-field">
              <input id="tileset-remove-color" type="text" value="#000000"/>
              <button class="tileset-tools-button tileset-eye-dropper" id="tileset-eye-dropper" type="button" aria-label="Pick color from tileset">Pick</button>
            </div>
          </div>
          <div class="tileset-field">
            <label for="tileset-remove-tolerance">Tolerance</label>
            <input id="tileset-remove-tolerance" type="text" value="20" inputmode="numeric"/>
          </div>
          <div class="tileset-field">
            <label for="tileset-palette-name">Palette Name</label>
            <input id="tileset-palette-name" type="text" value="Custom" maxlength="24"/>
          </div>
          <div class="tileset-field tileset-field-actions">
            <label>Actions</label>
            <button class="tileset-tools-button" id="tileset-remove-apply" type="button">Remove Selected Color</button>
            <button class="tileset-tools-button" id="tileset-cut-sprites" type="button">Cut Sprites</button>
          </div>
        </div>
        <div class="tileset-tools-divider" aria-hidden="true"></div>
        <div class="tileset-group-builder">
          <div class="tileset-group-builder-header">Groups</div>
          <div class="tileset-group-meta">
            <label for="tileset-group-name">Name</label>
            <input id="tileset-group-name" type="text" maxlength="24" placeholder="Ground pieces">
            <label for="tileset-group-x">X</label>
            <input id="tileset-group-x" type="text" value="0" inputmode="numeric">
            <label for="tileset-group-y">Y</label>
            <input id="tileset-group-y" type="text" value="0" inputmode="numeric">
            <label for="tileset-group-w">W</label>
            <input id="tileset-group-w" type="text" value="256" inputmode="numeric">
            <label for="tileset-group-h">H</label>
            <input id="tileset-group-h" type="text" value="128" inputmode="numeric">
            <button class="tileset-tools-button" id="tileset-group-add" type="button">Add Group</button>
            <button class="tileset-tools-button" id="tileset-group-select" type="button">Select Tiles</button>
          </div>
          <div class="tileset-group-list-label">Saved groups</div>
          <div class="tileset-group-list" id="tileset-group-list"></div>
        </div>
      </div>
      <div class="tileset-preview-stage">
        <img id="tileset-preview-image" alt="Tileset preview"/>
      <canvas class="tileset-preview-grid" id="tileset-preview-grid"></canvas>
      <canvas class="tileset-selection" id="tileset-selection-canvas"></canvas>
    </div>
    </div>
    <div id="editor-panel" class="editor-panel" aria-label="Level editor palette">
    <div class="editor-header">
      <span>PALETTE</span>
      <span>Press E</span>
    </div>
    <div class="editor-section">
      <h4>TERRAIN</h4>
      <div class="editor-grid" id="terrain-grid">
        <div class="editor-tile solid" data-tile="#" title="Ground"><canvas class="tile-preview" width="8" height="8" data-tile="#"></canvas></div>
        <div class="editor-tile sand" data-tile="S" title="Sand"><canvas class="tile-preview" width="8" height="8" data-tile="S"></canvas></div>
        <div class="editor-tile ice" data-tile="I" title="Ice"><canvas class="tile-preview" width="8" height="8" data-tile="I"></canvas></div>
      </div>
    </div>
    <div class="editor-section">
      <h4>OBJECTS</h4>
      <div class="editor-grid" id="object-grid">
        <div class="editor-tile" data-tile="B" title="Brick"><canvas class="tile-preview" width="8" height="8" data-tile="B"></canvas></div>
        <div class="editor-tile" data-tile="?" title="? Block"><canvas class="tile-preview" width="8" height="8" data-tile="?"></canvas></div>
        <div class="editor-tile" data-tile="u" title="Used Block"><canvas class="tile-preview" width="8" height="8" data-tile="u"></canvas></div>
        <div class="editor-tile" data-tile="C" title="Coin"><canvas class="tile-preview" width="8" height="8" data-tile="C"></canvas></div>
      </div>
    </div>
    <div class="editor-section">
      <h4>ENEMIES</h4>
      <div class="editor-grid" id="enemy-grid">
        <div class="editor-tile" data-tile="E" title="Enemy Spawn"><canvas class="tile-preview" width="8" height="8" data-tile="E"></canvas></div>
      </div>
    </div>
    <div class="editor-section">
      <h4>SPAWNS</h4>
      <div class="editor-grid" id="spawn-grid">
        <div class="editor-tile" data-tile="P" title="Player Spawn"><canvas class="tile-preview" width="8" height="8" data-tile="P"></canvas></div>
      </div>
    </div>
    <div class="editor-section author-only">
      <h4>AUTHOR TOOLS</h4>
        <div class="editor-field">
          <label for="sprite-upload">Sprite Upload</label>
          <input id="sprite-upload" type="file" accept="image/png, image/jpeg"/>
        </div>
        <div class="editor-field">
          <label for="tileset-upload">Tileset Upload</label>
          <input id="tileset-upload" type="file" accept="image/png, image/jpeg"/>
        </div>
        <div class="editor-hint">Author-only tools</div>
      </div>
    <div class="editor-section author-only">
      <h4>TIMELAPSE</h4>
      <div class="editor-actions">
        <button id="timelapse-toggle" type="button">Timelapse OFF</button>
        <button id="timelapse-clear" type="button">Clear Frames</button>
        <button id="timelapse-download" type="button">Download Frames</button>
        <button id="timelapse-download-webm" type="button">Download WebM</button>
      </div>
      <div class="editor-hint" id="timelapse-status">0 frames</div>
    </div>
    <div class="editor-section author-only">
      <h4>LEVEL CONTROL</h4>
      <div class="editor-actions">
        <button id="level-save-button" type="button">Save Level</button>
        <button id="level-reset-button" type="button">Reset Level</button>
      </div>
    </div>
    <div class="editor-section author-only custom-palette-section" id="custom-palette-section">
      <h4 id="custom-palette-title">CUSTOM</h4>
      <div class="editor-actions">
        <button id="custom-palette-clear" type="button">Clear Custom Tiles</button>
      </div>
      <div class="custom-palette-sheet" id="custom-palette-sheet">
        <div class="custom-palette-sheet-header">
          <span>Sprite Sheet</span>
          <span class="custom-palette-sheet-zoom" id="custom-palette-sheet-zoom"></span>
        </div>
        <div class="custom-palette-sheet-frame">
          <img id="custom-palette-sheet-image" alt="Sprite sheet preview"/>
        </div>
      </div>
      <div class="editor-grid" id="custom-palette-grid"></div>
    </div>
    <div class="editor-field">
      <label for="editor-label-input">Label</label>
      <input id="editor-label-input" type="text" maxlength="24" placeholder="Type to tag block"/>
    </div>
    <div class="editor-field">
      <label for="editor-text-stamp">Stamp Text (uses selected tile)</label>
      <input id="editor-text-stamp" type="text" maxlength="24" placeholder="Enter text"/>
      <div class="editor-actions">
        <button id="editor-stamp-button" type="button">Stamp</button>
      </div>
    </div>
    <div class="editor-hint">Left click paint · Right click erase · E to toggle</div>
  </div>
  <div class="game-shell">
    <canvas id="c" width="912" height="816"></canvas>
    <div class="tileset-preview" id="tileset-preview" aria-label="Tileset preview"></div>
    <div class="hud" aria-label="HUD">
  <div class="hud-bar">
    <div class="hud-section hud-left">
      <div class="hud-block">
        <span>WORLD</span>
        <span id="hud-world">1</span>
      </div>
      <div class="hud-block">
        <small>M</small>
        <span>x</span>
        <span id="hud-lives">3</span>
      </div>
    </div>
    <div class="hud-section hud-center">
      <div class="hud-speed-chip">
        <span>SPD</span>
        <span id="hud-spd">0</span>
      </div>
      <div class="hud-pmeter" aria-label="P-Meter">
        <span class="pmeter-label">P</span>
        <div class="pmeter-bar" id="hud-pmeter"></div>
      </div>
      <div class="hud-speed-chip">
        <span>FLY</span>
        <span id="hud-fly">0</span>
      </div>
    </div>
    <div class="hud-section hud-right">
      <div class="hud-block">
        <span>FORM</span>
        <span id="hud-form">SM</span>
      </div>
      <div class="hud-block">
        <div class="hud-icon-coin"></div>
        <span>x</span>
        <span id="hud-coins">00</span>
      </div>
      <div class="hud-block">
        <span id="hud-score">000000</span>
      </div>
      <div class="hud-block">
        <span>T</span>
        <span id="hud-time">300</span>
      </div>
      <div class="hud-block">
        <span>ACC</span>
        <span id="hud-acc">0</span>
      </div>
      <div class="hud-block">
        <span>★</span>
        <span id="hud-star">0</span>
      </div>
    </div>
  </div>
</div>
</div>
</div>
<button class="hint-toggle" id="hint-toggle" type="button" aria-label="Toggle hints">?</button>
<div class="hint-panel" id="hint-panel">
  <b>Controls:</b> Arrow keys move A? <b>Z</b> jump A? <b>X</b> run A? <b>C</b> fire/tail/hammer A? <b>V</b> statue A? <b>R</b> restart<br/>
  <b>Goal:</b> Collect coins, hit ? blocks, stomp enemies.<br/>
  <b>Jump range:</b> Walk <span id="jump-walk">--</span> tiles A? Run <span id="jump-run">--</span> tiles
</div>
  <div class="inventory-overlay" id="inventory-overlay" aria-label="Inventory">
  <div class="inventory-panel">
    <div class="inventory-header">
      <span>ITEM STORAGE</span>
      <span class="inventory-hint">Arrows move · Enter uses · Esc closes</span>
    </div>
    <div class="inventory-grid" id="inventory-grid" role="grid"></div>
    <div class="inventory-footer">
      <span id="inventory-selected">--</span>
      <span class="inventory-hint" id="inventory-footer-hint">Use</span>
    </div>
  </div>
</div>

<script>
(() => {
  // -----------------------------
  // Config
  // -----------------------------
  const AUTHOR_LOGIN_ENDPOINT = "/api/author-login";
  const AUTHOR_LOGOUT_ENDPOINT = "/api/author-logout";
  const AUTHOR_STATUS_ENDPOINT = "/api/author-status";
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });
  const tilesetUploadEl = document.getElementById("tileset-upload");
  const tilesetPreviewPanel = document.getElementById("tileset-preview");
  const tilesetPreviewStage = document.querySelector(".tileset-preview-stage");
  const tilesetPreviewSidebar = document.querySelector(".tileset-preview-sidebar");
  const tilesetPreviewImage = document.getElementById("tileset-preview-image");
  const tilesetPreviewGrid = document.getElementById("tileset-preview-grid");
  const tilesetGridX = document.getElementById("tileset-grid-x");
  const tilesetGridY = document.getElementById("tileset-grid-y");
  const tilesetGridW = document.getElementById("tileset-grid-w");
  const tilesetGridH = document.getElementById("tileset-grid-h");
  const tilesetGridPadX = document.getElementById("tileset-grid-padx");
  const tilesetGridPadY = document.getElementById("tileset-grid-pady");
  const tilesetRemoveColor = document.getElementById("tileset-remove-color");
  const tilesetEyeDropper = document.getElementById("tileset-eye-dropper");
  const tilesetRemoveApply = document.getElementById("tileset-remove-apply");
  const tilesetRemoveTolerance = document.getElementById("tileset-remove-tolerance");
  const tilesetPaletteName = document.getElementById("tileset-palette-name");
  const tilesetCutSprites = document.getElementById("tileset-cut-sprites");
  const tilesetToolsClose = document.querySelector(".tileset-tools-close");
  const tilesetGroupName = document.getElementById("tileset-group-name");
  const tilesetGroupX = document.getElementById("tileset-group-x");
  const tilesetGroupY = document.getElementById("tileset-group-y");
  const tilesetGroupW = document.getElementById("tileset-group-w");
  const tilesetGroupH = document.getElementById("tileset-group-h");
  const tilesetGroupAdd = document.getElementById("tileset-group-add");
  const tilesetGroupSelect = document.getElementById("tileset-group-select");
  const tilesetGroupList = document.getElementById("tileset-group-list");
  const hintToggle = document.getElementById("hint-toggle");
  const hintPanel = document.getElementById("hint-panel");
  const timelapseToggle = document.getElementById("timelapse-toggle");
  const timelapseClear = document.getElementById("timelapse-clear");
  const timelapseDownload = document.getElementById("timelapse-download");
  const timelapseDownloadWebm = document.getElementById("timelapse-download-webm");
  const timelapseStatus = document.getElementById("timelapse-status");
  const levelSaveButton = document.getElementById("level-save-button");
  const levelResetButton = document.getElementById("level-reset-button");
  const customPaletteSection = document.getElementById("custom-palette-section");
  const customPaletteTitle = document.getElementById("custom-palette-title");
  const customPaletteGrid = document.getElementById("custom-palette-grid");
  const customPaletteClear = document.getElementById("custom-palette-clear");
  const customPaletteSheet = document.getElementById("custom-palette-sheet");
  const customPaletteSheetImage = document.getElementById("custom-palette-sheet-image");
  const customPaletteSheetZoom = document.getElementById("custom-palette-sheet-zoom");
  const customTileSprites = new Map(); // tileId -> Image
  const customTileMap = new Map(); // key: "tx,ty" -> tileId
  const customTileDataUrls = new Map(); // tileId -> data url
  const RESERVED_TILES = new Set([".", "#", "B", "I", "S", "W", "?", "u", "C", "E", "P"]);
  const customIdForIndex = (index) => `~${index}`;
  const LEVEL_SAVE_KEY = "smb3-level-snapshot";
  const timelapseFrames = [];
  let timelapseEnabled = false;
  let timelapseCaptureActive = false;
  const tilesetGroups = [];
  let tilesetGroupCounter = 0;
  let tilesetPreviewUrl = null;
  let tilesetZoom = 1;
  let tilesetPanX = 0;
  let tilesetPanY = 0;
  let tilesetPanning = false;
  let tilesetPanStartX = 0;
  let tilesetPanStartY = 0;
  let customPaletteSheetUrl = null;
  let customPaletteSheetScale = 1;
  let customPaletteSheetCols = null;
  let customPaletteSheetRows = null;
  const setAuthorClass = (enabled) => {
    document.body.classList.toggle("author", enabled);
  };
  const isAuthor = () => document.body.classList.contains("author");
  if (hintToggle && hintPanel) {
    hintToggle.addEventListener("click", () => {
      hintPanel.classList.toggle("open");
    });
  }
  const updateTimelapseStatus = () => {
    if (!timelapseStatus) return;
    timelapseStatus.textContent = `${timelapseFrames.length} frame${timelapseFrames.length === 1 ? "" : "s"}`;
  };
  const demoCaptureQueue = [];
  const tilesetSelectionCanvas = document.getElementById("tileset-selection-canvas");
  const tilesetSelectionCtx = tilesetSelectionCanvas ? tilesetSelectionCanvas.getContext("2d") : null;
  let lastTilesetState = null;
  let tilesetSelection = null;
  let tilesetSelecting = false;
  let tilesetSelectionStart = null;
  let tilesetSelectionEnd = null;
  let tilesetSelectionModeActive = false;
  const captureTimelapseFrame = () => {
    if (!timelapseEnabled) return;
    try {
      timelapseCaptureActive = true;
      render();
      timelapseFrames.push(canvas.toDataURL("image/png"));
      timelapseCaptureActive = false;
      render();
      updateTimelapseStatus();
    } catch (err) {
      // ignore capture failures
      timelapseCaptureActive = false;
    }
  };
  const drawTilesetSelection = () => {
    if (!tilesetSelectionCtx || !lastTilesetState) return;
    const { bounds, stepX, stepY } = lastTilesetState;
    if (!tilesetSelection) {
      tilesetSelectionCtx.clearRect(0, 0, tilesetSelectionCanvas.width, tilesetSelectionCanvas.height);
      return;
    }
    const { x, y, w, h } = tilesetSelection;
    const rectX = x;
    const rectY = y;
    tilesetSelectionCtx.clearRect(0, 0, tilesetSelectionCanvas.width, tilesetSelectionCanvas.height);
    tilesetSelectionCtx.fillStyle = "rgba(246, 211, 65, 0.2)";
    tilesetSelectionCtx.strokeStyle = "rgba(246, 211, 65, 0.7)";
    tilesetSelectionCtx.lineWidth = 2 / Math.max(tilesetZoom, 1);
    tilesetSelectionCtx.fillRect(rectX, rectY, w, h);
    tilesetSelectionCtx.strokeRect(rectX + 0.5, rectY + 0.5, w - 1, h - 1);
  };
  const applySelectionToInputs = () => {
    if (!tilesetSelection) return;
    if (tilesetGroupX) tilesetGroupX.value = `${Math.round(tilesetSelection.x)}`;
    if (tilesetGroupY) tilesetGroupY.value = `${Math.round(tilesetSelection.y)}`;
    if (tilesetGroupW) tilesetGroupW.value = `${Math.round(tilesetSelection.w)}`;
    if (tilesetGroupH) tilesetGroupH.value = `${Math.round(tilesetSelection.h)}`;
  };
  const getTilesetNaturalPoint = (event) => {
    if (!lastTilesetState || !tilesetPreviewImage) return null;
    const imgRect = tilesetPreviewImage.getBoundingClientRect();
    const relX = event.clientX - imgRect.left;
    const relY = event.clientY - imgRect.top;
    if (relX < 0 || relY < 0 || relX > imgRect.width || relY > imgRect.height) return null;
    const { naturalW, naturalH } = lastTilesetState;
    const scaleX = naturalW ? imgRect.width / naturalW : 1;
    const scaleY = naturalH ? imgRect.height / naturalH : 1;
    const pixelX = relX / scaleX;
    const pixelY = relY / scaleY;
    const { stepX, stepY } = lastTilesetState;
    const cellX = Math.floor(pixelX / stepX);
    const cellY = Math.floor(pixelY / stepY);
    if (cellX < 0 || cellY < 0) return null;
    return {
      cellX,
      cellY,
      pixelX: cellX * stepX,
      pixelY: cellY * stepY,
    };
  };
  const updateSelectionCells = (startCell, endCell) => {
    if (!lastTilesetState || !startCell || !endCell) return;
    const { stepX, stepY, bounds } = lastTilesetState;
    const minX = Math.min(startCell.cellX, endCell.cellX);
    const minY = Math.min(startCell.cellY, endCell.cellY);
    const width = (Math.abs(startCell.cellX - endCell.cellX) + 1) * stepX;
    const height = (Math.abs(startCell.cellY - endCell.cellY) + 1) * stepY;
    tilesetSelection = {
      x: bounds.offsetX + minX * stepX,
      y: bounds.offsetY + minY * stepY,
      w: width,
      h: height,
      startCell,
      endCell,
    };
    drawTilesetSelection();
    applySelectionToInputs();
  };
  const flushDemoCapture = () => {
    if (demoCaptureQueue.length === 0) return;
    // placeholder for future demo recording logic; clear queue each frame
    demoCaptureQueue.length = 0;
  };
  const parseGroupValue = (el, fallback) => {
    if (!el) return fallback;
    const val = Number.parseInt(el.value, 10);
    return Number.isFinite(val) ? val : fallback;
  };
  const renderTilesetGroups = () => {
    if (!tilesetGroupList) return;
    tilesetGroupList.innerHTML = "";
    tilesetGroups.forEach((group) => {
      const entry = document.createElement("div");
      entry.className = "tileset-group-entry";
      const header = document.createElement("div");
      header.className = "tileset-group-header";
      const title = document.createElement("span");
      title.textContent = group.name;
      const remove = document.createElement("button");
      remove.type = "button";
      remove.className = "tileset-group-remove";
      remove.textContent = "×";
      remove.addEventListener("click", () => {
        const idx = tilesetGroups.findIndex((g) => g.id === group.id);
        if (idx >= 0) {
          tilesetGroups.splice(idx, 1);
          renderTilesetGroups();
        }
      });
      header.append(title, remove);
      const detail = document.createElement("div");
      detail.className = "tileset-group-detail";
      detail.textContent = `Pos: ${group.x}/${group.y} · Size: ${group.w}×${group.h}`;
      entry.append(header, detail);
      tilesetGroupList.appendChild(entry);
    });
  };
  const createGroup = (x, y, w, h) => {
    const name = (tilesetGroupName ? tilesetGroupName.value.trim() : "") || `Group ${tilesetGroups.length + 1}`;
    tilesetGroupCounter += 1;
    tilesetGroups.push({ id: tilesetGroupCounter, name, x, y, w, h });
    renderTilesetGroups();
    tilesetSelectionModeActive = false;
    if (tilesetGroupSelect) tilesetGroupSelect.textContent = "Select Tiles";
    tilesetSelection = null;
    drawTilesetSelection();
  };
  if (tilesetGroupAdd) {
    tilesetGroupAdd.addEventListener("click", () => {
      const fallbackX = parseGroupValue(tilesetGroupX, 0);
      const fallbackY = parseGroupValue(tilesetGroupY, 0);
      const fallbackW = Math.max(1, parseGroupValue(tilesetGroupW, 16));
      const fallbackH = Math.max(1, parseGroupValue(tilesetGroupH, 16));
      const { x, y, w, h } = tilesetSelection || { x: fallbackX, y: fallbackY, w: fallbackW, h: fallbackH };
      createGroup(x, y, w, h);
    });
  }
  if (tilesetGroupSelect) {
    tilesetGroupSelect.addEventListener("click", () => {
      tilesetSelectionModeActive = !tilesetSelectionModeActive;
      tilesetGroupSelect.textContent = tilesetSelectionModeActive ? "Selecting..." : "Select Tiles";
      if (!tilesetSelectionModeActive) {
        tilesetSelection = null;
        drawTilesetSelection();
      }
    });
  }
  if (timelapseToggle) {
    timelapseToggle.addEventListener("click", () => {
      timelapseEnabled = !timelapseEnabled;
      timelapseToggle.textContent = timelapseEnabled ? "Timelapse ON" : "Timelapse OFF";
    });
  }
  if (timelapseClear) {
    timelapseClear.addEventListener("click", () => {
      timelapseFrames.length = 0;
      updateTimelapseStatus();
    });
  }
  if (timelapseDownload) {
    timelapseDownload.addEventListener("click", () => {
      if (timelapseFrames.length === 0) {
        pushSystemChat("No timelapse frames to download.");
        return;
      }
      timelapseFrames.forEach((dataUrl, idx) => {
        const a = document.createElement("a");
        a.href = dataUrl;
        a.download = `timelapse-${String(idx + 1).padStart(4, "0")}.png`;
        document.body.appendChild(a);
        a.click();
        a.remove();
      });
    });
  }
  if (timelapseDownloadWebm) {
    timelapseDownloadWebm.addEventListener("click", () => {
      if (timelapseFrames.length === 0) {
        pushSystemChat("No timelapse frames to export.");
        return;
      }
      if (!("MediaRecorder" in window)) {
        pushSystemChat("WebM export not supported in this browser.");
        return;
      }
      const pickMimeType = () => {
        const candidates = [
          "video/webm;codecs=vp9",
          "video/webm;codecs=vp8",
          "video/webm",
        ];
        for (const type of candidates) {
          if (MediaRecorder.isTypeSupported(type)) return type;
        }
        return "";
      };
      const mimeType = pickMimeType();
      if (!mimeType) {
        pushSystemChat("No supported WebM encoder found.");
        return;
      }
      const renderCanvas = document.createElement("canvas");
      renderCanvas.width = canvas.width;
      renderCanvas.height = canvas.height;
      const rctx = renderCanvas.getContext("2d");
      if (!rctx) return;
      const stream = renderCanvas.captureStream(1); // 1 fps
      let recorder;
      try {
        recorder = new MediaRecorder(stream, { mimeType });
      } catch (err) {
        pushSystemChat("WebM recorder failed to старт.");
        return;
      }
      const chunks = [];
      recorder.ondataavailable = (ev) => {
        if (ev.data && ev.data.size > 0) chunks.push(ev.data);
      };
      recorder.onerror = () => {
        pushSystemChat("WebM recording error.");
      };
      recorder.onstop = () => {
        const blob = new Blob(chunks, { type: "video/webm" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "timelapse.webm";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      };
      recorder.start();
      let i = 0;
      const drawNext = () => {
        if (i >= timelapseFrames.length) {
          setTimeout(() => recorder.stop(), 200);
          return;
        }
        const img = new Image();
        img.onload = () => {
          rctx.clearRect(0, 0, renderCanvas.width, renderCanvas.height);
          rctx.drawImage(img, 0, 0, renderCanvas.width, renderCanvas.height);
          i += 1;
          setTimeout(drawNext, 1000);
        };
        img.onerror = () => {
          i += 1;
          setTimeout(drawNext, 1000);
        };
        img.src = timelapseFrames[i];
      };
      drawNext();
    });
  }
  async function refreshAuthorStatus() {
    try {
      const res = await fetch(AUTHOR_STATUS_ENDPOINT, { credentials: "include" });
      if (!res.ok) {
        setAuthorClass(false);
        return false;
      }
      const data = await res.json();
      const enabled = Boolean(data && data.author);
      setAuthorClass(enabled);
      return enabled;
    } catch (err) {
      setAuthorClass(false);
      return false;
    }
  }
  async function authorLogin(pass) {
    if (!pass) return false;
    try {
      const res = await fetch(AUTHOR_LOGIN_ENDPOINT, {
        method: "POST",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ pass }),
      });
      if (!res.ok) {
        setAuthorClass(false);
        return false;
      }
      const data = await res.json();
      const enabled = Boolean(data && data.author);
      setAuthorClass(enabled);
      return enabled;
    } catch (err) {
      return false;
    }
  }
  async function authorLogout() {
    try {
      await fetch(AUTHOR_LOGOUT_ENDPOINT, {
        method: "POST",
        credentials: "include",
      });
    } catch (err) {
      // ignore network errors
    }
    setAuthorClass(false);
    return false;
  }
  function handleAuthorCommand(text) {
    const raw = text.replace("/author", "").trim();
    if (!raw) {
      beginAuthorPrompt();
      return true;
    }
    const parts = raw.split(/\s+/);
    const action = parts[0].toLowerCase();
    if (action === "logout" || action === "off") {
      authorLogout().then(() => {
        pushSystemChat("Author mode disabled.");
      });
      return false;
    }
    if (action === "status") {
      refreshAuthorStatus().then((enabled) => {
        pushSystemChat(enabled ? "Author mode enabled." : "Author mode disabled.");
      });
      return false;
    }
    beginAuthorPrompt();
    return true;
  }
  const setTilesetPreview = (file) => {
    if (!tilesetPreviewPanel || !tilesetPreviewImage) return;
    if (tilesetPreviewUrl) {
      URL.revokeObjectURL(tilesetPreviewUrl);
      tilesetPreviewUrl = null;
    }
    if (!file) {
      tilesetPreviewImage.removeAttribute("src");
      tilesetPreviewPanel.classList.remove("visible");
      document.body.classList.remove("tileset-open");
      return;
    }
    tilesetPreviewUrl = URL.createObjectURL(file);
    tilesetPreviewImage.src = tilesetPreviewUrl;
    tilesetPreviewPanel.classList.add("visible");
    document.body.classList.add("tileset-open");
    tilesetPanX = 0;
    tilesetPanY = 0;
    setTilesetZoom(1);
    requestAnimationFrame(updateTilesetGrid);
  };

  if (tilesetUploadEl) {
    tilesetUploadEl.addEventListener("change", () => {
      const file = tilesetUploadEl.files && tilesetUploadEl.files[0];
      setTilesetPreview(file || null);
    });
  }

  const readGridValue = (inputEl, fallback) => {
    if (!inputEl) return fallback;
    const n = Number.parseInt(inputEl.value, 10);
    return Number.isFinite(n) ? n : fallback;
  };

  const normalizeHex = (value) => {
    if (!value) return "#000000";
    const v = value.trim();
    if (/^#[0-9a-f]{6}$/i.test(v)) return v.toLowerCase();
    if (/^#[0-9a-f]{3}$/i.test(v)) {
      return `#${v[1]}${v[1]}${v[2]}${v[2]}${v[3]}${v[3]}`.toLowerCase();
    }
    return "#000000";
  };

  const updateCustomSheetPreview = (url, scale = 1) => {
    customPaletteSheetUrl = url || null;
    customPaletteSheetScale = scale || 1;
    const hasUrl = !!customPaletteSheetUrl;
    if (customPaletteSheet) {
      customPaletteSheet.classList.toggle("has-preview", hasUrl);
    }
    if (customPaletteSheetImage) {
      if (hasUrl) {
        customPaletteSheetImage.src = customPaletteSheetUrl;
      } else {
        customPaletteSheetImage.removeAttribute("src");
      }
    }
    if (customPaletteSheetZoom) {
      customPaletteSheetZoom.textContent = hasUrl ? `${Math.round(customPaletteSheetScale * 100)}%` : "";
    }
  };

  const applyCustomPaletteLayout = (gridEl) => {
    if (!gridEl) return;
    const cols = customPaletteSheetCols;
    if (cols && Number.isFinite(cols) && cols > 0) {
      gridEl.style.gridTemplateColumns = `repeat(${cols}, 38px)`;
      gridEl.style.width = "max-content";
    } else {
      gridEl.style.gridTemplateColumns = "";
      gridEl.style.width = "";
    }
  };

  const getTilesetImageBounds = () => {
    if (!tilesetPreviewImage) return null;
    const baseW = tilesetPreviewImage.offsetWidth;
    const baseH = tilesetPreviewImage.offsetHeight;
    if (baseW <= 0 || baseH <= 0) return null;
    const naturalW = tilesetPreviewImage.naturalWidth || baseW;
    const naturalH = tilesetPreviewImage.naturalHeight || baseH;
    const scale = Math.min(baseW / naturalW, baseH / naturalH);
    const drawW = naturalW * scale;
    const drawH = naturalH * scale;
    const offsetX = (baseW - drawW) / 2;
    const offsetY = (baseH - drawH) / 2;
    return { baseW, baseH, drawW, drawH, offsetX, offsetY };
  };

  const setGridInputs = (x, y, w, h) => {
    if (tilesetGridX) tilesetGridX.value = `${Math.max(0, Math.round(x))}`;
    if (tilesetGridY) tilesetGridY.value = `${Math.max(0, Math.round(y))}`;
    if (tilesetGridW) tilesetGridW.value = `${Math.max(1, Math.round(w))}`;
    if (tilesetGridH) tilesetGridH.value = `${Math.max(1, Math.round(h))}`;
  };

  const setTilesetZoom = (nextZoom, anchorX = 0.5, anchorY = 0.5) => {
    tilesetZoom = Math.min(6, Math.max(0.5, nextZoom));
    if (tilesetPreviewStage) {
      tilesetPreviewStage.style.transformOrigin = `${anchorX * 100}% ${anchorY * 100}%`;
      tilesetPreviewStage.style.transform = `translate(${tilesetPanX}px, ${tilesetPanY}px) scale(${tilesetZoom})`;
    }
  };

  const updateTilesetGrid = () => {
    if (!tilesetPreviewGrid || !tilesetPreviewImage) return;
    if (!document.body.classList.contains("tileset-open")) {
      const ctx = tilesetPreviewGrid.getContext("2d");
      ctx && ctx.clearRect(0, 0, tilesetPreviewGrid.width, tilesetPreviewGrid.height);
      return;
    }
    const bounds = getTilesetImageBounds();
    if (!bounds) return;
    const dpr = window.devicePixelRatio || 1;
    tilesetPreviewGrid.width = Math.round(bounds.baseW * dpr);
    tilesetPreviewGrid.height = Math.round(bounds.baseH * dpr);
    tilesetPreviewGrid.style.width = `${Math.round(bounds.baseW)}px`;
    tilesetPreviewGrid.style.height = `${Math.round(bounds.baseH)}px`;
    const ctx = tilesetPreviewGrid.getContext("2d");
    if (!ctx) return;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, bounds.baseW, bounds.baseH);
    const { drawW, drawH, offsetX, offsetY } = bounds;
    const naturalW = tilesetPreviewImage.naturalWidth || drawW;
    const naturalH = tilesetPreviewImage.naturalHeight || drawH;
    const scale = Math.min(bounds.baseW / naturalW, bounds.baseH / naturalH);
    const x = readGridValue(tilesetGridX, 0);
    const y = readGridValue(tilesetGridY, 0);
    const w = Math.max(1, readGridValue(tilesetGridW, 16));
    const h = Math.max(1, readGridValue(tilesetGridH, 16));
    const padX = Math.max(0, readGridValue(tilesetGridPadX, 0));
    const padY = Math.max(0, readGridValue(tilesetGridPadY, 0));
    const stepX = w + padX;
    const stepY = h + padY;
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 1 / Math.max(0.5, tilesetZoom);
    ctx.beginPath();
    let startX = x;
    let startY = y;
    while (startX < 0) startX += stepX;
    while (startY < 0) startY += stepY;
    for (let gx = startX; gx <= naturalW; gx += stepX) {
      const px = offsetX + gx * scale;
      ctx.moveTo(Math.round(px) + 0.5, offsetY);
      ctx.lineTo(Math.round(px) + 0.5, offsetY + drawH);
    }
    for (let gy = startY; gy <= naturalH; gy += stepY) {
      const py = offsetY + gy * scale;
      ctx.moveTo(offsetX, Math.round(py) + 0.5);
      ctx.lineTo(offsetX + drawW, Math.round(py) + 0.5);
    }
    ctx.stroke();

    lastTilesetState = {
      bounds,
      scale,
      stepX,
      stepY,
      tileW: w,
      tileH: h,
      padX,
      padY,
      naturalW,
      naturalH,
    };
    if (tilesetSelectionCanvas) {
      tilesetSelectionCanvas.width = Math.round(bounds.baseW * dpr);
      tilesetSelectionCanvas.height = Math.round(bounds.baseH * dpr);
      tilesetSelectionCanvas.style.width = `${Math.round(bounds.baseW)}px`;
      tilesetSelectionCanvas.style.height = `${Math.round(bounds.baseH)}px`;
    }
    drawTilesetSelection();

  };

  if (tilesetPreviewImage) {
    tilesetPreviewImage.addEventListener("load", updateTilesetGrid);
    tilesetPreviewImage.draggable = false;
    tilesetPreviewImage.addEventListener("dragstart", (e) => e.preventDefault());
  }
  if (tilesetGridX && tilesetGridY && tilesetGridW && tilesetGridH && tilesetGridPadX && tilesetGridPadY) {
    [tilesetGridX, tilesetGridY, tilesetGridW, tilesetGridH, tilesetGridPadX, tilesetGridPadY].forEach((inputEl) => {
      inputEl.addEventListener("input", updateTilesetGrid);
    });
  }
  if (tilesetRemoveColor) {
    tilesetRemoveColor.addEventListener("blur", () => {
      tilesetRemoveColor.value = normalizeHex(tilesetRemoveColor.value);
    });
    if (tilesetEyeDropper) {
      tilesetEyeDropper.addEventListener("click", async () => {
        if (!("EyeDropper" in window)) {
          pushSystemChat("Eyedropper not supported in this browser.");
          return;
        }
        try {
          const eyeDropper = new EyeDropper();
          const result = await eyeDropper.open();
          if (result && result.sRGBHex) tilesetRemoveColor.value = result.sRGBHex;
        } catch (err) {
          // ignore cancel
        }
      });
    }
  }
  if (tilesetRemoveApply && tilesetRemoveColor && tilesetPreviewImage) {
    tilesetRemoveApply.addEventListener("click", () => {
      const hex = normalizeHex(tilesetRemoveColor.value);
      tilesetRemoveColor.value = hex;
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      const tolRaw = tilesetRemoveTolerance ? parseInt(tilesetRemoveTolerance.value, 10) : 0;
      const tol = Number.isFinite(tolRaw) ? Math.max(0, Math.min(255, tolRaw)) : 0;
      const w = tilesetPreviewImage.naturalWidth;
      const h = tilesetPreviewImage.naturalHeight;
      if (!w || !h) {
        pushSystemChat("Tileset not loaded yet.");
        return;
      }
      const offscreen = document.createElement("canvas");
      offscreen.width = w;
      offscreen.height = h;
      const octx = offscreen.getContext("2d");
      if (!octx) return;
      octx.drawImage(tilesetPreviewImage, 0, 0);
      const imgData = octx.getImageData(0, 0, w, h);
      const data = imgData.data;
      const tolSq = tol * tol;
      for (let i = 0; i < data.length; i += 4) {
        const dr = data[i] - r;
        const dg = data[i + 1] - g;
        const db = data[i + 2] - b;
        if (dr * dr + dg * dg + db * db <= tolSq) {
          data[i + 3] = 0;
        }
      }
      octx.putImageData(imgData, 0, 0);
      tilesetPreviewImage.src = offscreen.toDataURL("image/png");
    });
  }
  if (tilesetCutSprites && tilesetPreviewImage && customPaletteGrid) {
    tilesetCutSprites.addEventListener("click", () => {
      const w = tilesetPreviewImage.naturalWidth;
      const h = tilesetPreviewImage.naturalHeight;
      if (!w || !h) {
        pushSystemChat("Tileset not loaded yet.");
        return;
      }
      const gridX = readGridValue(tilesetGridX, 0);
      const gridY = readGridValue(tilesetGridY, 0);
      const tileW = Math.max(1, readGridValue(tilesetGridW, 16));
      const tileH = Math.max(1, readGridValue(tilesetGridH, 16));
      const padX = Math.max(0, readGridValue(tilesetGridPadX, 0));
      const padY = Math.max(0, readGridValue(tilesetGridPadY, 0));
      const stepX = tileW + padX;
      const stepY = tileH + padY;
      const tilesAcross = Math.max(1, Math.floor(Math.max(0, w - gridX - tileW) / stepX) + 1);
      const tilesDown = Math.max(1, Math.floor(Math.max(0, h - gridY - tileH) / stepY) + 1);
      customPaletteSheetCols = tilesAcross;
      customPaletteSheetRows = tilesDown;
      const offscreen = document.createElement("canvas");
      offscreen.width = w;
      offscreen.height = h;
      const octx = offscreen.getContext("2d");
      if (!octx) return;
      octx.drawImage(tilesetPreviewImage, 0, 0);
      if (customPaletteSheet || customPaletteSheetImage) {
        const availableW = (customPaletteSection && customPaletteSection.clientWidth) ? (customPaletteSection.clientWidth - 12) : 260;
        const maxPreviewW = Math.max(64, availableW);
        const maxPreviewH = 220;
        const sheetScale = Math.min(1, maxPreviewW / w, maxPreviewH / h);
        const previewCanvas = document.createElement("canvas");
        previewCanvas.width = Math.max(1, Math.round(w * sheetScale));
        previewCanvas.height = Math.max(1, Math.round(h * sheetScale));
        const pctx = previewCanvas.getContext("2d");
        if (pctx) {
          pctx.imageSmoothingEnabled = false;
          pctx.drawImage(offscreen, 0, 0, w, h, 0, 0, previewCanvas.width, previewCanvas.height);
          updateCustomSheetPreview(previewCanvas.toDataURL("image/png"), sheetScale);
        } else {
          updateCustomSheetPreview(null);
        }
      }
      const tilesToSort = [];
      customPaletteGrid.innerHTML = "";
      customPaletteGrid.style.gridTemplateColumns = "";
      customPaletteGrid.style.width = "";
      customTileSprites.clear();
      customTileDataUrls.clear();
      customTileMap.clear();
      let poolIndex = 0;
      const findGroupName = (xPos, yPos) => {
        for (const group of tilesetGroups) {
          if (xPos >= group.x && yPos >= group.y && xPos + tileW <= group.x + group.w && yPos + tileH <= group.y + group.h) {
            return group.name;
          }
        }
        return null;
      };
      for (let y = gridY; y + tileH <= h; y += stepY) {
        for (let x = gridX; x + tileW <= w; x += stepX) {
          const imgData = octx.getImageData(x, y, tileW, tileH);
          const data = imgData.data;
          let hasPixel = false;
          for (let i = 3; i < data.length; i += 4) {
            if (data[i] !== 0) {
              hasPixel = true;
              break;
            }
          }
          if (!hasPixel) continue;
          const tileId = customIdForIndex(poolIndex++);
          const tileCanvas = document.createElement("canvas");
          tileCanvas.width = tileW;
          tileCanvas.height = tileH;
          const tctx = tileCanvas.getContext("2d");
          if (!tctx) continue;
          tctx.putImageData(imgData, 0, 0);
          const url = tileCanvas.toDataURL("image/png");
          let rSum = 0, gSum = 0, bSum = 0, count = 0;
          for (let i = 0; i < data.length; i += 4) {
            if (data[i + 3] === 0) continue;
            rSum += data[i];
            gSum += data[i + 1];
            bSum += data[i + 2];
            count += 1;
          }
          const avgR = count ? rSum / count : 0;
          const avgG = count ? gSum / count : 0;
          const avgB = count ? bSum / count : 0;
          const toHsl = (r, g, b) => {
            const rn = r / 255;
            const gn = g / 255;
            const bn = b / 255;
            const max = Math.max(rn, gn, bn);
            const min = Math.min(rn, gn, bn);
            const delta = max - min;
            let h = 0;
            if (delta !== 0) {
              if (max === rn) h = ((gn - bn) / delta) % 6;
              else if (max === gn) h = (bn - rn) / delta + 2;
              else h = (rn - gn) / delta + 4;
              h = Math.round(h * 60);
              if (h < 0) h += 360;
            }
            const l = (max + min) / 2;
            const s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
            return { h, s, l };
          };
          tilesToSort.push({ tileId, url, hsl: toHsl(avgR, avgG, avgB), group: findGroupName(x, y) });
        }
      }
      const sections = new Map();
      const sectionOrder = [];
      const ensureSection = (name) => {
        if (!sections.has(name)) {
          sections.set(name, []);
          sectionOrder.push(name);
        }
        return sections.get(name);
      };
      const paletteName = (tilesetPaletteName && tilesetPaletteName.value.trim()) || "Custom";
      tilesToSort.forEach((tile) => {
        const sectionName = tile.group || paletteName;
        ensureSection(sectionName).push(tile);
      });
      let totalTiles = 0;
      const createTileElement = (tile) => {
        const img = new Image();
        img.src = tile.url;
        customTileSprites.set(tile.tileId, img);
        customTileDataUrls.set(tile.tileId, tile.url);
        const tileEl = document.createElement("div");
        tileEl.className = "editor-tile";
        tileEl.setAttribute("data-tile", tile.tileId);
        const preview = document.createElement("canvas");
        preview.className = "tile-preview";
        preview.width = 8;
        preview.height = 8;
        preview.setAttribute("data-tile", tile.tileId);
        tileEl.appendChild(preview);
        return tileEl;
      };
      for (const sectionName of sectionOrder) {
        const tiles = sections.get(sectionName);
        if (!tiles || tiles.length === 0) continue;
        const groupWrapper = document.createElement("div");
        groupWrapper.className = "custom-palette-group";
        const groupHeader = document.createElement("div");
        groupHeader.className = "custom-palette-group-header";
        groupHeader.textContent = sectionName;
        const groupGrid = document.createElement("div");
        groupGrid.className = "editor-grid";
        tiles.forEach((tile) => {
          const tileEl = createTileElement(tile);
          groupGrid.appendChild(tileEl);
        });
        applyCustomPaletteLayout(groupGrid);
        groupWrapper.append(groupHeader, groupGrid);
        customPaletteGrid.appendChild(groupWrapper);
        wirePaletteGrid(groupGrid);
        totalTiles += tiles.length;
      }
      if (customPaletteTitle) customPaletteTitle.textContent = paletteName.toUpperCase();
      document.body.classList.add("has-custom-tiles");
      renderPalettePreviews();
      pushSystemChat(`Cut ${totalTiles} tiles into ${paletteName}.`);
    });
  }
  if (tilesetToolsClose) {
    tilesetToolsClose.addEventListener("click", () => {
      setTilesetPreview(null);
    });
  }
  if (tilesetPreviewStage) {
    tilesetPreviewStage.addEventListener("wheel", (e) => {
      if (!document.body.classList.contains("tileset-open")) return;
      e.preventDefault();
      const direction = e.deltaY > 0 ? -0.1 : 0.1;
      const rect = tilesetPreviewStage.getBoundingClientRect();
      const anchorX = rect.width ? (e.clientX - rect.left) / rect.width : 0.5;
      const anchorY = rect.height ? (e.clientY - rect.top) / rect.height : 0.5;
      setTilesetZoom(tilesetZoom + direction, anchorX, anchorY);
    }, { passive: false });

    tilesetPreviewStage.addEventListener("mousedown", (e) => {
      if (!document.body.classList.contains("tileset-open")) return;
      if (e.button === 0) {
        const cell = getTilesetNaturalPoint(e);
        if (!cell) return;
        tilesetSelectionStart = cell;
        tilesetSelectionEnd = cell;
        tilesetSelecting = true;
        updateSelectionCells(cell, cell);
        return;
      }
      if (e.button !== 1) return;
      e.preventDefault();
      tilesetPanning = true;
      tilesetPanStartX = e.clientX - tilesetPanX;
      tilesetPanStartY = e.clientY - tilesetPanY;
      tilesetPreviewStage.classList.add("panning");
    });
    tilesetPreviewStage.addEventListener("mousemove", (e) => {
      if (tilesetSelecting) {
        const cell = getTilesetNaturalPoint(e);
        if (!cell) return;
        tilesetSelectionEnd = cell;
        updateSelectionCells(tilesetSelectionStart, cell);
      }
      if (!tilesetPanning) return;
      tilesetPanX = e.clientX - tilesetPanStartX;
      tilesetPanY = e.clientY - tilesetPanStartY;
      setTilesetZoom(tilesetZoom);
      updateTilesetGrid();
    });
    const stopTilesetPan = () => {
      if (tilesetPanning) {
        tilesetPanning = false;
        tilesetPreviewStage.classList.remove("panning");
      }
    };
    tilesetPreviewStage.addEventListener("mouseup", (e) => {
      stopTilesetPan();
      if (e.button === 0) {
        tilesetSelecting = false;
        if (tilesetSelectionModeActive && tilesetSelection) {
          const { x, y, w, h } = tilesetSelection;
          createGroup(x, y, w, h);
        }
      }
    });
    tilesetPreviewStage.addEventListener("mouseleave", () => {
      stopTilesetPan();
      tilesetSelecting = false;
    });
    document.addEventListener("mouseup", () => {
      tilesetSelecting = false;
    });

  }
  window.addEventListener("resize", updateTilesetGrid);

  refreshAuthorStatus();
  renderTilesetGroups();

  const TILE = 16;
  // Pixel-art vibe: render at low-res then scale up
  const BASE_W = 304; // 19 tiles wide
  const BASE_H = 272; // 17 tiles tall (14 play + 3 HUD)
  const HUD_TILES = 3;
  const HUD_PX = HUD_TILES * TILE;
  const PLAYFIELD_TILES = BASE_H / TILE - HUD_TILES; // 14 rows of play area
  const PLAYFIELD_H = PLAYFIELD_TILES * TILE;
  const CAMERA_SEGMENT_PX = PLAYFIELD_H; // snap camera in full-screen chunks
  const MIN_LEVEL_ROWS = PLAYFIELD_TILES * 2 + HUD_TILES; // enough height for two screens + HUD
  const UNDERGROUND_SEGMENTS = 1;
  const UNDERGROUND_ROWS = UNDERGROUND_SEGMENTS * PLAYFIELD_TILES;
  const UNDERGROUND_BG = "#0b0c17";
  const UNDERGROUND_ACCENT = "#11182e";
  let undergroundStartPx = Infinity;
  let undergroundStartTy = Infinity;
  const DUNGEON_CHUNK_W = 48;
  const DUNGEON_CHUNK_H = 32;
  const DUNGEON_MIN_ROOM = 8;
  const DUNGEON_MAX_DEPTH = 4;
  const dungeonChunks = new Map(); // key: "cx,cy" -> true
  let SCALE = 3; // integer-only scaling for crisp pixels
  let showGrid = true;
  let showTerrainDebug = false;
  let editorOpen = false;
  let editorTile = "#";
  let selectedCell = null; // {tx, ty}
  let hoverCell = null; // {tx, ty}
  let editorClipboard = null;
  let clickDebug = null; // {sx, sy, tx, ty, timer}
  let stampMode = false;
  const undoStack = [];
  const redoStack = [];
  const TEXT_FONT = {
    A: ["0110","1001","1111","1001","1001"],
    B: ["1110","1001","1110","1001","1110"],
    C: ["0111","1000","1000","1000","0111"],
    D: ["1110","1001","1001","1001","1110"],
    E: ["1111","1000","1110","1000","1111"],
    F: ["1111","1000","1110","1000","1000"],
    G: ["0111","1000","1011","1001","0111"],
    H: ["1001","1001","1111","1001","1001"],
    I: ["111","010","010","010","111"],
    J: ["0111","0010","0010","1010","0100"],
    K: ["1001","1010","1100","1010","1001"],
    L: ["1000","1000","1000","1000","1111"],
    M: ["10001","11011","10101","10001","10001"],
    N: ["1001","1101","1011","1001","1001"],
    O: ["0110","1001","1001","1001","0110"],
    P: ["1110","1001","1110","1000","1000"],
    Q: ["0110","1001","1001","1011","0111"],
    R: ["1110","1001","1110","1010","1001"],
    S: ["0111","1000","0110","0001","1110"],
    T: ["111","010","010","010","010"],
    U: ["1001","1001","1001","1001","0110"],
    V: ["1001","1001","1001","0101","0010"],
    W: ["10001","10001","10101","11011","10001"],
    X: ["1001","0110","0100","0110","1001"],
    Y: ["1001","0101","0010","0010","0010"],
    Z: ["1111","0010","0100","1000","1111"],
    "0": ["0110","1001","1001","1001","0110"],
    "1": ["010","110","010","010","111"],
    "2": ["1110","0001","0110","1000","1111"],
    "3": ["1110","0001","0110","0001","1110"],
    "4": ["1001","1001","1111","0001","0001"],
    "5": ["1111","1000","1110","0001","1110"],
    "6": ["0111","1000","1110","1001","0110"],
    "7": ["1111","0001","0010","0100","0100"],
    "8": ["0110","1001","0110","1001","0110"],
    "9": ["0110","1001","0111","0001","1110"],
    " ": ["0","0","0","0","0"],
    ".": ["0","0","0","0","1"],
    "!": ["1","1","1","0","1"],
    "?": ["111","001","011","000","010"],
    "-": ["0","0","111","0","0"],
  };
  const TERRAIN_TILES = new Set(["#", "S", "I"]);
  const TERRAIN_STYLE = {
    "#": { base: "#3b2f2f", mid: "#433434", light: "#4a3a3a", shadow: "#2a2020", wall: "#2f2525", accent: "#5a4545" },
    "S": { base: "#d8c28f", mid: "#ceb47a", light: "#f7e7b8", shadow: "#b89f6b", wall: "#b39c68", accent: "#f0e0a8" },
    "I": { base: "#b0e0ff", mid: "#a0d6f5", light: "#d8f4ff", shadow: "#8bbbd6", wall: "#8cb9d3", accent: "#e3f2ff" },
  };
  const TERRAIN_DEBUG_COLORS = {
    "top-single": "#fbbf24",
    "top-left": "#9ff5b2",
    "top-right": "#9ff5b2",
    "top-mid": "#c7d2fe",
    "gap-left": "#f472b6",
    "gap-right": "#f472b6",
    pillar: "#c084fc",
    ledge: "#cbd5e1",
  };
  function isTerrainTile(t) {
    return TERRAIN_TILES.has(t);
  }
  function terrainPalette(t) {
    return TERRAIN_STYLE[t] || TERRAIN_STYLE["#"];
  }
  const TERRAIN_ROLE_CHOICES = [
    { key: "top-left", label: "Top Left Corner (TL)" },
    { key: "top-mid", label: "Top Edge (TM)" },
    { key: "top-right", label: "Top Right Corner (TR)" },
    { key: "top-single", label: "Top Single (TS)" },
    { key: "gap-left", label: "Gap Wall Left (GL)" },
    { key: "gap-right", label: "Gap Wall Right (GR)" },
    { key: "pillar", label: "Gap Pillar (GP)" },
    { key: "ledge", label: "Bottom Ledge (BT)" },
  ];
  let roleMenuEl = null;
  function drawDebugLabel(ctx, text, cx, cy, color = "#f2f5ff") {
    ctx.save();
    ctx.font = "7px 'Press Start 2P', 'VT323', monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillText(text, cx + 1, cy);
    ctx.fillText(text, cx - 1, cy);
    ctx.fillText(text, cx, cy + 1);
    ctx.fillStyle = color;
    ctx.fillText(text, cx, cy);
    ctx.restore();
  }
  function drawSmartTerrainFace(ctx, t, x, y, size, meta, debug = false) {
    const info = meta || {
      exposedTop: true,
      exposedBottom: true,
      exposedLeft: false,
      exposedRight: false,
      variant: "top-mid",
      label: null,
    };
    const palette = terrainPalette(t);
    const topBand = Math.max(2, Math.round(size * 0.22));
    const sideBand = Math.max(2, Math.round(size * 0.16));
    const shadowBand = Math.max(2, Math.round(size * 0.25));

    ctx.fillStyle = palette.base;
    ctx.fillRect(x, y, size, size);

    ctx.fillStyle = palette.shadow;
    ctx.fillRect(x, y + size - shadowBand, size, shadowBand);

    ctx.fillStyle = info.exposedTop ? palette.light : palette.mid;
    ctx.fillRect(x, y, size, info.exposedTop ? topBand : Math.max(1, topBand - 1));

    if (info.exposedLeft) {
      ctx.fillStyle = palette.wall;
      ctx.fillRect(x, y, sideBand, size);
    }
    if (info.exposedRight) {
      ctx.fillStyle = palette.wall;
      ctx.fillRect(x + size - sideBand, y, sideBand, size);
    }

    const accent = palette.accent || palette.light;
    if (info.variant === "top-left") {
      ctx.fillStyle = accent;
      ctx.fillRect(x, y, sideBand + 1, topBand);
    } else if (info.variant === "top-right") {
      ctx.fillStyle = accent;
      ctx.fillRect(x + size - sideBand - 1, y, sideBand + 1, topBand);
    } else if (info.variant === "top-mid") {
      ctx.fillStyle = accent;
      ctx.fillRect(x + sideBand - 1, y, size - (sideBand - 1) * 2, Math.max(1, topBand - 1));
    } else if (info.variant === "top-single") {
      ctx.fillStyle = accent;
      ctx.fillRect(x, y, size, topBand);
      ctx.fillRect(x, y, sideBand, size);
      ctx.fillRect(x + size - sideBand, y, sideBand, size);
    } else if (info.variant === "gap-left" || info.variant === "gap-right") {
      ctx.fillStyle = accent;
      const offsetX = info.variant === "gap-left" ? 0 : size - sideBand;
      ctx.fillRect(x + offsetX, y + topBand, sideBand, size - topBand);
    } else if (info.variant === "pillar") {
      ctx.fillStyle = accent;
      ctx.fillRect(x, y + topBand, sideBand, size - topBand);
      ctx.fillRect(x + size - sideBand, y + topBand, sideBand, size - topBand);
    } else if (info.variant === "ledge") {
      ctx.fillStyle = accent;
      ctx.fillRect(x, y + size - shadowBand - 1, size, Math.max(2, shadowBand - 1));
    }

    if (debug && info.label) {
      const color = TERRAIN_DEBUG_COLORS[info.variant] || "#f2f5ff";
      drawDebugLabel(ctx, info.label, x + size / 2, y + size / 2, color);
    }
  }
  const off = document.createElement("canvas");
  off.width = BASE_W;
  off.height = BASE_H;
  const g = off.getContext("2d", { alpha: false });

  let lastFrameW = null;
  let lastFrameH = null;
  const applyLayoutVars = (frameW, frameH, canvasW, canvasH) => {
    const cw = canvasW ?? (canvas.clientWidth || canvas.width);
    const ch = canvasH ?? (canvas.clientHeight || canvas.height);
    const fw = frameW ?? lastFrameW ?? cw;
    const fh = frameH ?? lastFrameH ?? ch;
    const barWidth = Math.max(0, Math.round((fw - cw) / 2));
    const editorWidth = editorOpen ? Math.min(360, barWidth) : 0;
    const editorScale = Math.min(1, Math.max(0.6, fh / 720));
    document.documentElement.style.setProperty("--frame-width", `${fw}px`);
    document.documentElement.style.setProperty("--frame-height", `${fh}px`);
    document.documentElement.style.setProperty("--canvas-width", `${cw}px`);
    document.documentElement.style.setProperty("--canvas-height", `${ch}px`);
    document.documentElement.style.setProperty("--editor-width", `${editorWidth}px`);
    document.documentElement.style.setProperty("--editor-scale", `${editorScale}`);
    if (frameW) lastFrameW = frameW;
    if (frameH) lastFrameH = frameH;
  };

  const getViewportSize = () => {
    const vv = window.visualViewport;
    const vw = vv ? vv.width : window.innerWidth;
    const vh = vv ? vv.height : window.innerHeight;
    return { vw, vh };
  };

  const applyScale = () => {
    // Scale smoothly to fit viewport while preserving aspect ratio (no integer step jumps)
    const { vw, vh } = getViewportSize();
    const frameBaseW = BASE_H * (16 / 9);
    const frameBaseH = BASE_H;
    const scale = Math.min(vw / frameBaseW, vh / frameBaseH);
    SCALE = scale;
    canvas.width = BASE_W;
    canvas.height = BASE_H;
    const displayW = BASE_W * scale;
    const displayH = BASE_H * scale;
    const frameW = frameBaseW * scale;
    const frameH = frameBaseH * scale;
    canvas.style.width = `${displayW}px`;
    canvas.style.height = `${displayH}px`;
    applyLayoutVars(frameW, frameH, displayW, displayH);
  };

  applyScale();
  window.addEventListener("resize", applyScale);
  if (window.visualViewport) {
    window.visualViewport.addEventListener("resize", applyScale);
    window.visualViewport.addEventListener("scroll", applyScale);
  }
  ctx.imageSmoothingEnabled = false;
  g.imageSmoothingEnabled = false;

  let prevGridOn = showGrid;
  function setEditorOpen(next) {
    if (next && !editorOpen) {
      prevGridOn = showGrid;
      showGrid = true; // ensure grid visible in editor
    }
    if (!next && editorOpen) {
      showGrid = prevGridOn; // restore prior state
    }
    editorOpen = next;
    document.body.classList.toggle("editor-open", editorOpen);
    applyLayoutVars();
  }

  function selectEditorTile(tile, el) {
    editorTile = tile;
    document.querySelectorAll(".editor-tile.selected").forEach(n => n.classList.remove("selected"));
    if (el) el.classList.add("selected");
  }

  const params = new URLSearchParams(location.search);
  const mpParam = params.get("mp");
  const MP_ENABLED = mpParam !== "0";
  // Default to shared lobby relay; override via ?mpUrl=ws://localhost:3001 for local dev
  const MP_SERVER = params.get("mpUrl") || "wss://ws.playfree.dev";
  const MP_ROOM = params.get("room") || "lobby";
  const ENDLESS_ENABLED = true; // force endless for all users
  const ENDLESS_DEBUG = params.get("endlessDebug") === "1" || params.get("edebug") === "1";
  let showJumpGuide = params.get("jumpGuide") !== "0";
  const CHAT_BUBBLE_TIME = 4;
  let PLAYER_NAME = (params.get("name") || `P${Math.floor(Math.random() * 900 + 100)}`).slice(0, 20);
  const STATE_SEND_INTERVAL = 0.05; // seconds
  const PEER_STALE_TIME = 6; // seconds
  const GRAVITY = 1400;      // px/s^2
  const MAX_FALL = 900;
  const WALK_ACCEL_CURVE = { high: 1700, low: 900 }; // higher out of standstill, softer near cap
  const RUN_ACCEL_CURVE = { high: 2200, low: 1200 };
  const FRICTION_DECEL = 1700;
  const BRAKE_DECEL = 2800;
  const AIR_ACCEL_SCALE = 0.55;
  const AIR_FRICTION_DECEL = 400;
  const AIR_BRAKE_DECEL = 750;
  const SKID_SPEED_THRESHOLD = 140;
  const SKID_TIME = 0.25;
  const SKID_ACCEL_SCALE = 0.25;
  const SKID_FRICTION_DECEL = 600;
  const SKID_BRAKE_DECEL = 1400;
  const SKID_DUST_INTERVAL = 0.06;
  const SKID_BOOST_AMOUNT = 0.1; // 10% max speed bump
  const SKID_BOOST_DECAY = 1.8;  // per second decay back to 0
  const WALK_MAX = 120;
  const RUN_MAX = 185;
  const P_SPEED_MAX = 240;
  const P_SPEED_CHARGE_TIME = 1.2; // seconds of run-hold to reach full P-speed
  const P_SPEED_ENTRY_SPEED = RUN_MAX - 8; // must be near run cap before charge progresses
  const P_SPEED_DECAY_RATE = 1.5; // how quickly P-speed charge drains when not qualifying
  const P_METER_SEGMENTS = 6;
  const P_METER_DECAY_DELAY = 0.12; // brief hold before the HUD meter drops a tier
  const JUMP_V = 420;
  const COYOTE_TIME = 0.08;  // seconds
  const JUMP_BUFFER = 0.1;   // seconds
  const P_PIVOT_GRACE = 0.12; // seconds of pivot that still counts for P-speed gain
  const HUD_TIMER_START = 300; // seconds
  const DAMAGE_INVULN_TIME = 1.0;
  const FIREBALL_COOLDOWN = 0.35; // seconds between shots
  const FIREBALL_SPEED = 320;
  const FIREBALL_GRAVITY = 900;
  const FIREBALL_BOUNCE_V = 340;
  const FIREBALL_LIFETIME = 3.5;
  const FIREBALL_MAGNUS = 0.32; // side/upward curve strength
  const GLIDE_GRAVITY_SCALE = 0.35;
  const TAIL_SWING_TIME = 0.2;
  const TAIL_COOLDOWN = 0.6;
  const TAIL_RANGE_X = 18;
  const TAIL_RANGE_Y = 12;
  const FLIGHT_TIME = 2.6;
  const FLIGHT_LIFT = 180;
  const STATUE_DURATION = 2.5;
  const STATUE_COOLDOWN = 4.5;
  const STATUE_INVULN_TOPUP = 0.12;
  const WATER_GRAVITY_SCALE = 0.28;
  const WATER_MAX_FALL = 220;
  const WATER_SWIM_IMPULSE = 320;
  const LADDER_CLIMB_SPEED = 140;
  const FROG_LAND_ACCEL_SCALE = 0.7;
  const FROG_LAND_DECEL_SCALE = 0.65;
  const HAMMER_COOLDOWN = 0.3;
  const HAMMER_GRAVITY = 1200;
  const HAMMER_LIFETIME = 0.9;
  const HAMMER_CHARGE_TIME = 0.8; // seconds to reach max distance
  const HAMMER_MIN_SPEED = 200;
  const HAMMER_MAX_SPEED = 470; // tuned for ~7 tiles of range at max charge
  const HAMMER_MIN_ANGLE = (20 * Math.PI) / 180;
  const HAMMER_MAX_ANGLE = (70 * Math.PI) / 180; // ~5 tiles of arc height at max charge
  const HAMMER_MAGNUS = 0.24;
  const DIG_COOLDOWN = 0.1;
  const JETPACK_THRUST = 260;
  const JETPACK_GRAVITY_SCALE = 0.4;
  const JETPACK_MAX_FALL = 520;
  const JETPACK_FUEL_TIME = 999;
  const PowerUpForm = Object.freeze({
    Small: "small",
    Super: "super",
    Fire: "fire",
    Raccoon: "raccoon",
    Tanooki: "tanooki",
    Frog: "frog",
    Hammer: "hammer",
    Jetpack: "jetpack",
  });
  const BIG_FORMS = new Set([
    PowerUpForm.Super,
    PowerUpForm.Fire,
    PowerUpForm.Raccoon,
    PowerUpForm.Tanooki,
    PowerUpForm.Frog,
    PowerUpForm.Hammer,
    PowerUpForm.Jetpack,
  ]);
  const PLAYER_SAVE_KEY = "smb3-player-state";
  const SURFACE_MODS = {
    ice: { accel: 0.9, friction: 0.35, brake: 0.6 },
    sand: { accel: 0.65, friction: 1.35, brake: 1.15 },
  };

  // -----------------------------
  // Inventory UI (overlay)
  // -----------------------------
  const inventoryOverlay = document.getElementById("inventory-overlay");
  const inventoryGrid = document.getElementById("inventory-grid");
  const inventorySelected = document.getElementById("inventory-selected");
  const inventoryFooterHint = document.getElementById("inventory-footer-hint");
  const inventoryFeedback = document.createElement("div");
  inventoryFeedback.className = "inventory-hint";
  inventoryFeedback.id = "inventory-feedback";

  const INVENTORY_COLS = 7;
  const INVENTORY_ROWS = 4;
  const INVENTORY_SLOTS = INVENTORY_COLS * INVENTORY_ROWS;

  // Demo data; replace with real inventory view model wiring.
  const inventorySlots = Array(INVENTORY_SLOTS).fill(null);
  inventorySlots[0] = { name: "Fire Flower", icon: "🔥", count: 1, type: "fire-flower" };
  inventorySlots[1] = { name: "Super Leaf", icon: "🍂", count: 1, type: "super-leaf" };
  inventorySlots[2] = { name: "Hammer Suit", icon: "🔨", count: 1, type: "hammer-suit" };
  inventorySlots[3] = { name: "Frog Suit", icon: "🐸", count: 1, type: "frog-suit" };
  inventorySlots[4] = { name: "Jetpack Suit", icon: "🚀", count: 1, type: "jetpack-suit" };

  let inventoryOpen = false;
  let inventoryCursor = 0;
  const slotEls = [];

  function buildInventoryGrid() {
    inventoryGrid.innerHTML = "";
    slotEls.length = 0;
    for (let i = 0; i < INVENTORY_SLOTS; i++) {
      const el = document.createElement("div");
      el.className = "inventory-slot empty";
      const icon = document.createElement("div");
      icon.className = "inventory-icon";
      const count = document.createElement("div");
      count.className = "inventory-count";
      el.appendChild(icon);
      el.appendChild(count);
    inventoryGrid.appendChild(el);
    slotEls.push({ el, icon, count });
  }
  inventoryGrid.insertAdjacentElement("afterend", inventoryFeedback);
  }

  function renderInventory() {
    inventoryOverlay.classList.toggle("open", inventoryOpen);
    inventorySelected.textContent = "--";
    inventoryFooterHint.textContent = "Use";
    inventoryFeedback.textContent = "";
    for (let i = 0; i < INVENTORY_SLOTS; i++) {
      const slot = inventorySlots[i];
      const { el, icon, count } = slotEls[i];
      const isSelected = i === inventoryCursor;
      if (slot) {
        el.className = "inventory-slot" + (isSelected ? " selected" : "");
        icon.textContent = slot.icon || "●";
        count.textContent = slot.count > 1 ? `x${slot.count}` : "";
        if (isSelected) {
          inventorySelected.textContent = slot.name;
          inventoryFooterHint.textContent = "Use";
        }
      } else {
        el.className = "inventory-slot empty" + (isSelected ? " selected" : "");
        icon.textContent = "";
        count.textContent = "";
        if (isSelected) {
          inventorySelected.textContent = "(empty)";
          inventoryFooterHint.textContent = "Close";
        }
      }
    }
  }

  function moveInventoryCursor(dx, dy) {
    const col = inventoryCursor % INVENTORY_COLS;
    const row = Math.floor(inventoryCursor / INVENTORY_COLS);
    const nextCol = (col + dx + INVENTORY_COLS) % INVENTORY_COLS;
    const nextRow = (row + dy + INVENTORY_ROWS) % INVENTORY_ROWS;
    inventoryCursor = nextRow * INVENTORY_COLS + nextCol;
    renderInventory();
  }

  function toggleInventory(forceOpen) {
    const next = typeof forceOpen === "boolean" ? forceOpen : !inventoryOpen;
    inventoryOpen = next;
    renderInventory();
  }

  const inventoryUseHandlers = {
    "fire-flower": () => setPlayerForm(PowerUpForm.Fire),
    "super-leaf": () => setPlayerForm(PowerUpForm.Raccoon),
    "hammer-suit": () => setPlayerForm(PowerUpForm.Hammer),
    "frog-suit": () => setPlayerForm(PowerUpForm.Frog),
    "jetpack-suit": () => setPlayerForm(PowerUpForm.Jetpack),
    mushroom: () => setPlayerForm(PowerUpForm.Super),
  };

  function useSelectedInventoryItem() {
    const slot = inventorySlots[inventoryCursor];
    if (!slot) {
      inventoryFeedback.textContent = "Empty slot";
      toggleInventory(false);
      return;
    }
    const handler = slot.type ? inventoryUseHandlers[slot.type] : null;
    if (handler) {
      handler();
      inventoryFeedback.textContent = `${slot.name} equipped`;
      if (slot.count && slot.count > 1) {
        slot.count -= 1;
      } else {
        inventorySlots[inventoryCursor] = null;
      }
      toggleInventory(false);
    } else {
      inventoryFeedback.textContent = `Cannot use ${slot.name}`;
      console.log("Cannot use item:", slot.name);
    }
  }

  function handleInventoryKey(e) {
    if (e.code === "KeyI") {
      toggleInventory();
      e.preventDefault();
      return true;
    }
    if (!inventoryOpen) return false;
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", "Space", "Escape"].includes(e.code)) {
      e.preventDefault();
      if (e.code === "ArrowUp") moveInventoryCursor(0, -1);
      else if (e.code === "ArrowDown") moveInventoryCursor(0, 1);
      else if (e.code === "ArrowLeft") moveInventoryCursor(-1, 0);
      else if (e.code === "ArrowRight") moveInventoryCursor(1, 0);
      else if (e.code === "Enter" || e.code === "Space") useSelectedInventoryItem();
      else if (e.code === "Escape") toggleInventory(false);
      return true;
    }
    return false;
  }

  buildInventoryGrid();
  renderInventory();

  // Precompute jump guide numbers (tiles traveled during a full jump)
  const jumpFlightTime = (2 * JUMP_V) / GRAVITY;
  const jumpWalkTiles = (WALK_MAX * jumpFlightTime) / TILE;
  const jumpRunTiles = (RUN_MAX * jumpFlightTime) / TILE;
  const jumpPSpeedTiles = (P_SPEED_MAX * jumpFlightTime) / TILE;

  // -----------------------------
  // Input
  // -----------------------------
  const keys = new Set();
  const pressed = new Set();
  const chatInput = document.createElement("input");
  chatInput.type = "text";
  chatInput.maxLength = 200;
  chatInput.placeholder = "Enter chat (/name newname)";
  chatInput.style.position = "relative";
  chatInput.style.left = "0";
  chatInput.style.bottom = "0";
  chatInput.style.width = "100%";
  chatInput.style.padding = "8px 10px";
  chatInput.style.border = "2px solid #000";
  chatInput.style.background = "#0f182a";
  chatInput.style.color = "#dfe7ff";
  chatInput.style.font = "12px 'Press Start 2P', 'VT323', monospace";
  chatInput.style.boxShadow = "inset 0 0 0 2px rgba(255,255,255,0.08)";
  chatInput.style.boxSizing = "border-box";
  chatInput.style.borderRadius = "8px";
  chatInput.style.zIndex = "500";
  chatInput.style.display = "none";
  document.body.appendChild(chatInput);
  let authorPromptActive = false;
  const chatPlaceholderDefault = chatInput.placeholder;

  function toggleChatInput(show) {
    chatInput.style.display = show ? "block" : "none";
    if (show) {
      chatInput.value = "";
      chatInput.focus();
    } else {
      chatInput.blur();
    }
  }
  function beginAuthorPrompt() {
    authorPromptActive = true;
    chatInput.type = "password";
    chatInput.placeholder = "Author passphrase";
    chatInput.value = "";
    toggleChatInput(true);
    pushSystemChat("Enter author passphrase.");
  }
  function endAuthorPrompt() {
    authorPromptActive = false;
    chatInput.type = "text";
    chatInput.placeholder = chatPlaceholderDefault;
  }
  function submitAuthorPass(pass) {
    const raw = pass ?? "";
    endAuthorPrompt();
    toggleChatInput(false);
    if (!raw) {
      pushSystemChat("Author login cancelled.");
      return;
    }
    authorLogin(raw).then((ok) => {
      pushSystemChat(ok ? "Author mode enabled." : "Author login failed.");
    });
  }
  window.addEventListener("keydown", (e) => {
    if (e.target && e.target.tagName === "INPUT" && e.target !== chatInput) return;
    if (e.target === chatInput) {
      if (e.code === "Escape") {
        if (authorPromptActive) endAuthorPrompt();
        toggleChatInput(false);
        e.preventDefault();
      } else if (e.code === "Enter") {
        if (authorPromptActive) {
          submitAuthorPass(chatInput.value);
          e.preventDefault();
          return;
        }
        const text = chatInput.value.trim();
        if (text.startsWith("/name")) {
          const next = text.replace("/name", "").trim().slice(0, 20);
          if (next) PLAYER_NAME = next;
        } else if (text.startsWith("/author")) {
          const keepOpen = handleAuthorCommand(text);
          chatInput.value = "";
          if (!keepOpen) toggleChatInput(false);
          e.preventDefault();
          return;
        } else if (text.startsWith("/status")) {
          const msg = text.replace("/status", "").trim();
          if (msg) {
            sendChat(msg, { pin: true });
          }
        } else if (text.startsWith("/showjump")) {
          const arg = text.replace("/showjump", "").trim().toLowerCase();
          if (["on", "1", "true"].includes(arg)) {
            showJumpMode = true;
          } else if (["off", "0", "false"].includes(arg)) {
            showJumpMode = false;
          } else if (arg.length === 0) {
            showJumpMode = !showJumpMode;
          }
          pushSystemChat(`Jump mode ${showJumpMode ? "ON" : "OFF"} — last jump ${jumpMetrics.lastJump.toFixed(1)} tiles`);
        } else if (text.startsWith("/clear")) {
          clearLevelForAuthor();
        } else if (text.startsWith("/save")) {
          const ok = saveLevelSnapshot();
          pushSystemChat(ok ? "Level saved." : "Level save failed.");
        } else if (text.startsWith("/results")) {
          const dxMax = jumpMetrics.maxJump.toFixed(1);
          const dyMax = jumpMetrics.maxJumpDy.toFixed(1);
          const form = jumpMetrics.maxJumpForm || player.form || "unknown";
          const p0 = jumpMetrics.pReachTilesFromZero.toFixed(1);
          const pTime = jumpMetrics.pReachTimeFromZero ? `${jumpMetrics.pReachTimeFromZero.toFixed(2)}s` : "n/a";
          const summary = `Results — Max jump: ${dxMax} wide, ${dyMax} high (${form}); P: ${p0} tiles, ${pTime}`;
          copyToClipboard(summary).then((copied) => {
            pushSystemChat(copied ? `${summary} (copied)` : summary);
          });
        } else {
          sendChat(text);
        }
        chatInput.value = "";
        toggleChatInput(false);
        e.preventDefault();
      }
      return;
    }
    // Open chat with Enter only if inventory is closed
    if (e.code === "Enter" && !inventoryOpen) {
      toggleChatInput(chatInput.style.display === "none");
      e.preventDefault();
      return;
    }
    if (handleInventoryKey(e)) return;
    if (editorOpen && handleEditorClipboard(e)) {
      e.preventDefault();
      return;
    }
    if (editorOpen && e.ctrlKey && e.code === "KeyZ") {
      e.preventDefault();
      undoAction();
      return;
    }
    if (editorOpen && e.ctrlKey && e.code === "KeyY") {
      e.preventDefault();
      redoAction();
      return;
    }
    if (e.code === "KeyE") {
      setEditorOpen(!editorOpen);
      e.preventDefault();
      return;
    }
    if (e.code === "KeyT") {
      showTerrainDebug = !showTerrainDebug;
      e.preventDefault();
      return;
    }
    if (e.code === "KeyG") {
      showGrid = !showGrid;
      e.preventDefault();
      return;
    }
    if (e.code === "KeyJ") {
      showJumpGuide = !showJumpGuide;
      e.preventDefault();
      return;
    }
    if (!keys.has(e.code)) pressed.add(e.code);
    keys.add(e.code);
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
  }, { passive:false });

  window.addEventListener("keyup", (e) => {
    if (e.target && e.target.tagName === "INPUT") return;
    keys.delete(e.code);
  });

  // Clear keys when focus is lost to avoid stuck inputs causing auto actions
  window.addEventListener("blur", () => {
    keys.clear();
    pressed.clear();
  });

  function decayChatBubbles(dt) {
    if (selfChatBubble) {
      selfChatBubble.timer -= dt;
      if (selfChatBubble.timer <= 0) selfChatBubble = null;
    }
    for (const peer of peers.values()) {
      if (peer.bubble) {
        peer.bubble.timer -= dt;
        if (peer.bubble.timer <= 0) delete peer.bubble;
      }
    }
  }

  const down = (code) => keys.has(code);
  const tap = (code) => pressed.has(code);

  // -----------------------------
  // Editor palette interactions
  // -----------------------------
  const terrainGrid = document.getElementById("terrain-grid");
  const objectGrid = document.getElementById("object-grid");
  const enemyGrid = document.getElementById("enemy-grid");
  const spawnGrid = document.getElementById("spawn-grid");
  const labelInput = document.getElementById("editor-label-input");
  const textStampInput = document.getElementById("editor-text-stamp");
  const textStampButton = document.getElementById("editor-stamp-button");
  function updateStampButtonUI() {
    if (!textStampButton) return;
    textStampButton.classList.toggle("active", stampMode);
    textStampButton.textContent = stampMode ? "Stamp Mode ON" : "Stamp Mode OFF";
  }

  function updateLabelInput() {
    if (!labelInput) return;
    if (selectedCell) {
      const current = getLabel(selectedCell.tx, selectedCell.ty) || "";
      labelInput.value = current;
    } else {
      labelInput.value = "";
    }
  }

  function wirePaletteGrid(gridEl) {
    if (!gridEl) return;
    gridEl.querySelectorAll(".editor-tile").forEach(tileEl => {
      tileEl.addEventListener("click", () => {
        const tile = tileEl.getAttribute("data-tile") || "#";
        selectEditorTile(tile, tileEl);
      });
      tileEl.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        const tile = tileEl.getAttribute("data-tile") || "#";
        buildRoleMenu(tile, e.clientX, e.clientY);
      });
    });
  }

  wirePaletteGrid(terrainGrid);
  wirePaletteGrid(objectGrid);
  wirePaletteGrid(enemyGrid);
  wirePaletteGrid(spawnGrid);
  document.addEventListener("click", () => hideRoleMenu());
  document.addEventListener("keydown", (e) => {
    if (e.code === "Escape") hideRoleMenu();
  });
  // default select ground
  const first = (terrainGrid || objectGrid || enemyGrid || spawnGrid)?.querySelector(".editor-tile");
  if (first) selectEditorTile(first.getAttribute("data-tile") || "#", first);
  if (labelInput) {
    // prevent global hotkeys from interfering while typing
    ["keydown", "keyup", "mousedown"].forEach(ev => {
      labelInput.addEventListener(ev, (e) => {
        e.stopPropagation();
      });
    });
    labelInput.addEventListener("input", () => {
      if (!selectedCell) return;
      const prevTile = getTile(selectedCell.tx, selectedCell.ty);
      const prevLabel = getLabel(selectedCell.tx, selectedCell.ty);
      const nextLabel = labelInput.value.trim();
      if (prevLabel === nextLabel) return;
      setLabel(selectedCell.tx, selectedCell.ty, nextLabel);
      broadcastEditChange(selectedCell.tx, selectedCell.ty, prevTile, nextLabel);
      recordAction([{
        tx: selectedCell.tx, ty: selectedCell.ty,
        prevTile, prevLabel,
        nextTile: prevTile, nextLabel,
      }]);
    });
    updateLabelInput();
  }
  if (textStampInput) {
    ["keydown", "keyup", "mousedown"].forEach(ev => {
      textStampInput.addEventListener(ev, (e) => {
        e.stopPropagation();
      });
    });
  }
  if (textStampButton) {
    textStampButton.addEventListener("click", () => {
      stampMode = !stampMode;
      updateStampButtonUI();
    });
    updateStampButtonUI();
  }
  renderPalettePreviews();

  function setSelection(tx, ty) {
    ensureBounds(tx, ty);
    selectedCell = { tx, ty };
    updateLabelInput();
  }

  function recordAction(changes) {
    if (!changes || changes.length === 0) return;
    undoStack.push(changes);
    redoStack.length = 0;
  }

  function applyChanges(changes, useNext=true) {
    for (const c of changes) {
      if (c.prevTile === undefined && c.nextTile === undefined && c.prevLabel === undefined && c.nextLabel === undefined) continue;
      if (useNext) {
        if (c.nextTile !== undefined) setTileRaw(c.tx, c.ty, c.nextTile);
        if (c.nextLabel !== undefined) setLabelRaw(c.tx, c.ty, c.nextLabel);
        broadcastEditChange(c.tx, c.ty, c.nextTile, c.nextLabel);
      } else {
        if (c.prevTile !== undefined) setTileRaw(c.tx, c.ty, c.prevTile);
        if (c.prevLabel !== undefined) setLabelRaw(c.tx, c.ty, c.prevLabel);
        broadcastEditChange(c.tx, c.ty, c.prevTile, c.prevLabel);
      }
    }
  }

  function undoAction() {
    if (undoStack.length === 0) return;
    const changes = undoStack.pop();
    applyChanges(changes, false);
    redoStack.push(changes);
    updateLabelInput();
    captureTimelapseFrame();
  }

  function redoAction() {
    if (redoStack.length === 0) return;
    const changes = redoStack.pop();
    applyChanges(changes, true);
    undoStack.push(changes);
    updateLabelInput();
    captureTimelapseFrame();
  }

  function drawTilePreview(ctx, t) {
    ctx.imageSmoothingEnabled = false;
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    if (customTileSprites.has(t)) {
      const img = customTileSprites.get(t);
      if (img && img.complete) {
        ctx.drawImage(img, 0, 0, w, h);
        return;
      }
    }
    if (isTerrainTile(t)) {
      const previewMeta = {
        exposedTop: true,
        exposedBottom: true,
        exposedLeft: false,
        exposedRight: false,
        variant: "top-mid",
        label: null,
      };
      drawSmartTerrainFace(ctx, t, 0, 0, w, previewMeta, false);
      return;
    }
    if (t === "B") {
      ctx.fillStyle = "#7c3f2a";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(0, 1, w, 1);
      ctx.fillRect(0, Math.max(1, Math.floor(h / 2)), w, 1);
      ctx.fillRect(Math.floor(w / 2), 0, 1, h);
      return;
    }
    if (t === "?") {
      ctx.fillStyle = "#d1a23a";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#8a6a18";
      ctx.fillRect(0, h - Math.ceil(h * 0.25), w, Math.ceil(h * 0.25));
      ctx.fillStyle = "#fff2";
      ctx.fillRect(0, 0, w, Math.max(1, Math.round(h * 0.2)));
      ctx.fillStyle = "#2b1d05";
      ctx.fillRect(Math.floor(w/2) - 1, Math.floor(h/2) - 1, 2, 2);
      return;
    }
    if (t === "u") {
      ctx.fillStyle = "#8c8c8c";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#0002";
      ctx.fillRect(0, h - Math.ceil(h * 0.25), w, Math.ceil(h * 0.25));
      return;
    }
    if (t === "C") {
      ctx.fillStyle = "#0b1629";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#f5d000";
      ctx.fillRect(Math.floor(w/2) - 1, 1, 2, h - 2);
      ctx.fillRect(Math.floor(w/2) - 2, Math.floor(h/2) - 1, 4, 2);
      ctx.fillStyle = "#fff5";
      ctx.fillRect(Math.floor(w/2), 1, 1, 2);
      return;
    }
    if (t === "E") {
      ctx.fillStyle = "#0b1629";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#6b3b2a";
      ctx.fillRect(1, 1, w-2, h-2);
      ctx.fillStyle = "#000";
      ctx.fillRect(2, Math.floor(h/2), w-4, 1);
      return;
    }
    if (t === "P") {
      ctx.fillStyle = "#0b1629";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#2a49ff";
      ctx.fillRect(2, 2, w-4, h-4);
      ctx.fillStyle = "#f00";
      ctx.fillRect(2, 0, w-4, 2);
      return;
    }
  }

  function stampText(raw) {
    if (!selectedCell || !raw) return;
    const startX = selectedCell.tx;
    const startY = selectedCell.ty;
    const text = raw.toUpperCase();
    let cursorX = startX;
    const changes = [];
    for (const ch of text) {
      const glyph = TEXT_FONT[ch] || TEXT_FONT["?"];
      const glyphW = glyph[0].length;
      for (let y = 0; y < glyph.length; y++) {
        for (let x = 0; x < glyphW; x++) {
          if (glyph[y][x] === "1") {
            const tx = cursorX + x;
            const ty = startY + y;
            const prevTile = getTile(tx, ty);
            const prevLabel = getLabel(tx, ty);
            if (prevTile === editorTile) continue;
            setTile(tx, ty, editorTile);
            changes.push({
              tx, ty,
              prevTile, prevLabel,
              nextTile: editorTile,
              nextLabel: prevLabel,
            });
          }
        }
      }
      cursorX += glyphW + 1; // 1 tile gap
    }
    recordAction(changes);
    captureTimelapseFrame();
  }

  function renderPalettePreviews() {
    document.querySelectorAll(".tile-preview").forEach(canvasEl => {
      const t = canvasEl.getAttribute("data-tile") || "#";
      const ctx = canvasEl.getContext("2d", { alpha: false });
      ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
      drawTilePreview(ctx, t);
    });
  }

  function screenToCell(screenX, screenY) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const px = (screenX - rect.left) * scaleX;
    const py = (screenY - rect.top) * scaleY;
    const worldX = px + cam.x;
    const worldY = py + cam.y;
    return { tx: Math.floor(worldX / TILE), ty: Math.floor(worldY / TILE) };
  }

  function applyEditorPaint(screenX, screenY, remove=false) {
    if (!editorOpen) return;
    const cell = screenToCell(screenX, screenY);
    if (!cell) return;
    const prevTile = getTile(cell.tx, cell.ty);
    const prevLabel = getLabel(cell.tx, cell.ty);
    ensureBounds(cell.tx, cell.ty);
    setSelection(cell.tx, cell.ty);
    const nextTile = remove ? "." : editorTile;
    if (prevTile === nextTile) return;
    setTile(cell.tx, cell.ty, nextTile);
    broadcastEditChange(cell.tx, cell.ty, nextTile, prevLabel);
    recordAction([{
      tx: cell.tx, ty: cell.ty,
      prevTile, prevLabel,
      nextTile, nextLabel: prevLabel,
    }]);
    captureTimelapseFrame();
  }

  let paintingButton = null;
  canvas.addEventListener("mousedown", (e) => {
    if (!editorOpen) return;
    const cell = screenToCell(e.clientX, e.clientY);
    if (cell) setSelection(cell.tx, cell.ty);
    if (cell) {
      const sx = Math.floor(cell.tx * TILE - cam.x);
      const sy = Math.floor(cell.ty * TILE - cam.y);
      clickDebug = { sx, sy, tx: cell.tx, ty: cell.ty, timer: 0.5 };
    }
    if (stampMode && e.button === 0) {
      e.preventDefault();
      stampText(textStampInput ? textStampInput.value : "");
      return;
    }
    if (e.button === 0 || e.button === 2) {
      e.preventDefault();
      paintingButton = e.button;
      applyEditorPaint(e.clientX, e.clientY, e.button === 2);
    }
  });
  canvas.addEventListener("mousemove", (e) => {
    if (!editorOpen) return;
    const cell = screenToCell(e.clientX, e.clientY);
    hoverCell = cell || null;
    if (paintingButton !== null) {
      applyEditorPaint(e.clientX, e.clientY, paintingButton === 2);
    }
  });
  canvas.addEventListener("mouseup", () => {
    paintingButton = null;
  });
  canvas.addEventListener("mouseleave", () => {
    paintingButton = null;
    hoverCell = null;
  });
  canvas.addEventListener("contextmenu", (e) => {
    if (!editorOpen) return;
    e.preventDefault();
  });

  function handleEditorClipboard(e) {
    if (!editorOpen || !selectedCell) return false;
    const { tx, ty } = selectedCell;
    const tile = getTile(tx, ty);
    const hasTile = tile && tile !== ".";
    if (e.code === "KeyC" && e.ctrlKey) {
      if (hasTile) editorClipboard = tile;
      return true;
    }
    if (e.code === "KeyX" && e.ctrlKey) {
      if (hasTile) editorClipboard = tile;
      const prevLabel = getLabel(tx, ty);
      setTile(tx, ty, ".");
      recordAction([{
        tx, ty,
        prevTile: tile, prevLabel,
        nextTile: ".", nextLabel: prevLabel,
      }]);
      return true;
    }
    if (e.code === "KeyV" && e.ctrlKey) {
      if (editorClipboard) {
        const prevLabel = getLabel(tx, ty);
        const prevTile = getTile(tx, ty);
        setTile(tx, ty, editorClipboard);
        recordAction([{
          tx, ty,
          prevTile, prevLabel,
          nextTile: editorClipboard,
          nextLabel: prevLabel,
        }]);
      }
      return true;
    }
    return false;
  }

  // -----------------------------
  // Level
  // Legend:
  //  . empty
  //  # solid ground
  //  B solid brick
  //  I ice (slippery)
//  S sand (heavy)
//  W water (swimmable)
//  L ladder (climbable)
//  ? question block
  //  u used block
  //  C coin (pickup, not solid)
  //  E enemy spawn
  //  P player spawn
  // -----------------------------
  const ORIGINAL_LEVEL = [
    "................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "......................C.............?...........C...............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "..............?............................?....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    ".............BBB.........................BBB....................C...............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    ".....................................................E..........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "....P......................IIIIII...............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "########################SSSSSS############################.....#################................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "########################SSSSSS############################.....#################................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................"
  ];

  function buildEndlessLevel() {
    const baseWidth = 96;
    const ground = "#".repeat(baseWidth);
    const air = ".".repeat(baseWidth);
    const playerRow = ".P" + ".".repeat(Math.max(0, baseWidth - 2));
    return [
      air, air, air, air, air, air, air, air, air,
      playerRow,
      air, air,
      ground,
      ground
    ];
  }

  function padLevelVertical(baseLevel) {
    if (!baseLevel.length) return baseLevel;
    const width = baseLevel[0].length;
    const emptyRow = ".".repeat(width);
    // Add generous headroom so multiple atmospheric/space layers are reachable
    const topPadRows = PLAYFIELD_TILES * 8; // 8 screens of empty sky above start
    const topPad = Array.from({ length: topPadRows }, () => emptyRow);
    let padded = [...topPad, ...baseLevel];
    const bottomRow = baseLevel[baseLevel.length - 1] || emptyRow;
    const minRows = Math.max(MIN_LEVEL_ROWS, padded.length);
    while (padded.length < minRows) padded.push(bottomRow);

    undergroundStartPx = padded.length * TILE;
    undergroundStartTy = padded.length;
    const undergroundRows = Array.from({ length: UNDERGROUND_ROWS }, (_, i) =>
      i === UNDERGROUND_ROWS - 1 ? bottomRow : emptyRow
    );
    padded = [...padded, ...undergroundRows];

    return padded;
  }

  const BASE_LEVEL = ENDLESS_ENABLED ? buildEndlessLevel() : ORIGINAL_LEVEL;
  const LEVEL = padLevelVertical(BASE_LEVEL);

  let mapH = LEVEL.length;
  let mapW = LEVEL[0].length;
  const tiles = LEVEL.map(row => row.split(""));
  const labelMap = new Map(); // key: "tx,ty" -> string

  // -----------------------------
  // Endless world data
  // -----------------------------
  const VIEW_TILES = Math.ceil(BASE_W / TILE);
  const WORLD_AHEAD_TILES = 24;
  const WORLD_BUFFER_TILES = VIEW_TILES + WORLD_AHEAD_TILES;
  let defaultGroundY = Math.max(4, mapH - 2);

  // Layering (one on-screen playfield tall per layer)
  const LAYER_HEIGHT_PX = CAMERA_SEGMENT_PX;
  const LAYER_LABEL_UP = [
    "Above Surface",
    "High Altitude / Sky",
    "Atmosphere",
    "Upper Atmosphere",
    "Space",
    "Deep Space",
  ];
  const LAYER_LABEL_DOWN = [
    "Shallow Underground",
    "Underground",
    "Deep Underground",
  ];
  let layerOriginY = 0; // set once player spawn is known
  function layerInfoForY(worldY) {
    const altitude = layerOriginY - worldY; // going up increases altitude
    const relLayer = Math.floor(altitude / LAYER_HEIGHT_PX);
    if (relLayer === 0) return { index: relLayer, label: "Surface" };
    if (relLayer > 0) {
      const label = LAYER_LABEL_UP[relLayer - 1] || LAYER_LABEL_UP[LAYER_LABEL_UP.length - 1] || `Layer ${relLayer}`;
      return { index: relLayer, label };
    }
    const depthIdx = Math.abs(relLayer) - 1;
    const downLabel = LAYER_LABEL_DOWN[depthIdx] || LAYER_LABEL_DOWN[LAYER_LABEL_DOWN.length - 1] || "Deep Underground";
    return { index: relLayer, label: downLabel };
  }

  function hashSeed(str) {
    let h = 2166136261 >>> 0;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  function mulberry32(seed) {
    let a = seed >>> 0;
    return () => {
      a = (a + 0x6D2B79F5) | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  function createRng(seedStr = "endless") {
    let rand = mulberry32(hashSeed(seedStr));
    return {
      seed: seedStr,
      next() { return rand(); },
      range(min, max) { return min + (max - min) * rand(); },
      int(min, max) { return Math.floor(rand() * (max - min + 1)) + min; },
      bool(prob = 0.5) { return rand() < prob; },
      reseed(nextSeed) {
        this.seed = nextSeed;
        rand = mulberry32(hashSeed(nextSeed));
      },
    };
  }

  const worldSeed = "playfree-global-seed";
  const worldRng = createRng(worldSeed);

  function makeColumn(tx, ground = defaultGroundY, tilesForCol = [], entities = []) {
    return { tx, ground, tiles: tilesForCol, entities };
  }

  const worldBuffer = {
    columns: [],
    view: VIEW_TILES,
    ahead: WORLD_AHEAD_TILES,
    target: WORLD_BUFFER_TILES,
    startTx: mapW,
    nextTx: mapW,
  };

  function resetWorldBuffer() {
    worldBuffer.columns.length = 0;
    worldBuffer.startTx = mapW;
    worldBuffer.nextTx = mapW;
    defaultGroundY = Math.max(4, mapH - 2);
  }

  const difficultyTuning = Object.freeze({
    baseSpeed: WALK_MAX,
    maxSpeed: P_SPEED_MAX,
    speedRampPerSecond: 0.5,
    baseBudget: 1,
    budgetRampPerChunk: 0.15,
    budgetCap: 12,
  });

  // Endless generator tuning
  const GROUND_MIN = 2;
  const GROUND_MAX = Math.max(GROUND_MIN + 2, mapH - 2);
  const SLOPE_LIMIT = 1;
  const GAP_MIN = 1;
  const GAP_MAX_SAFE = 5; // generous run jump; tune with player jump charts
  const LANDING_PAD = 2;
  const ENEMY_COST = 1;
  const ENEMY_COOLDOWN_COLS = 3;
  const GAP_COOLDOWN_COLS = 6;
  const GAP_RESCUE_STEP = 1;         // spacing between ladder rungs inside gaps
  const GAP_RESCUE_BOTTOM_PAD = 1;   // keep the first rescue rung above the implicit bedrock
  const GAP_RESCUE_HEADROOM = 1;     // keep at least one open tile at the rim
  const HAZARD_COOLDOWN_COLS = 2;
  const REST_INTERVAL_COLS = 14;
  const REST_PAD_COLS = 2;
  const BUDGET_DISTANCE_SCALE = 0.002;
  const SPEED_DISTANCE_GAIN = 0.08; // px/s per tile of distance
  const PATTERN_BASE_WEIGHTS = { flat: 1, gap: 1, enemy: 1.1 };
  let showEndlessDebug = ENDLESS_DEBUG;

  function createDifficultyState() {
    return {
      distance: 0,
      hazardBudget: difficultyTuning.baseBudget,
      hazardCooldown: 0,
      enemyCooldown: 0,
      gapCooldown: 0,
      speed: difficultyTuning.baseSpeed,
      groundY: defaultGroundY,
      gapRemaining: 0,
      safeLanding: 0,
      restCountdown: REST_INTERVAL_COLS,
      patternUse: { flat: 0, gap: 0, enemy: 0 },
      gapRescue: null,
    };
  }

  let difficultyState = createDifficultyState();

  function resetDifficultyState() {
    difficultyState = createDifficultyState();
  }

  resetWorldBuffer();

  // -----------------------------
  // Endless column generator
  // -----------------------------

  function clampGround(y) {
    return clamp(y, GROUND_MIN, GROUND_MAX);
  }

  function canAfford(state, cost) {
    if (state.hazardBudget < cost) return false;
    state.hazardBudget -= cost;
    return true;
  }

  function regenBudget(state) {
    const distanceBoost = state.distance * BUDGET_DISTANCE_SCALE;
    state.hazardBudget = Math.min(
      difficultyTuning.budgetCap,
      state.hazardBudget + difficultyTuning.budgetRampPerChunk + distanceBoost
    );
  }

  function pickPattern(state, choices, rng = worldRng) {
    if (!choices || choices.length === 0) return "flat";
    const usage = state.patternUse || {};
    let total = 0;
    const weights = choices.map((name) => {
      const base = PATTERN_BASE_WEIGHTS[name] || 1;
      const count = usage[name] || 0;
      const w = base / Math.max(1, count + 0.5); // bias toward underused
      total += w;
      return { name, w };
    });
    let r = rng.range(0, total);
    for (const entry of weights) {
      if ((r -= entry.w) <= 0) return entry.name;
    }
    return choices[choices.length - 1];
  }

  function gapRescuePlan(startTx, gapWidth, groundY, rng) {
    const sideRight = rng.bool();
    // Gap length includes the start column plus remaining columns
    const rescueTx = startTx + (sideRight ? gapWidth : 0);
    const bottomY = Math.max(GROUND_MIN, mapH - GAP_RESCUE_BOTTOM_PAD);
    const topY = Math.max(GROUND_MIN, groundY - GAP_RESCUE_HEADROOM - 1);
    const steps = [];
    for (let y = bottomY; y >= topY; y -= GAP_RESCUE_STEP) {
      steps.push(y);
    }
    return { rescueTx, steps };
  }

  function addGapRescueTiles(state, tx, tilesForCol) {
    const plan = state.gapRescue;
    if (!plan || plan.rescueTx !== tx) return;
    for (const y of plan.steps) tilesForCol.push({ t: "L", y });
  }

  function genColumn(state, tx, rng = worldRng) {
    for (let attempt = 0; attempt < 6; attempt++) {
      const nextState = { ...state };
      const tilesForCol = [];
      const entitiesForCol = [];
      let groundY = nextState.groundY;

      if (nextState.gapRemaining <= 0) nextState.gapRescue = null;

      // Respect ongoing gap
      if (nextState.gapRemaining > 0) {
        nextState.gapRemaining -= 1;
        nextState.safeLanding = Math.max(nextState.safeLanding, LANDING_PAD);
        nextState.gapCooldown = Math.max(nextState.gapCooldown - 1, 0);
        addGapRescueTiles(nextState, tx, tilesForCol);
        regenBudget(nextState);
        const col = makeColumn(tx, groundY, tilesForCol, entitiesForCol);
        col.variant = "gap";
        return [col, nextState];
      }

      const mustRest = nextState.restCountdown <= 0;

      // Drift ground height
      groundY = clampGround(groundY + rng.int(-SLOPE_LIMIT, SLOPE_LIMIT));
      nextState.groundY = groundY;

      // Pattern selection with weighted bias to underused
      const patternChoices = ["flat"];
      const hazardFree = nextState.safeLanding === 0 && nextState.hazardCooldown === 0 && !mustRest;
      if (hazardFree && nextState.gapCooldown === 0) patternChoices.push("gap");
      if (hazardFree && nextState.enemyCooldown === 0 && nextState.hazardBudget >= ENEMY_COST) patternChoices.push("enemy");
      const pattern = mustRest ? "flat" : pickPattern(nextState, patternChoices, rng);
      nextState.patternUse = { ...nextState.patternUse, [pattern]: (nextState.patternUse?.[pattern] || 0) + 1 };

      if (pattern === "gap") {
        const gapWidth = rng.int(GAP_MIN, GAP_MAX_SAFE);
        nextState.gapRemaining = gapWidth; // this column plus remaining
        nextState.gapCooldown = GAP_COOLDOWN_COLS;
        nextState.safeLanding = LANDING_PAD;
        nextState.gapRescue = gapRescuePlan(tx, gapWidth, groundY, rng);
        addGapRescueTiles(nextState, tx, tilesForCol);
        regenBudget(nextState);
        const col = makeColumn(tx, groundY, tilesForCol, entitiesForCol);
        col.variant = "gap";
        return [col, nextState];
      }

      // Build solid floor from ground to bottom
      for (let y = groundY; y < mapH; y++) {
        tilesForCol.push({ t: "#", y });
      }

      if (pattern === "enemy") {
        if (canAfford(nextState, ENEMY_COST)) {
          entitiesForCol.push({ type: "goon", x: tx * TILE + 1, y: (groundY - 1) * TILE });
          nextState.enemyCooldown = ENEMY_COOLDOWN_COLS;
          nextState.hazardCooldown = HAZARD_COOLDOWN_COLS;
        }
      }

      // Landings after hazards
      if (nextState.safeLanding > 0) {
        nextState.safeLanding -= 1;
      }

      // Cooldowns tick
      nextState.enemyCooldown = Math.max(0, nextState.enemyCooldown - 1);
      nextState.gapCooldown = Math.max(0, nextState.gapCooldown - 1);
      nextState.hazardCooldown = Math.max(0, nextState.hazardCooldown - 1);
      if (mustRest) {
        nextState.safeLanding = Math.max(nextState.safeLanding, REST_PAD_COLS);
        nextState.restCountdown = REST_INTERVAL_COLS;
      } else {
        nextState.restCountdown = Math.max(0, nextState.restCountdown - 1);
      }
      nextState.distance += 1;
      regenBudget(nextState);

      // Column is valid; return
      return [makeColumn(tx, groundY, tilesForCol, entitiesForCol), nextState];
    }

    // Fallback: return flat column if all attempts failed
    const fallbackGround = clampGround(state.groundY);
    const flatTiles = [];
    for (let y = fallbackGround; y < mapH; y++) flatTiles.push({ t: "#", y });
    const safeState = {
      ...state,
      groundY: fallbackGround,
      gapRemaining: 0,
      safeLanding: LANDING_PAD,
      patternUse: { ...(state.patternUse || {}) },
    };
    regenBudget(safeState);
    return [makeColumn(tx, fallbackGround, flatTiles, []), safeState];
  }

  function applyColumnToWorld(col) {
    if (col.applied) return;
    ensureBounds(col.tx, 0);
    for (const { t, y } of col.tiles) {
      setTileRaw(col.tx, y, t);
    }
    for (const e of col.entities) {
      if (e.type === "goon") {
        const tx = Math.floor(e.x / TILE);
        const ty = Math.floor(e.y / TILE);
        spawnEnemy(tx, ty);
      }
    }
    col.applied = true;
    updateWorldWidth();
  }

  function updateEndlessWorld(dt) {
    if (!ENDLESS_ENABLED) return;

    // Ramp player speed targets over time and distance; generator uses budget per column.
    const targetSpeed = clamp(
      difficultyTuning.baseSpeed + difficultyState.distance * SPEED_DISTANCE_GAIN,
      difficultyTuning.baseSpeed,
      difficultyTuning.maxSpeed
    );
    if (difficultyState.speed < targetSpeed) {
      difficultyState.speed = Math.min(
        targetSpeed,
        difficultyState.speed + difficultyTuning.speedRampPerSecond * dt
      );
    }

    const viewLeftTx = Math.floor(cam.x / TILE);
    const viewRightTx = viewLeftTx + worldBuffer.view;
    const needUpTo = viewRightTx + worldBuffer.ahead;

    while (worldBuffer.nextTx <= needUpTo) {
      const [col, nextState] = genColumn(difficultyState, worldBuffer.nextTx, worldRng);
      difficultyState = nextState;
      worldBuffer.columns.push(col);
      applyColumnToWorld(col);
      worldBuffer.nextTx += 1;
    }

    // drop old columns from buffer to bound memory; keep a small margin behind view
    const minKeepTx = Math.max(0, viewLeftTx - 4);
    while (worldBuffer.columns.length > worldBuffer.target || (worldBuffer.columns[0] && worldBuffer.columns[0].tx < minKeepTx)) {
      worldBuffer.columns.shift();
    }

    // Despawn non-player entities well behind the camera
    const despawnX = Math.max(0, (viewLeftTx - 6) * TILE);
    if (despawnX > 0) {
      for (const e of entities) {
        if (!e.alive) continue;
        if (e.type === "player") continue;
        if (e.x + e.w < despawnX) e.alive = false;
      }
    }

    // Spawn dungeon chunks when underground
    maybeGenerateDungeon();
  }

  // -----------------------------
  // Dungeon generation (underground, endless)
  // -----------------------------
  function dungeonChunkKey(cx, cy) { return `${cx},${cy}`; }
  function dungeonRng(cx, cy) { return createRng(`${worldSeed}:d:${cx},${cy}`); }

  function setDungeonTile(updates, tx, ty, t) {
    updates.push({ tx, ty, t });
  }

  function carveRoom(updates, originX, originY, room) {
    const rx = originX + room.x;
    const ry = originY + room.y;
    const floorY = ry + room.h - 1;
    for (let y = ry; y < ry + room.h; y++) {
      for (let x = rx; x < rx + room.w; x++) {
        setDungeonTile(updates, x, y, y === floorY ? "#" : ".");
      }
    }
  }

  function carveCorridor(updates, x0, y0, x1, y1) {
    const floorY = Math.round(y0);
    const minX = Math.min(x0, x1);
    const maxX = Math.max(x0, x1);
    for (let x = minX; x <= maxX; x++) {
      setDungeonTile(updates, x, floorY, "#");
      setDungeonTile(updates, x, floorY - 1, ".");
      setDungeonTile(updates, x, floorY - 2, ".");
    }
    const minY = Math.min(y0, y1);
    const maxY = Math.max(y0, y1);
    for (let y = minY; y <= maxY; y++) {
      setDungeonTile(updates, x1, y, "#");
      setDungeonTile(updates, x1, y - 1, ".");
      setDungeonTile(updates, x1, y - 2, ".");
    }
  }

  function splitSpace(rect, depth, rng, leaves) {
    const canSplitH = rect.w >= DUNGEON_MIN_ROOM * 2 + 4;
    const canSplitV = rect.h >= DUNGEON_MIN_ROOM * 2 + 4;
    if (depth >= DUNGEON_MAX_DEPTH || (!canSplitH && !canSplitV)) {
      leaves.push(rect);
      return;
    }
    const splitHoriz = canSplitH && (canSplitV ? rng.bool(0.5) : true);
    if (splitHoriz) {
      const split = rng.int(DUNGEON_MIN_ROOM + 2, rect.w - DUNGEON_MIN_ROOM - 2);
      splitSpace({ x: rect.x, y: rect.y, w: split, h: rect.h }, depth + 1, rng, leaves);
      splitSpace({ x: rect.x + split, y: rect.y, w: rect.w - split, h: rect.h }, depth + 1, rng, leaves);
    } else {
      const split = rng.int(DUNGEON_MIN_ROOM + 2, rect.h - DUNGEON_MIN_ROOM - 2);
      splitSpace({ x: rect.x, y: rect.y, w: rect.w, h: split }, depth + 1, rng, leaves);
      splitSpace({ x: rect.x, y: rect.y + split, w: rect.w, h: rect.h - split }, depth + 1, rng, leaves);
    }
  }

  function createDungeonRooms(rng) {
    const leaves = [];
    splitSpace({ x: 1, y: 1, w: DUNGEON_CHUNK_W - 2, h: DUNGEON_CHUNK_H - 2 }, 0, rng, leaves);
    const rooms = [];
    for (const leaf of leaves) {
      const roomW = rng.int(DUNGEON_MIN_ROOM, Math.max(DUNGEON_MIN_ROOM, leaf.w - 1));
      const roomH = rng.int(DUNGEON_MIN_ROOM, Math.max(DUNGEON_MIN_ROOM, leaf.h - 1));
      const rx = leaf.x + rng.int(0, Math.max(1, leaf.w - roomW));
      const ry = leaf.y + rng.int(0, Math.max(1, leaf.h - roomH));
      rooms.push({ x: rx, y: ry, w: roomW, h: roomH });
    }
    return rooms;
  }

  function generateDungeonChunk(cx, cy) {
    const key = dungeonChunkKey(cx, cy);
    if (dungeonChunks.has(key)) return;
    const rng = dungeonRng(cx, cy);
    const originX = cx * DUNGEON_CHUNK_W;
    const originY = undergroundStartTy + cy * DUNGEON_CHUNK_H;
    const updates = [];
    const rooms = createDungeonRooms(rng);
    for (const room of rooms) carveRoom(updates, originX, originY, room);
    for (let i = 1; i < rooms.length; i++) {
      const a = rooms[i - 1];
      const b = rooms[i];
      const ax = originX + Math.floor(a.x + a.w / 2);
      const ay = originY + Math.floor(a.y + a.h / 2);
      const bx = originX + Math.floor(b.x + b.w / 2);
      const by = originY + Math.floor(b.y + b.h / 2);
      carveCorridor(updates, ax, ay, bx, ay);
      carveCorridor(updates, bx, ay, bx, by);
    }
    for (const { tx, ty, t } of updates) {
      ensureBounds(tx, ty);
      setTileRaw(tx, ty, t);
    }
    dungeonChunks.set(key, true);
  }

  function maybeGenerateDungeon() {
    if (!ENDLESS_ENABLED) return;
    if (!Number.isFinite(undergroundStartTy)) return;
    const playerTy = Math.floor(player.y / TILE);
    if (playerTy < undergroundStartTy) return;
    const playerCx = Math.floor((player.x / TILE) / DUNGEON_CHUNK_W);
    const playerCy = Math.floor((playerTy - undergroundStartTy) / DUNGEON_CHUNK_H);
    const radius = 1;
    for (let cy = playerCy - radius; cy <= playerCy + radius; cy++) {
      for (let cx = playerCx - radius; cx <= playerCx + radius; cx++) {
        if (cy < 0) continue;
        generateDungeonChunk(cx, cy);
      }
    }
  }

  function endlessSnapshot(seed = "test", columns = 120) {
    const rng = createRng(seed);
    let state = createDifficultyState();
    const signature = [];
    let gapLen = 0;
    let prevGround = state.groundY;
    for (let i = 0; i < columns; i++) {
      const [col, next] = genColumn(state, i, rng);
      state = next;
      const isGap = col.variant === "gap" || col.tiles.length === 0;
      gapLen = isGap ? gapLen + 1 : 0;
      signature.push({ g: col.ground, gap: isGap, budget: Number(state.hazardBudget.toFixed(2)) });
      if (Math.abs(col.ground - prevGround) > SLOPE_LIMIT) {
        throw new Error(`Slope too steep at col ${i}`);
      }
      if (gapLen > GAP_MAX_SAFE) {
        throw new Error(`Gap too wide at col ${i} (len ${gapLen})`);
      }
      if (!isGap) prevGround = col.ground;
    }
    return signature;
  }

  function runEndlessSelfTest(seed = "test", columns = 200) {
    const errors = [];
    let snapshotA, snapshotB;
    try {
      snapshotA = endlessSnapshot(seed, columns);
      snapshotB = endlessSnapshot(seed, columns);
    } catch (err) {
      errors.push(err.message || String(err));
    }
    if (snapshotA && snapshotB && JSON.stringify(snapshotA) !== JSON.stringify(snapshotB)) {
      errors.push("Determinism check failed");
    }
    return { ok: errors.length === 0, errors, sample: snapshotA ? snapshotA.slice(0, 12) : [] };
  }

  const jumpMetrics = {
    startTx: null,
    startTy: null,
    lastJump: 0,
    lastJumpDx: 0,
    lastJumpDy: 0,
    maxJump: 0,
    maxJumpDy: 0,
    maxJumpForm: null,
    pStartTx: null,
    pDistance: 0,
    pBuildStartTx: null,
    pReachTilesFromZero: 0,
    pBuildStartTime: null,
    pReachTimeFromZero: 0,
    pRunStartTile: null,
    pRunStartTime: null,
    pLastMode: "none",
  };
  let showJumpMode = false;

  function jumpCenterTile() {
    return (player.x + player.w / 2) / TILE;
  }

  function startJumpTrack() {
    jumpMetrics.startTx = jumpCenterTile();
    jumpMetrics.startTy = Math.floor((player.y + player.h - 1) / TILE);
  }

  window.endlessSnapshot = endlessSnapshot;
  window.runEndlessSelfTest = runEndlessSelfTest;
  window.endlessReseed = (seed = worldRng.seed) => {
    if (!ENDLESS_ENABLED) {
      console.warn("Endless reseed ignored; not in endless mode");
      return false;
    }
    const nextSeed = seed || worldRng.seed || "endless";
    worldRng.reseed(nextSeed);
    resetDifficultyState();
    resetWorldBuffer();
    restart();
    return nextSeed;
  };
  window.toggleEndlessDebug = (on) => {
    showEndlessDebug = typeof on === "boolean" ? on : !showEndlessDebug;
    return showEndlessDebug;
  };
  window.jumpMetrics = jumpMetrics;

  const isCustomTileId = (t) => typeof t === "string" && t.startsWith("~");
  const serializeLevelSnapshot = () => {
    return {
      tiles: tiles.map(row => row.join("")),
      labels: Array.from(labelMap.entries()),
      customTiles: Array.from(customTileMap.entries()),
      customSprites: Array.from(customTileDataUrls.entries()),
      customSheet: customPaletteSheetUrl,
      customSheetScale: customPaletteSheetScale,
      customSheetCols: customPaletteSheetCols,
      customSheetRows: customPaletteSheetRows,
      paletteName: (tilesetPaletteName && tilesetPaletteName.value.trim()) || "Custom",
    };
  };

  const loadLevelSnapshot = () => {
    if (ENDLESS_ENABLED) return false; // never override endless seed with local save
    if (typeof localStorage === "undefined") return false;
    const raw = localStorage.getItem(LEVEL_SAVE_KEY);
    if (!raw) return false;
    try {
      const data = JSON.parse(raw);
      if (Array.isArray(data.tiles)) {
        tiles.length = 0;
        for (const row of data.tiles) tiles.push(row.split(""));
        mapH = tiles.length;
        mapW = tiles[0]?.length || 0;
        defaultGroundY = Math.max(4, mapH - 2);
        updateWorldWidth();
        if (ENDLESS_ENABLED) {
          resetDifficultyState();
          resetWorldBuffer();
        }
      }
      labelMap.clear();
      if (Array.isArray(data.labels)) {
        for (const [key, value] of data.labels) labelMap.set(key, value);
      }
      customTileMap.clear();
      if (Array.isArray(data.customTiles)) {
        for (const [key, value] of data.customTiles) customTileMap.set(key, value);
      }
      customTileSprites.clear();
      customTileDataUrls.clear();
      customPaletteSheetCols = null;
      customPaletteSheetRows = null;
      updateCustomSheetPreview(null);
      if (Array.isArray(data.customSprites)) {
        for (const [tileId, url] of data.customSprites) {
          const img = new Image();
          img.src = url;
          customTileSprites.set(tileId, img);
          customTileDataUrls.set(tileId, url);
        }
      }
      if (data.customSheet) {
        updateCustomSheetPreview(data.customSheet, data.customSheetScale || 1);
      }
      if (Number.isFinite(data.customSheetCols)) customPaletteSheetCols = data.customSheetCols;
      if (Number.isFinite(data.customSheetRows)) customPaletteSheetRows = data.customSheetRows;
      if (customPaletteGrid) {
        customPaletteGrid.innerHTML = "";
        for (const tileId of customTileSprites.keys()) {
          const tileEl = document.createElement("div");
          tileEl.className = "editor-tile";
          tileEl.setAttribute("data-tile", tileId);
          const preview = document.createElement("canvas");
          preview.className = "tile-preview";
          preview.width = 8;
          preview.height = 8;
          preview.setAttribute("data-tile", tileId);
          tileEl.appendChild(preview);
          customPaletteGrid.appendChild(tileEl);
        }
        applyCustomPaletteLayout(customPaletteGrid);
        wirePaletteGrid(customPaletteGrid);
      }
      const paletteName = data.paletteName || "Custom";
      if (customPaletteTitle) customPaletteTitle.textContent = paletteName.toUpperCase();
      if (tilesetPaletteName) tilesetPaletteName.value = paletteName;
      if (customTileSprites.size > 0) document.body.classList.add("has-custom-tiles");
      renderPalettePreviews();
      hasLocalSnapshot = true;
      return true;
    } catch (err) {
      return false;
    }
  };

  const saveLevelSnapshot = () => {
    if (typeof localStorage === "undefined") return false;
    try {
      localStorage.setItem(LEVEL_SAVE_KEY, JSON.stringify(serializeLevelSnapshot()));
      hasLocalSnapshot = true;
      return true;
    } catch (err) {
      return false;
    }
  };
  const clearCustomTiles = () => {
    if (!customPaletteGrid) return;
    customPaletteGrid.innerHTML = "";
    customPaletteGrid.style.gridTemplateColumns = "";
    customPaletteGrid.style.width = "";
    customTileSprites.clear();
    customTileDataUrls.clear();
    customTileMap.clear();
    customPaletteSheetCols = null;
    customPaletteSheetRows = null;
    updateCustomSheetPreview(null);
    document.body.classList.remove("has-custom-tiles");
    if (tilesetPaletteName) tilesetPaletteName.value = "Custom";
    if (customPaletteTitle) customPaletteTitle.textContent = "CUSTOM";
    renderPalettePreviews();
    saveLevelSnapshot();
    pushSystemChat("Custom tiles cleared.");
  };
  if (customPaletteClear) {
    customPaletteClear.addEventListener("click", () => {
      clearCustomTiles();
    });
  }

  function ensureBounds(tx, ty) {
    let grew = false;
    while (ty >= tiles.length) {
      tiles.push(new Array(mapW).fill("."));
      grew = true;
    }
    if (grew) {
      mapH = tiles.length;
      updateWorldWidth();
    }
    if (tx >= mapW) {
      const add = tx - mapW + 1;
      for (const row of tiles) {
        for (let i = 0; i < add; i++) row.push(".");
      }
      mapW = tiles[0].length;
      updateWorldWidth();
    }
  }

  function inBounds(tx, ty) { return tx >= 0 && ty >= 0 && tx < mapW && ty < mapH; }

  function getTile(tx, ty) {
    if (!inBounds(tx, ty)) return "#"; // treat out-of-bounds as solid wall
    const key = labelKey(tx, ty);
    if (customTileMap.has(key)) return customTileMap.get(key);
    return tiles[ty][tx];
  }
  function setTileRaw(tx, ty, v) {
    ensureBounds(tx, ty);
    const key = labelKey(tx, ty);
    if (isCustomTileId(v)) {
      customTileMap.set(key, v);
      tiles[ty][tx] = ".";
    } else {
      customTileMap.delete(key);
      tiles[ty][tx] = v;
    }
  }
  function setTile(tx, ty, v) {
    setTileRaw(tx, ty, v);
  }
  function labelKey(tx, ty) { return `${tx},${ty}`; }
  function getLabel(tx, ty) {
    return labelMap.get(labelKey(tx, ty));
  }
  function setLabelRaw(tx, ty, text) {
    const key = labelKey(tx, ty);
    if (!text) {
      labelMap.delete(key);
    } else {
      labelMap.set(key, text);
    }
  }
  function setLabel(tx, ty, text) {
    setLabelRaw(tx, ty, text);
  }
  function isLadder(t) { return t === "L"; }
  function isSolid(t) {
    if (isCustomTileId(t)) return true;
    return t === "#" || t === "B" || t === "?" || t === "u" || t === "I" || t === "S";
  }
  function isQuestion(t){ return t === "?"; }
  function isCoinTile(t){ return t === "C"; }
  function surfaceType(t) {
    if (t === "I") return "ice";
    if (t === "S") return "sand";
    return null;
  }

  function isWaterTile(t) {
    return t === "W";
  }
  function isBodyOnLadder(body) {
    const x0 = Math.floor(body.x / TILE);
    const x1 = Math.floor((body.x + body.w - 1) / TILE);
    const y0 = Math.floor(body.y / TILE);
    const y1 = Math.floor((body.y + body.h - 1) / TILE);
    for (let ty = y0; ty <= y1; ty++) {
      for (let tx = x0; tx <= x1; tx++) {
        if (isLadder(getTile(tx, ty))) return true;
      }
    }
    return false;
  }
  function classifyTerrainTile(tx, ty) {
    const tile = getTile(tx, ty);
    if (!isTerrainTile(tile)) return null;
    const same = (dx, dy) => getTile(tx + dx, ty + dy) === tile;
    const above = same(0, -1);
    const below = same(0, 1);
    const left = same(-1, 0);
    const right = same(1, 0);
    const meta = {
      tile,
      exposedTop: !above,
      exposedBottom: !below,
      exposedLeft: !left,
      exposedRight: !right,
      variant: "body",
      label: null,
    };

    if (meta.exposedTop) {
      if (meta.exposedLeft && meta.exposedRight) {
        meta.variant = "top-single";
        meta.label = "TS";
      } else if (meta.exposedLeft) {
        meta.variant = "top-left";
        meta.label = "TL";
      } else if (meta.exposedRight) {
        meta.variant = "top-right";
        meta.label = "TR";
      } else {
        meta.variant = "top-mid";
        meta.label = "TM";
      }
      return meta;
    }

    if (meta.exposedLeft && meta.exposedRight) {
      meta.variant = "pillar";
      meta.label = "GP";
      return meta;
    }
    if (meta.exposedLeft) {
      meta.variant = "gap-left";
      meta.label = "GL";
      return meta;
    }
    if (meta.exposedRight) {
      meta.variant = "gap-right";
      meta.label = "GR";
      return meta;
    }

    if (meta.exposedBottom && !meta.label) {
      meta.variant = "ledge";
      meta.label = "BT";
    }

    return meta;
  }

  function ensureRoleMenu() {
    if (roleMenuEl) return roleMenuEl;
    const menu = document.createElement("div");
    menu.id = "terrain-role-menu";
    menu.style.position = "fixed";
    menu.style.zIndex = "1200";
    menu.style.background = "#0f182a";
    menu.style.border = "2px solid #0a0f1f";
    menu.style.boxShadow = "0 8px 18px rgba(0,0,0,0.35)";
    menu.style.padding = "8px";
    menu.style.borderRadius = "8px";
    menu.style.minWidth = "160px";
    menu.style.display = "none";
    menu.style.font = "12px 'Press Start 2P', 'VT323', monospace";
    menu.addEventListener("click", (e) => e.stopPropagation());
    document.body.appendChild(menu);
    roleMenuEl = menu;
    return menu;
  }
  function hideRoleMenu() {
    if (!roleMenuEl) return;
    roleMenuEl.style.display = "none";
    roleMenuEl.dataset.tile = "";
  }
  function buildRoleMenu(tile, x, y) {
    const menu = ensureRoleMenu();
    menu.innerHTML = "";
    const title = document.createElement("div");
    title.textContent = `Map ${tile} to…`;
    title.style.color = "#dfe7ff";
    title.style.marginBottom = "6px";
    menu.appendChild(title);
    TERRAIN_ROLE_CHOICES.forEach((choice) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.textContent = choice.label;
      btn.style.display = "block";
      btn.style.width = "100%";
      btn.style.margin = "4px 0";
      btn.style.padding = "6px";
      btn.style.font = "12px 'Press Start 2P', 'VT323', monospace";
      btn.style.background = "#1a2740";
      btn.style.color = "#dfe7ff";
      btn.style.border = "1px solid #304266";
      btn.style.borderRadius = "4px";
      btn.style.cursor = "pointer";
      btn.addEventListener("click", () => {
        applyTerrainRoleMapping(tile, choice.key);
        hideRoleMenu();
      });
      btn.addEventListener("mouseenter", () => btn.style.background = "#24345c");
      btn.addEventListener("mouseleave", () => btn.style.background = "#1a2740");
      menu.appendChild(btn);
    });
    menu.style.left = `${x}px`;
    menu.style.top = `${y}px`;
    menu.style.display = "block";
  }
  function captureTerrainVariants() {
    const snapshot = [];
    for (let y = 0; y < mapH; y++) {
      for (let x = 0; x < mapW; x++) {
        const meta = classifyTerrainTile(x, y);
        if (meta) snapshot.push({ tx: x, ty: y, variant: meta.variant });
      }
    }
    return snapshot;
  }
  function applyTerrainRoleMapping(tileId, variantKey) {
    const snapshot = captureTerrainVariants();
    const changes = [];
    for (const cell of snapshot) {
      if (cell.variant !== variantKey) continue;
      const prevTile = getTile(cell.tx, cell.ty);
      const prevLabel = getLabel(cell.tx, cell.ty);
      if (prevTile === tileId) continue;
      setTile(cell.tx, cell.ty, tileId);
      changes.push({
        tx: cell.tx, ty: cell.ty,
        prevTile, prevLabel,
        nextTile: tileId, nextLabel: prevLabel,
      });
    }
    if (changes.length) {
      recordAction(changes);
      captureTimelapseFrame();
      pushSystemChat(`Mapped ${tileId} to ${variantKey} (${changes.length} tiles).`);
    } else {
      pushSystemChat(`No tiles matched role ${variantKey}.`);
    }
  }

  // Find spawns
  function findChar(ch) {
    for (let y = 0; y < mapH; y++) {
      for (let x = 0; x < mapW; x++) {
        if (tiles[y][x] === ch) return { x, y };
      }
    }
    return null;
  }

  const playerSpawn = findChar("P") || { x: 2, y: 2 };
  // Anchor layer 0 to the starting surface position (shifted down 5 tiles)
  layerOriginY = playerSpawn.y * TILE + 5 * TILE;

  // Replace spawns with empty
  for (let y = 0; y < mapH; y++) {
    for (let x = 0; x < mapW; x++) {
      if (tiles[y][x] === "P") tiles[y][x] = ".";
    }
  }

  // Entities
  const entities = [];
  const particles = [];
  const peers = new Map(); // peerId -> state snapshot for rendering
  const chatLog = [];
  const chatMax = 30;
  let chatVisibleTime = 0;
  let selfChatBubble = null; // {text, timer}
  async function copyToClipboard(text) {
    if (!text) return false;
    try {
      if (navigator?.clipboard?.writeText) {
        await navigator.clipboard.writeText(text);
        return true;
      }
    } catch (err) {
      // fall through to fallback
    }
    try {
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.setAttribute("readonly", "");
      ta.style.position = "fixed";
      ta.style.opacity = "0";
      document.body.appendChild(ta);
      ta.select();
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      return ok;
    } catch (err) {
      return false;
    }
  }
  let hasLocalSnapshot = false;
  function clearLevelForAuthor() {
    if (!isAuthor()) {
      pushSystemChat("Author only. Use /author to login.");
      return;
    }
    labelMap.clear();
    customTileMap.clear();
    // ensure tiles grid exists
    for (let y = 0; y < mapH; y++) {
      if (!tiles[y]) tiles[y] = new Array(mapW).fill(".");
      else tiles[y].fill(".");
    }
    // add a simple ground row so players don't fall forever
    const groundY = Math.max(0, mapH - 1);
    for (let x = 0; x < mapW; x++) {
      setTileRaw(x, groundY, "#");
    }
    // wipe entities/particles
    entities.length = 0;
    particles.length = 0;
    coinCount = 0;
    questionHits = 0;
    hasLocalSnapshot = true;
    saveLevelSnapshot();
    // reset player to start of level
    player.x = 0;
    player.y = Math.max(0, (groundY - 2) * TILE);
    player.vx = 0;
    player.vy = 0;
    updateCamera();
    pushSystemChat("Level cleared.");
  }
  const pushChatEntry = (name, text, ts = Date.now(), pin = false) => {
    if (!text) return;
    chatLog.push({ name, text, ts, seq: chatLog.length, pin });
    while (chatLog.length > chatMax) chatLog.shift();
    chatVisibleTime = pin ? 9999 : 6;
  };
  const setSelfBubble = (text) => {
    if (!text) return;
    selfChatBubble = { text: text.slice(0, 120), timer: CHAT_BUBBLE_TIME };
  };
  const setPeerBubble = (peer, text) => {
    if (!peer || !text) return;
    peer.bubble = { text: text.slice(0, 120), timer: CHAT_BUBBLE_TIME };
  };
  function pushSystemChat(text) {
    if (!text) return;
    pushChatEntry("SYSTEM", text);
  }
  const tagLayer = document.createElement("div");
  tagLayer.style.position = "fixed";
  tagLayer.style.left = "0";
  tagLayer.style.top = "0";
  tagLayer.style.width = "100%";
  tagLayer.style.height = "100%";
  tagLayer.style.pointerEvents = "none";
  tagLayer.style.zIndex = "400";
  document.body.appendChild(tagLayer);
  const chatLayer = document.createElement("div");
  chatLayer.style.position = "fixed";
  chatLayer.style.left = "0";
  chatLayer.style.top = "0";
  chatLayer.style.width = "100%";
  chatLayer.style.height = "100%";
  chatLayer.style.pointerEvents = "none";
  chatLayer.style.zIndex = "450";
  chatLayer.style.font = "12px 'Press Start 2P', 'VT323', monospace";
  const chatPanel = document.createElement("div");
  chatPanel.style.position = "absolute";
  chatPanel.style.display = "flex";
  chatPanel.style.flexDirection = "column";
  chatPanel.style.justifyContent = "flex-end";
  chatPanel.style.gap = "6px";
  chatPanel.style.pointerEvents = "none";
  chatPanel.style.boxSizing = "border-box";
  const chatLogContainer = document.createElement("div");
  chatLogContainer.style.flex = "1 1 auto";
  chatLogContainer.style.display = "flex";
  chatLogContainer.style.flexDirection = "column";
  chatLogContainer.style.justifyContent = "flex-end";
  chatLogContainer.style.gap = "6px";
  chatLogContainer.style.overflow = "hidden";
  const chatInputWrapper = document.createElement("div");
  chatInputWrapper.style.display = "none";
  chatInputWrapper.style.pointerEvents = "auto";
  chatInputWrapper.style.boxSizing = "border-box";
  chatInputWrapper.appendChild(chatInput);
  chatPanel.appendChild(chatLogContainer);
  chatPanel.appendChild(chatInputWrapper);
  chatLayer.appendChild(chatPanel);
  document.body.appendChild(chatLayer);
  let netSocket = null;
  let clientId = null;
  let reconnectTimer = 0;
  let stateSendTimer = STATE_SEND_INTERVAL;
  let audioCtx = null;

  function playSkidSound() {
    try {
      if (!audioCtx) audioCtx = new AudioContext();
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "square";
      osc.frequency.setValueAtTime(320, now);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.08);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.09);
    } catch (e) {
      // ignore audio init errors (e.g., autoplay restrictions)
    }
  }

  function playFireballSound() {
    try {
      if (!audioCtx) audioCtx = new AudioContext();
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "square";
      osc.frequency.setValueAtTime(520, now);
      gain.gain.setValueAtTime(0.06, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.2);
    } catch (e) {
      // ignore audio init errors
    }
  }

  function playTailSound() {
    try {
      if (!audioCtx) audioCtx = new AudioContext();
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(280, now);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.14);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.16);
    } catch (e) {
      // ignore audio init errors
    }
  }

  function playHammerSound() {
    try {
      if (!audioCtx) audioCtx = new AudioContext();
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "square";
      osc.frequency.setValueAtTime(340, now);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.2);
    } catch (e) {
      // ignore audio init errors
    }
  }

  function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  const mix = (a, b, t) => a + (b - a) * t;
  function isOnGround(body) {
    // Check for solid tiles just below the feet with a 1px tolerance
    const footY = body.y + body.h + 1;
    const ty = Math.floor(footY / TILE);
    const x0 = Math.floor(body.x / TILE);
    const x1 = Math.floor((body.x + body.w - 1) / TILE);
    for (let tx = x0; tx <= x1; tx++) {
      if (isSolid(getTile(tx, ty))) return true;
    }
    return false;
  }

  // -----------------------------
  // Multiplayer (client)
  // -----------------------------
  function openSocket() {
    try {
      netSocket = new WebSocket(MP_SERVER);
    } catch (err) {
      netSocket = null;
      reconnectTimer = 1.5;
      return;
    }

    netSocket.addEventListener("open", () => {
      stateSendTimer = STATE_SEND_INTERVAL;
      netSocket.send(JSON.stringify({ type: "join", room: MP_ROOM, name: PLAYER_NAME }));
    });

    netSocket.addEventListener("message", (ev) => handleNetMessage(ev.data));

    const handleClose = () => {
      clientId = null;
      netSocket = null;
      reconnectTimer = 1.5;
    };
    netSocket.addEventListener("close", handleClose);
    netSocket.addEventListener("error", handleClose);
  }

  function handleNetMessage(raw) {
    let msg;
    try {
      msg = JSON.parse(raw);
    } catch (e) {
      return;
    }
    const ignoreRemoteTiles = hasLocalSnapshot; // always accept remote tiles/labels in endless to keep peers in sync
    if (msg.type === "welcome") {
      clientId = msg.id || null;
      if (Array.isArray(msg.players)) {
        for (const p of msg.players) {
          recordPeerState(p.id, p, p.name);
        }
      }
      if (Array.isArray(msg.tiles) && !ignoreRemoteTiles) {
        for (const t of msg.tiles) {
          if (typeof t.tx === "number" && typeof t.ty === "number") {
            setTile(t.tx, t.ty, t.value ?? ".");
          }
        }
      }
      if (Array.isArray(msg.labels) && !ignoreRemoteTiles) {
        for (const t of msg.labels) {
          if (typeof t.tx === "number" && typeof t.ty === "number") {
            setLabel(t.tx, t.ty, t.label ?? "");
          }
        }
      }
      return;
    }
    if (msg.type === "state" && msg.id && msg.state) {
      recordPeerState(msg.id, msg.state, msg.name);
      return;
    }
    if (msg.type === "chat" && typeof msg.text === "string") {
      const isSelf = (msg.id && msg.id === clientId) || (!msg.id && msg.name === PLAYER_NAME);
      if (!isSelf) pushChatEntry(msg.name || "Player", msg.text, msg.ts || Date.now(), !!msg.pin);
      const bubbleText = msg.text;
      if (isSelf) {
        setSelfBubble(bubbleText);
      } else {
        let target = null;
        if (msg.id && peers.has(msg.id)) target = peers.get(msg.id);
        else {
          for (const peer of peers.values()) {
            if (peer.name === msg.name) { target = peer; break; }
          }
        }
        if (target) setPeerBubble(target, bubbleText);
      }
      return;
    }
    if (msg.type === "leave" && msg.id) {
      peers.delete(msg.id);
      return;
    }
    if (msg.type === "tile" && typeof msg.tx === "number" && typeof msg.ty === "number") {
      if (ignoreRemoteTiles) return;
      setTile(msg.tx, msg.ty, msg.value ?? ".");
    }
    if (msg.type === "edit" && typeof msg.tx === "number" && typeof msg.ty === "number") {
      if (ignoreRemoteTiles) return;
      if (msg.value !== undefined) setTile(msg.tx, msg.ty, msg.value ?? ".");
      if (msg.label !== undefined) setLabel(msg.tx, msg.ty, msg.label ?? "");
    }
  }

  function recordPeerState(id, state, name) {
    if (!id || id === clientId) return;
    const now = performance.now();
    const incomingForm = isValidForm(state.form) ? state.form : null;
    const incomingBig = incomingForm ? formIsBig(incomingForm) : !!state.big;
    const incomingCoins = Number.isFinite(state.coins) ? state.coins : 0;
    const incomingScore = Number.isFinite(state.score) ? state.score : 0;
    const incomingLives = Number.isFinite(state.lives) ? state.lives : 3;
    const incomingTimer = Number.isFinite(state.timer) ? state.timer : HUD_TIMER_START;
    let peer = peers.get(id);
    if (!peer) {
      peer = {
        x: state.x ?? 0,
        y: state.y ?? 0,
        targetX: state.x ?? 0,
        targetY: state.y ?? 0,
        facing: state.facing || 1,
        form: incomingForm ?? (incomingBig ? PowerUpForm.Super : PowerUpForm.Small),
        big: incomingBig,
        name: name || `P-${String(id).slice(0, 4)}`,
        state: state.state || "ground",
        coins: incomingCoins,
        score: incomingScore,
        lives: incomingLives,
        timer: incomingTimer,
        lastSeen: now,
      };
      peers.set(id, peer);
    } else {
      peer.targetX = state.x ?? peer.targetX;
      peer.targetY = state.y ?? peer.targetY;
      peer.facing = state.facing || peer.facing || 1;
      if (incomingForm) peer.form = incomingForm;
      if (!peer.form) peer.form = incomingBig ? PowerUpForm.Super : PowerUpForm.Small;
      peer.big = incomingForm ? formIsBig(incomingForm) : (incomingBig || peer.big);
      peer.state = state.state || peer.state || "ground";
      if (name) peer.name = name;
      peer.coins = incomingCoins;
      peer.score = incomingScore;
      peer.lives = incomingLives;
      peer.timer = incomingTimer;
      peer.lastSeen = now;
    }
    if (peer.x === undefined) peer.x = peer.targetX;
    if (peer.y === undefined) peer.y = peer.targetY;
  }

  function broadcastEditChange(tx, ty, value, label) {
    if (!MP_ENABLED || !netSocket || netSocket.readyState !== WebSocket.OPEN) return;
    const msg = { type: "edit", room: MP_ROOM, tx, ty };
    if (value !== undefined) msg.value = value;
    if (label !== undefined) msg.label = label;
    netSocket.send(JSON.stringify(msg));
  }

  function sendPlayerState() {
    if (!MP_ENABLED || !netSocket || netSocket.readyState !== WebSocket.OPEN) return;
    const payload = {
      type: "state",
      room: MP_ROOM,
      name: PLAYER_NAME,
      state: {
        x: player.x,
        y: player.y,
        vx: player.vx,
        vy: player.vy,
        facing: player.facing,
        big: player.big,
        form: player.form,
        state: player.state,
        coins: coinCount,
        score: score,
        lives: lives,
        timer: levelTimer,
      },
    };
    netSocket.send(JSON.stringify(payload));
  }

  function sendChat(text, options = {}) {
    const { pin = false } = options;
    if (!MP_ENABLED || !netSocket || netSocket.readyState !== WebSocket.OPEN) return;
    if (!text || !text.trim()) return;
    const trimmed = text.trim().slice(0, 200);
    const ts = Date.now();
    pushChatEntry(PLAYER_NAME, trimmed, ts, pin);
    setSelfBubble(trimmed);
    netSocket.send(JSON.stringify({ type: "chat", room: MP_ROOM, name: PLAYER_NAME, text: trimmed, ts, id: clientId, pin }));
  }

  function smoothPeers(dt) {
    for (const peer of peers.values()) {
      if (peer.targetX === undefined || peer.targetY === undefined) continue;
      const lerp = Math.min(1, dt * 10);
      peer.x = peer.x + (peer.targetX - peer.x) * lerp;
      peer.y = peer.y + (peer.targetY - peer.y) * lerp;
    }
  }

  function updateNetwork(dt) {
    if (!MP_ENABLED) return;
    if (!netSocket) {
      if (reconnectTimer > 0) reconnectTimer -= dt;
      if (reconnectTimer <= 0) openSocket();
      return;
    }
    if (netSocket.readyState === WebSocket.OPEN) {
      stateSendTimer -= dt;
      if (stateSendTimer <= 0) {
        stateSendTimer = STATE_SEND_INTERVAL;
        sendPlayerState();
      }
    }
    const now = performance.now();
    for (const [id, peer] of peers.entries()) {
      if (now - peer.lastSeen > PEER_STALE_TIME * 1000) peers.delete(id);
    }
    smoothPeers(dt);
  }

  // -----------------------------
  // Tile collision
  // -----------------------------
  function moveAndCollide(body, dt) {
    // body: {x,y,w,h,vx,vy,onGround,hitHead}
    body.onGround = false;
    body.hitHead = false;

    // Horizontal
    body.x += body.vx * dt;
    if (body.vx !== 0) {
      const dir = Math.sign(body.vx);
      const aheadX = dir > 0 ? body.x + body.w : body.x;
      const tx = Math.floor(aheadX / TILE);

      const y0 = Math.floor(body.y / TILE);
      const y1 = Math.floor((body.y + body.h - 1) / TILE);

      for (let ty = y0; ty <= y1; ty++) {
        const t = getTile(tx, ty);
        if (isSolid(t)) {
          if (dir > 0) body.x = tx * TILE - body.w;
          else body.x = (tx + 1) * TILE;
          body.vx = 0;
          break;
        }
      }
    }

    // Vertical
    body.y += body.vy * dt;
    if (body.vy !== 0) {
      const dir = Math.sign(body.vy);

      const ty = Math.floor((dir > 0 ? (body.y + body.h) : body.y) / TILE);
      const x0 = Math.floor(body.x / TILE);
      const x1 = Math.floor((body.x + body.w - 1) / TILE);

      for (let tx = x0; tx <= x1; tx++) {
        const t = getTile(tx, ty);
        if (isSolid(t)) {
          if (dir > 0) {
            body.y = ty * TILE - body.h;
            body.onGround = true;
          } else {
            const brokeBrick = t === "B" && canBreakBricks();
            if (brokeBrick) {
              breakBrick(tx, ty);
            } else if (isQuestion(t)) {
              bumpQuestionBlock(tx, ty);
            }
            body.y = (ty + 1) * TILE;
            body.hitHead = true;
          }
          body.vy = 0;
          break;
        }
      }
    }
  }

  // -----------------------------
  // Game logic: blocks / pickups
  // -----------------------------
  let coinCount = 0;
  let score = 0;
  let lives = 3;
  let levelTimer = HUD_TIMER_START;

  function spawnCoinBurst(x, y) {
    for (let i = 0; i < 8; i++) {
      particles.push({
        x, y,
        vx: (Math.random() * 2 - 1) * 120,
        vy: -(Math.random() * 220 + 100),
        life: 0.5 + Math.random() * 0.25,
      });
    }
  }

  function spawnSkidDust(x, y, dir) {
    for (let i = 0; i < 3; i++) {
      particles.push({
        x: x + (Math.random() * 4 - 2),
        y: y + (Math.random() * 2 - 1),
        vx: (Math.random() * 50 + 60) * dir * -1,
        vy: -(Math.random() * 70 + 30),
        life: 0.25 + Math.random() * 0.12,
        color: "#d8d8d8",
        size: 2
      });
    }
  }

  function spawnMushroom(px, py) {
    entities.push({
      type: "mushroom",
      x: px, y: py,
      w: 14, h: 14,
      vx: 70, vy: 0,
      alive: true,
    });
  }

  function spawnFireball() {
    const dir = player.facing >= 0 ? 1 : -1;
    const startX = player.x + (dir > 0 ? player.w : -6);
    const startY = player.y + 6;
    entities.push({
      type: "fireball",
      x: startX,
      y: startY,
      w: 6,
      h: 6,
      vx: FIREBALL_SPEED * dir,
      vy: -60,
      alive: true,
      life: FIREBALL_LIFETIME,
      bounces: 0,
      spinDir: dir,
      magnus: FIREBALL_MAGNUS,
    });
    player.fireCooldown = FIREBALL_COOLDOWN;
    playFireballSound();
  }

  function performTailAttack() {
    const dir = player.facing >= 0 ? 1 : -1;
    const hitbox = {
      x: player.x + (dir > 0 ? player.w : -TAIL_RANGE_X),
      y: player.y + (player.h - TAIL_RANGE_Y - 4),
      w: TAIL_RANGE_X,
      h: TAIL_RANGE_Y,
    };
    for (const target of entities) {
      if (!target.alive || target.type !== "goon") continue;
      if (aabb(hitbox.x, hitbox.y, hitbox.w, hitbox.h, target.x, target.y, target.w, target.h)) {
        target.alive = false;
        spawnCoinBurst(target.x + target.w / 2, target.y + target.h / 2);
      }
    }
    playTailSound();
  }

  function countHammers() {
    return entities.filter((e) => e.alive && e.type === "hammer").length;
  }

  function spawnHammer(charge = 0) {
    if (countHammers() >= 2) return;
    const dir = player.facing >= 0 ? 1 : -1;
    const t = clamp(charge, 0, 1);
    const launchAngle = mix(HAMMER_MIN_ANGLE, HAMMER_MAX_ANGLE, t);
    const launchSpeed = mix(HAMMER_MIN_SPEED, HAMMER_MAX_SPEED, t);
    const vx = Math.cos(launchAngle) * launchSpeed * dir;
    const vy = -Math.sin(launchAngle) * launchSpeed;
    const startX = player.x + (dir > 0 ? player.w : -6);
    const startY = player.y + 4;
    entities.push({
      type: "hammer",
      x: startX,
      y: startY,
      w: 6,
      h: 6,
      vx,
      vy,
      alive: true,
      life: HAMMER_LIFETIME,
      spin: 0,
      spinDir: dir,
      magnus: HAMMER_MAGNUS,
    });
    player.hammerCooldown = HAMMER_COOLDOWN;
    playHammerSound();
  }

  function startStatue() {
    player.statueActive = true;
    player.statueTimer = STATUE_DURATION;
    player.statueCooldown = STATUE_COOLDOWN;
    player.vx = 0;
    player.ax = 0;
    player.pCharge = 0;
    playTailSound();
  }

  // Alternate between coin and mushroom spawns (simple demo)
  let questionHits = 0;

  function bumpQuestionBlock(tx, ty) {
    setTile(tx, ty, "u");
    broadcastEditChange(tx, ty, "u");
    questionHits++;
    const cx = tx * TILE + TILE/2;
    const cy = ty * TILE;

    if (questionHits % 2 === 1) {
      coinCount++;
      score += 200;
      spawnCoinBurst(cx, cy);
    } else {
      spawnMushroom(tx * TILE + 1, ty * TILE - 14);
    }
  }

  function breakBrick(tx, ty) {
    setTile(tx, ty, ".");
    broadcastEditChange(tx, ty, ".");
    const cx = tx * TILE + TILE / 2;
    const cy = ty * TILE + TILE / 2;
    for (let i = 0; i < 6; i++) {
      particles.push({
        x: cx,
        y: cy,
        vx: (Math.random() * 2 - 1) * 160,
        vy: -(Math.random() * 200 + 80),
        life: 0.35 + Math.random() * 0.2,
        color: "#b46a3a",
        size: 2 + Math.floor(Math.random() * 2),
      });
    }
  }

  function breakIce(tx, ty) {
    setTile(tx, ty, ".");
    broadcastEditChange(tx, ty, ".");
    const cx = tx * TILE + TILE / 2;
    const cy = ty * TILE + TILE / 2;
    for (let i = 0; i < 4; i++) {
      particles.push({
        x: cx,
        y: cy,
        vx: (Math.random() * 2 - 1) * 120,
        vy: -(Math.random() * 140 + 60),
        life: 0.35 + Math.random() * 0.2,
        color: "#b0e0ff",
        size: 2,
      });
    }
  }

  function breakDestructible(tx, ty) {
    const t = getTile(tx, ty);
    if (t === "B") return breakBrick(tx, ty);
    if (t === "I") return breakIce(tx, ty);
  }

  function collectCoinTileAtPlayer(player) {
    // check tiles overlapped by player for 'C'
    const x0 = Math.floor(player.x / TILE);
    const x1 = Math.floor((player.x + player.w - 1) / TILE);
    const y0 = Math.floor(player.y / TILE);
    const y1 = Math.floor((player.y + player.h - 1) / TILE);

      for (let ty = y0; ty <= y1; ty++) {
        for (let tx = x0; tx <= x1; tx++) {
          if (getTile(tx, ty) === "C") {
            setTile(tx, ty, ".");
            broadcastEditChange(tx, ty, ".");
            coinCount++;
            score += 100;
            spawnCoinBurst(tx*TILE + TILE/2, ty*TILE + TILE/2);
          }
        }
    }
  }

  // -----------------------------
  // Player
  // -----------------------------
  const player = {
    type: "player",
    x: playerSpawn.x * TILE,
    y: playerSpawn.y * TILE,
    w: 12,
    h: 14,
    vx: 0,
    vy: 0,
    facing: 1,
    onGround: false,
    hitHead: false,
    state: "ground",
    coyote: 0,
    jumpBuf: 0,
    form: PowerUpForm.Small,
    big: formIsBig(PowerUpForm.Small),
    invuln: 0,
    ax: 0,
    onLadder: false,
    pCharge: 0,
    skidTimer: 0,
    skidDust: 0,
    skidBoost: 0,
    airCarryMax: 0,
    fireCooldown: 0,
    hammerCooldown: 0,
    tailTimer: 0,
    tailCooldown: 0,
    flightTimer: 0,
    flightActive: false,
    statueActive: false,
    statueTimer: 0,
    statueCooldown: 0,
    hammerCharge: 0,
    hammerCharging: false,
  };
  let powerFormStats = new Map(); // form -> { maxDistance, enterDistance }
  let currentFormEntryDist = 0;
  let lastForm = player.form;
  let pMeterDisplaySegs = 0;
  let pMeterDecayHold = 0;
  const debugVxEl = document.getElementById("debug-vx");
  const debugAxEl = document.getElementById("debug-ax");
  const debugPChargeEl = document.getElementById("debug-pcharge");
  const debugPSegsEl = document.getElementById("debug-psegs");
  const debugPMaxEl = document.getElementById("debug-pmax");
  if (debugPMaxEl) debugPMaxEl.textContent = P_METER_SEGMENTS;

  function isValidForm(form) {
    return Object.values(PowerUpForm).includes(form);
  }

  function formIsBig(form) {
    return BIG_FORMS.has(form);
  }

  function formPalette(form) {
    switch (form) {
      case PowerUpForm.Fire:
        return { shirt: "#ff6b35", pants: "#ffd166" };
      case PowerUpForm.Raccoon:
        return { shirt: "#d66f4a", pants: "#7f5539" };
      case PowerUpForm.Tanooki:
        return { shirt: "#a97155", pants: "#5b4636" };
      case PowerUpForm.Frog:
        return { shirt: "#2dd36f", pants: "#0a8a4a" };
      case PowerUpForm.Hammer:
        return { shirt: "#5d78ff", pants: "#2d3142" };
      case PowerUpForm.Jetpack:
        return { shirt: "#ff9f1c", pants: "#1b9aaa" };
      case PowerUpForm.Super:
        return { shirt: "#e23b2e", pants: "#2a49ff" };
      default:
        return { shirt: "#e23b2e", pants: "#2a49ff" };
    }
  }

  function setPlayerForm(form, options = {}) {
    const { skipSave = false } = options;
    const nextForm = isValidForm(form) ? form : PowerUpForm.Small;
    const willBeBig = formIsBig(nextForm);
    player.form = nextForm;
    player.big = willBeBig;
    // adjust hitbox height; keep feet position stable when size changes
    const oldH = player.h;
    player.h = willBeBig ? 22 : 14;
    player.y += (oldH - player.h);
    if (!skipSave) savePlayerSnapshot();
  }

  let autoSaveCooldown = 0;

  function serializePlayerSnapshot() {
    return {
      form: player.form,
      levelTimer,
      invuln: player.invuln,
      fireCooldown: player.fireCooldown,
      hammerCooldown: player.hammerCooldown,
      tailCooldown: player.tailCooldown,
      flightTimer: player.flightTimer,
      flightActive: player.flightActive,
      statueActive: player.statueActive,
      statueTimer: player.statueTimer,
      statueCooldown: player.statueCooldown,
    };
  }

  function savePlayerSnapshot() {
    if (typeof localStorage === "undefined") return;
    try {
      localStorage.setItem(PLAYER_SAVE_KEY, JSON.stringify(serializePlayerSnapshot()));
    } catch (err) {
      // ignore persistence failures (e.g., storage disabled)
    }
  }

  function loadPlayerSnapshot() {
    if (typeof localStorage === "undefined") return false;
    const raw = localStorage.getItem(PLAYER_SAVE_KEY);
    if (!raw) return false;
    try {
      const data = JSON.parse(raw);
      if (isValidForm(data.form)) {
        setPlayerForm(data.form, { skipSave: true });
      }
      if (typeof data.levelTimer === "number") {
        levelTimer = clamp(data.levelTimer, 0, HUD_TIMER_START);
      }
      if (typeof data.invuln === "number") {
        player.invuln = clamp(data.invuln, 0, DAMAGE_INVULN_TIME);
      }
      if (typeof data.fireCooldown === "number") {
        player.fireCooldown = clamp(data.fireCooldown, 0, FIREBALL_COOLDOWN);
      }
      if (typeof data.hammerCooldown === "number") {
        player.hammerCooldown = clamp(data.hammerCooldown, 0, HAMMER_COOLDOWN);
      }
      if (typeof data.tailCooldown === "number") {
        player.tailCooldown = clamp(data.tailCooldown, 0, TAIL_COOLDOWN);
      }
      if (typeof data.flightTimer === "number") {
        const maxFlight = player.form === PowerUpForm.Jetpack ? JETPACK_FUEL_TIME : FLIGHT_TIME;
        player.flightTimer = clamp(data.flightTimer, 0, maxFlight);
      }
      if (typeof data.flightActive === "boolean") {
        player.flightActive = data.flightActive;
      }
      if (typeof data.statueActive === "boolean") {
        player.statueActive = data.statueActive;
      }
      if (typeof data.statueTimer === "number") {
        player.statueTimer = clamp(data.statueTimer, 0, STATUE_DURATION);
      }
      if (typeof data.statueCooldown === "number") {
        player.statueCooldown = clamp(data.statueCooldown, 0, STATUE_COOLDOWN);
      }
      return true;
    } catch (err) {
      return false;
    }
  }

  function maybeAutoSave(dt) {
    autoSaveCooldown = Math.max(0, autoSaveCooldown - dt);
    if (autoSaveCooldown > 0) return;
    savePlayerSnapshot();
    autoSaveCooldown = 1.0;
  }

  function downgradeForm(form) {
    if (form === PowerUpForm.Small) return null;
    if (form === PowerUpForm.Super) return PowerUpForm.Small;
    return PowerUpForm.Super;
  }

  function canBreakBricks() {
    return formIsBig(player.form);
  }

  function canShootFire() {
    return player.form === PowerUpForm.Fire;
  }

  function hasTailAbilities() {
    return player.form === PowerUpForm.Raccoon || player.form === PowerUpForm.Tanooki;
  }

  function getSurfaceModifier(body) {
    if (!body.onGround) return { accel: 1, friction: 1, brake: 1 };
    const footY = body.y + body.h + 0.5;
    const tx = Math.floor((body.x + body.w / 2) / TILE);
    const ty = Math.floor(footY / TILE);
    const type = surfaceType(getTile(tx, ty));
    return type ? SURFACE_MODS[type] : { accel: 1, friction: 1, brake: 1 };
  }

  function isPlayerSwimming() {
    const tx = Math.floor((player.x + player.w / 2) / TILE);
    const ty = Math.floor((player.y + player.h - 2) / TILE);
    return isWaterTile(getTile(tx, ty));
  }

  // -----------------------------
  // Enemies
  // -----------------------------
  function spawnEnemy(tx, ty) {
    entities.push({
      type: "goon",
      x: tx * TILE + 1,
      y: ty * TILE,
      w: 14,
      h: 14,
      vx: -50,
      vy: 0,
      alive: true,
    });
  }

  // Create enemies from map
  for (let y = 0; y < mapH; y++) {
    for (let x = 0; x < mapW; x++) {
      if (tiles[y][x] === "E") {
        tiles[y][x] = ".";
        spawnEnemy(x, y);
      }
    }
  }

  // -----------------------------
  // Camera
  // -----------------------------
  const cam = { x: 0, y: 0 };
  let worldWpx = mapW * TILE;
  let worldHpx = mapH * TILE;

  function updateWorldWidth() {
    worldWpx = mapW * TILE;
    worldHpx = mapH * TILE;
  }

  function updateCamera() {
    const targetX = player.x + player.w/2 - BASE_W/2;
    cam.x = clamp(targetX, 0, Math.max(0, worldWpx - BASE_W));

    const maxCamY = Math.max(0, worldHpx - BASE_H);
    const targetY = player.y + player.h / 2;
    const snappedY = clamp(Math.floor(targetY / CAMERA_SEGMENT_PX) * CAMERA_SEGMENT_PX, 0, maxCamY);
    cam.y = snappedY;
  }

  // -----------------------------
  // Game state
  // -----------------------------
  let deadTimer = 0;
  function restart() {
    // reset tiles to initial
    tiles.length = 0;
    for (const row of LEVEL) tiles.push(row.split(""));
    mapH = tiles.length;
    mapW = tiles[0]?.length || 0;
    defaultGroundY = Math.max(4, mapH - 2);
    updateWorldWidth();
    resetDifficultyState();
    resetWorldBuffer();
    // wipe spawns
    for (let y = 0; y < mapH; y++) for (let x = 0; x < mapW; x++) if (tiles[y][x] === "P") tiles[y][x] = ".";
    // reset coins and blocks
    coinCount = 0;
    questionHits = 0;
    entities.length = 0;
    particles.length = 0;

    // respawn enemies from template
    for (let y = 0; y < mapH; y++) {
      for (let x = 0; x < mapW; x++) {
        if (tiles[y][x] === "E") {
          tiles[y][x] = ".";
          spawnEnemy(x, y);
        }
      }
    }

    player.x = playerSpawn.x * TILE;
    player.y = playerSpawn.y * TILE;
    player.vx = 0; player.vy = 0;
    player.invuln = 0;
    player.coyote = 0;
    player.jumpBuf = 0;
    player.ax = 0;
    player.pCharge = 0;
    player.skidTimer = 0;
    player.skidDust = 0;
    player.skidBoost = 0;
    player.airCarryMax = 0;
    player.fireCooldown = 0;
    player.hammerCooldown = 0;
    player.tailTimer = 0;
    player.tailCooldown = 0;
    player.flightTimer = 0;
    player.flightActive = false;
    player.hammerCooldown = 0;
    player.statueActive = false;
    player.statueTimer = 0;
    player.statueCooldown = 0;
    player.onLadder = false;
    pMeterDisplaySegs = 0;
    pMeterDecayHold = 0;
    setPlayerForm(PowerUpForm.Small, { skipSave: true });
    deadTimer = 0;
    // also clear transient inputs so we don't instantly re-trigger actions
    pressed.clear();
    keys.clear();
    levelTimer = HUD_TIMER_START;
    loadPlayerSnapshot();
    savePlayerSnapshot();
  }

  if (levelSaveButton) {
    levelSaveButton.addEventListener("click", () => {
      const ok = saveLevelSnapshot();
      pushSystemChat(ok ? "Level saved." : "Level save failed.");
    });
  }
  if (levelResetButton) {
    levelResetButton.addEventListener("click", () => {
      const loaded = loadLevelSnapshot();
      pushSystemChat(loaded ? "Level reset to saved state." : "No saved level found.");
    });
  }

  function killPlayer() {
    deadTimer = 0.8;
    player.vx = 0;
    player.vy = -420;
    setPlayerForm(PowerUpForm.Small);
    player.invuln = 0;
    player.fireCooldown = 0;
    player.hammerCooldown = 0;
    player.tailTimer = 0;
    player.tailCooldown = 0;
    player.flightTimer = 0;
    player.flightActive = false;
    player.hammerCooldown = 0;
    player.statueActive = false;
    player.statueTimer = 0;
    player.statueCooldown = 0;
    player.onLadder = false;
    levelTimer = HUD_TIMER_START;
    savePlayerSnapshot();
    if (ENDLESS_ENABLED) {
      const deathTx = player.x / TILE;
      console.info("[ENDLESS] death", {
        seed: worldRng.seed,
        tx: Number.isFinite(deathTx) ? +deathTx.toFixed(2) : deathTx,
        distance: difficultyState.distance,
        speed: difficultyState.speed,
      });
    }
  }

  function handlePlayerHit() {
    if (player.invuln > 0 || deadTimer > 0) return;
    const nextForm = downgradeForm(player.form);
    if (!nextForm) {
      killPlayer();
      return;
    }
    setPlayerForm(nextForm);
    player.invuln = DAMAGE_INVULN_TIME;
    player.vx = -player.facing * 120;
    player.vy = -240;
  }

  // first load: replace initial P in template (already done), but keep everything else
  // NOTE: coins in map are collected as tiles
  // We'll initialize coinCount by counting coins on map (optional). We'll keep it 0 and treat them as pickups.

  // -----------------------------
  // Physics helper for entities
  // -----------------------------
  function entityMoveAndCollide(e, dt) {
    e.onGround = false;

    // Horizontal
    e.x += e.vx * dt;
    if (e.vx !== 0) {
      const dir = Math.sign(e.vx);
      const aheadX = dir > 0 ? e.x + e.w : e.x;
      const tx = Math.floor(aheadX / TILE);

      const y0 = Math.floor(e.y / TILE);
      const y1 = Math.floor((e.y + e.h - 1) / TILE);

      for (let ty = y0; ty <= y1; ty++) {
        const t = getTile(tx, ty);
        if (isSolid(t)) {
          if (dir > 0) e.x = tx * TILE - e.w;
          else e.x = (tx + 1) * TILE;
          e.vx = -e.vx; // bounce back
          break;
        }
      }
    }

    // Vertical
    e.y += e.vy * dt;
    if (e.vy !== 0) {
      const dir = Math.sign(e.vy);
      const ty = Math.floor((dir > 0 ? (e.y + e.h) : e.y) / TILE);

      const x0 = Math.floor(e.x / TILE);
      const x1 = Math.floor((e.x + e.w - 1) / TILE);

      for (let tx = x0; tx <= x1; tx++) {
        const t = getTile(tx, ty);
        if (isSolid(t)) {
          if (dir > 0) {
            e.y = ty * TILE - e.h;
            e.onGround = true;
          } else {
            e.y = (ty + 1) * TILE;
          }
          e.vy = 0;
          break;
        }
      }
    }
  }

  // Applies a simple Magnus force so spinning projectiles curve
  function applyMagnusForce(e, dt) {
    if (!e.magnus || !e.spinDir) return;
    const lift = e.magnus * e.spinDir;
    const ax = e.vy * lift;
    const ay = -e.vx * lift;
    e.vx += ax * dt;
    e.vy += ay * dt;
  }

  // -----------------------------
  // Update
  // -----------------------------
  let last = performance.now();
  let acc = 0;
  const FIXED = 1/120;

  function step(dt) {
    // Restart key
    if (tap("KeyR")) restart();

    // Death / respawn pause
    if (deadTimer > 0) {
      deadTimer -= dt;
      if (deadTimer <= 0) restart();
      return;
    }

    updateEndlessWorld(dt);

    const jetpackEquipped = player.form === PowerUpForm.Jetpack;

    // Update invuln
    player.invuln = Math.max(0, player.invuln - dt);
    player.tailTimer = Math.max(0, player.tailTimer - dt);
    player.tailCooldown = Math.max(0, player.tailCooldown - dt);
    player.flightTimer = jetpackEquipped ? JETPACK_FUEL_TIME : Math.max(0, player.flightTimer - dt);
    player.statueTimer = Math.max(0, player.statueTimer - dt);
    player.statueCooldown = Math.max(0, player.statueCooldown - dt);

    // Jump buffer: remember a tap briefly to fire on next grounded frame
    if (tap("KeyZ")) player.jumpBuf = JUMP_BUFFER;
    else player.jumpBuf = Math.max(0, player.jumpBuf - dt);
    player.fireCooldown = Math.max(0, player.fireCooldown - dt);
    player.hammerCooldown = Math.max(0, player.hammerCooldown - dt);

    const prevVx = player.vx;
    const wasGrounded = player.onGround;
    const prevFeet = player.y + player.h;

    // Move input
    const left = down("ArrowLeft");
    const right = down("ArrowRight");
    const run = down("KeyX");
    const hammerTap = tap("KeyC");
    const hammerHeld = down("KeyC");
    const tailSwing = hammerTap;
    const statueToggle = tap("KeyV");
    const onLadder = isBodyOnLadder(player);
    const surfaceMod = player.onGround ? getSurfaceModifier(player) : { accel: 1, friction: 1, brake: 1 };
    const ladderUp = onLadder && down("ArrowUp");
    const ladderDown = onLadder && down("ArrowDown");

    // Tanooki statue toggle
    if (hasTailAbilities() && player.form === PowerUpForm.Tanooki) {
      if (statueToggle && player.statueCooldown <= 0 && !player.statueActive) {
        startStatue();
      }
      if (player.statueActive) {
        if (player.statueTimer <= 0) {
          player.statueActive = false;
        } else {
          player.invuln = Math.max(player.invuln, STATUE_INVULN_TOPUP);
        }
      }
    } else {
      player.statueActive = false;
      player.statueTimer = 0;
    }

    player.onLadder = onLadder;

    const moveLeft = player.statueActive ? false : left;
    const moveRight = player.statueActive ? false : right;
    const runHeld = player.statueActive ? false : run;
    const accelCurve = runHeld ? RUN_ACCEL_CURVE : WALK_ACCEL_CURVE;
    const wantsRun = runHeld && (moveLeft !== moveRight);
    const hasPSpeed = player.pCharge >= 1;
    const boostMult = 1 + player.skidBoost;
    const baseMax = runHeld ? (hasPSpeed ? P_SPEED_MAX : RUN_MAX) : WALK_MAX;
    const maxSpeed = baseMax * boostMult;
    const speedRatio = clamp(Math.abs(player.vx) / Math.max(1, maxSpeed), 0, 1);
    const accel = mix(accelCurve.high, accelCurve.low, speedRatio);

    const wantDir = (moveLeft ? -1 : 0) + (moveRight ? 1 : 0);
    const vxSign = Math.sign(player.vx);
    // Use previous-frame velocity to decide skid, so friction this frame doesn't block the trigger
    const prevVxSign = Math.sign(prevVx);
    const reversing = player.onGround && wantDir !== 0 && prevVxSign !== 0 && wantDir === -prevVxSign && Math.abs(prevVx) > SKID_SPEED_THRESHOLD;

    // Trigger skid when reversing at speed on ground
    if (reversing && player.skidTimer <= 0) {
      player.skidTimer = SKID_TIME;
      player.skidDust = 0;
      player.skidBoost = Math.max(player.skidBoost, SKID_BOOST_AMOUNT);
      playSkidSound();
      spawnSkidDust(player.x + (player.facing > 0 ? player.w : 0), player.y + player.h, player.facing);
    }

    const isSkidding = player.skidTimer > 0 && player.onGround;
    if (player.skidTimer > 0) player.skidTimer = Math.max(0, player.skidTimer - dt);
    const accelScale = player.onGround ? (isSkidding ? SKID_ACCEL_SCALE : 1) : AIR_ACCEL_SCALE;
    const frogLandAccelScale = player.form === PowerUpForm.Frog && player.onGround ? FROG_LAND_ACCEL_SCALE : 1;
    const frogLandDecelScale = player.form === PowerUpForm.Frog && player.onGround ? FROG_LAND_DECEL_SCALE : 1;

    if (player.statueActive) {
      player.vx = 0;
    } else if (wantDir === 0) {
      // friction
      const mag = Math.abs(player.vx);
      const groundFriction = (isSkidding ? SKID_FRICTION_DECEL : FRICTION_DECEL) * frogLandDecelScale;
      const dec = (player.onGround ? groundFriction * surfaceMod.friction : AIR_FRICTION_DECEL) * dt;
      player.vx = (mag <= dec) ? 0 : (mag - dec) * vxSign;
    } else if (wantDir !== vxSign && player.vx !== 0) {
      // braking when reversing direction
      const mag = Math.abs(player.vx);
      const groundBrake = (isSkidding ? SKID_BRAKE_DECEL : BRAKE_DECEL) * frogLandDecelScale;
      const dec = (player.onGround ? groundBrake * surfaceMod.brake : AIR_BRAKE_DECEL) * dt;
      player.vx = (mag <= dec) ? 0 : (mag - dec) * vxSign;
    } else {
      // accelerate in desired direction
      player.vx += accel * accelScale * surfaceMod.accel * frogLandAccelScale * dt * wantDir;
      player.facing = wantDir;
    }

    player.vx = clamp(player.vx, -maxSpeed, maxSpeed);

    // Gravity (with glide/flight/ladder/jetpack modifiers)
    let gravity = GRAVITY;
    if (player.statueActive) {
      player.flightActive = false;
      player.flightTimer = 0;
    }
    const swimming = isPlayerSwimming();
    const onLadderNow = onLadder && !player.statueActive;
    const jetpackThrusting = jetpackEquipped && !swimming && !onLadderNow && down("KeyZ");
    const gliding = !swimming && !onLadderNow && hasTailAbilities() && player.vy > 40 && down("KeyZ") && !player.flightActive;
    if (gliding) gravity *= GLIDE_GRAVITY_SCALE;
    if (jetpackEquipped) gravity *= JETPACK_GRAVITY_SCALE;
    if (swimming) {
      gravity *= WATER_GRAVITY_SCALE;
    }
    if (onLadderNow) {
      gravity = 0;
      player.flightActive = false;
      player.flightTimer = 0;
      const climbV = ladderUp ? -LADDER_CLIMB_SPEED : (ladderDown ? LADDER_CLIMB_SPEED : 0);
      player.vy = climbV;
    } else if (jetpackThrusting) {
      // Infinite-fuel jetpack lift
      const targetVy = -JETPACK_THRUST;
      player.vy = Math.min(player.vy, targetVy);
      player.flightActive = true;
      player.flightTimer = JETPACK_FUEL_TIME;
    } else if (!swimming && player.flightActive && player.flightTimer > 0 && down("KeyZ")) {
      // keep upward lift while flight lasts
      player.vy = Math.min(player.vy, -FLIGHT_LIFT);
      player.flightTimer = Math.max(0, player.flightTimer - dt);
      if (player.flightTimer <= 0) player.flightActive = false;
    } else if (!jetpackEquipped && player.flightActive && player.flightTimer <= 0) {
      player.flightActive = false;
    } else if (!jetpackThrusting && jetpackEquipped) {
      player.flightActive = false;
    }
    player.vy += gravity * dt;
    const maxFall = swimming ? WATER_MAX_FALL : (jetpackEquipped ? JETPACK_MAX_FALL : MAX_FALL);
    player.vy = Math.min(player.vy, maxFall);

    // Collide
    moveAndCollide(player, dt);

    if (onLadderNow) {
      player.onGround = true;
      player.coyote = COYOTE_TIME;
    }

    // Track actual acceleration (accounts for collisions and friction)
    player.ax = (player.vx - prevVx) / dt;

    // Grounded tracking and state (adds tolerance check so micro-separations don't kill jumps)
    const grounded = player.onGround || isOnGround(player);
    // Carry takeoff speed in air so P-speed bonus lingers until air friction/braking trims it
    if (!grounded && wasGrounded) {
      player.airCarryMax = Math.max(player.airCarryMax, Math.abs(player.vx));
    } else if (grounded) {
      player.airCarryMax = 0;
    }
    const speedCap = Math.max(maxSpeed, player.airCarryMax || 0);
    player.vx = clamp(player.vx, -speedCap, speedCap);
    player.onGround = grounded;
    player.coyote = grounded ? COYOTE_TIME : Math.max(0, player.coyote - dt);
    const skiddingActive = isSkidding && grounded;
    player.state = grounded ? (skiddingActive ? "skid" : "ground") : "jumping";
    if (player.statueActive) player.state = "statue";
    trackJumpDistance(wasGrounded, grounded);
    if (skiddingActive && Math.abs(player.vx) > 20) {
      player.pivotGrace = P_PIVOT_GRACE;
    } else {
      player.pivotGrace = Math.max(0, (player.pivotGrace || 0) - dt);
    }

    if (skiddingActive && Math.abs(player.vx) > 20) {
      player.skidDust -= dt;
      if (player.skidDust <= 0) {
        player.skidDust = SKID_DUST_INTERVAL;
        spawnSkidDust(player.x + (player.facing > 0 ? player.w : 0), player.y + player.h, player.facing);
      }
    }

    // Decay skid boost over time
    player.skidBoost = Math.max(0, player.skidBoost - SKID_BOOST_DECAY * dt);

    // P-speed charge only builds while holding run on ground near run cap; drains slowly otherwise
    const pQualifies = wantsRun && grounded && (Math.abs(player.vx) >= P_SPEED_ENTRY_SPEED || (player.pivotGrace && Math.abs(player.vx) >= P_SPEED_ENTRY_SPEED * 0.6));
    if (pQualifies) {
      player.pCharge = clamp(player.pCharge + dt / P_SPEED_CHARGE_TIME, 0, 1);
    } else if (player.pCharge > 0) {
      const decay = (!wantsRun || !grounded) ? P_SPEED_DECAY_RATE * 0.65 : P_SPEED_DECAY_RATE;
      player.pCharge = Math.max(0, player.pCharge - dt * decay);
    }
    trackPSpeedDistance(grounded, wantsRun, dt);

    // If jump is held while grounded, refresh the buffer so landing while held triggers another jump
    if (down("KeyZ") && grounded) player.jumpBuf = JUMP_BUFFER;

    // Fireball/Hammer throw
    if (!player.statueActive) {
      if (player.form !== PowerUpForm.Hammer && player.hammerCharging) {
        player.hammerCharging = false;
        player.hammerCharge = 0;
      }
      if (player.form === PowerUpForm.Hammer) {
        const canThrowHammer = player.hammerCooldown <= 0;
        if (canThrowHammer && hammerHeld) {
          if (!player.hammerCharging) {
            player.hammerCharging = true;
            player.hammerCharge = 0;
          }
          player.hammerCharge = Math.min(1, player.hammerCharge + (dt / HAMMER_CHARGE_TIME));
        }
        if (player.hammerCharging && !hammerHeld && canThrowHammer) {
          spawnHammer(player.hammerCharge);
          player.hammerCharging = false;
          player.hammerCharge = 0;
        }
        if (!canThrowHammer && !hammerHeld) {
          player.hammerCharging = false;
          player.hammerCharge = 0;
        }
      } else if (hammerTap && canShootFire() && player.fireCooldown <= 0) {
        spawnFireball();
      }
    } else {
      player.hammerCharging = false;
      player.hammerCharge = 0;
    }

    // Tail attack (Raccoon/Tanooki)
    if (!player.statueActive && hasTailAbilities() && tailSwing && player.tailCooldown <= 0) {
      player.tailTimer = TAIL_SWING_TIME;
      player.tailCooldown = TAIL_COOLDOWN;
      performTailAttack();
    }

    // Jump: only allow when currently on ground, no buffer
    if (player.jumpBuf > 0 && player.coyote > 0) {
      const swimming = isPlayerSwimming();
      if (swimming) {
        player.vy = -WATER_SWIM_IMPULSE;
        player.onGround = false;
      } else {
        player.vy = -JUMP_V;
        player.onGround = false;
        if (hasTailAbilities() && player.pCharge >= 1) {
          player.flightActive = true;
          player.flightTimer = FLIGHT_TIME;
        } else {
          player.flightActive = false;
          player.flightTimer = 0;
        }
      }
      player.state = "jumping";
      player.coyote = 0;
      player.jumpBuf = 0;
      startJumpTrack();
      // Capture takeoff speed so airborne clamp preserves P-speed until air drag/braking trims it
      player.airCarryMax = Math.max(player.airCarryMax || 0, Math.abs(player.vx));
    }

    // Level timer tick
    levelTimer = Math.max(0, levelTimer - dt);
    maybeAutoSave(dt);

    // Collect coin tiles
    collectCoinTileAtPlayer(player);

    // Entity updates
    for (const e of entities) {
      if (!e.alive) continue;

      if (e.type === "goon" || e.type === "mushroom") {
        e.vy += GRAVITY * dt;
        e.vy = Math.min(e.vy, MAX_FALL);
        entityMoveAndCollide(e, dt);

        // If it falls off world, kill it
        if (e.y > worldHpx + 200) e.alive = false;
      }
      if (e.type === "fireball") {
        e.life -= dt;
        if (e.life <= 0) {
          e.alive = false;
        } else {
          // gravity
          e.vy += FIREBALL_GRAVITY * dt;
          e.vy = Math.min(e.vy, MAX_FALL);
          applyMagnusForce(e, dt);

          // horizontal move, die on wall hit
          const dirX = Math.sign(e.vx);
          e.x += e.vx * dt;
          if (dirX !== 0) {
            const tx = Math.floor((dirX > 0 ? e.x + e.w : e.x) / TILE);
            const y0 = Math.floor(e.y / TILE);
            const y1 = Math.floor((e.y + e.h - 1) / TILE);
            for (let ty = y0; ty <= y1; ty++) {
              if (isSolid(getTile(tx, ty))) {
                e.alive = false;
                break;
              }
            }
          }

          // vertical move with ground bounce
          const dirY = Math.sign(e.vy);
          e.y += e.vy * dt;
          if (dirY !== 0) {
            const ty = Math.floor((dirY > 0 ? e.y + e.h : e.y) / TILE);
            const x0 = Math.floor(e.x / TILE);
            const x1 = Math.floor((e.x + e.w - 1) / TILE);
            for (let tx = x0; tx <= x1; tx++) {
              if (isSolid(getTile(tx, ty))) {
                if (dirY > 0) {
                  e.y = ty * TILE - e.h;
                  e.vy = -FIREBALL_BOUNCE_V;
                  e.bounces += 1;
                  if (e.bounces > 4) e.alive = false;
                } else {
                  e.alive = false;
                }
                break;
              }
            }
          }
        }
      }
      if (e.type === "hammer") {
        e.life -= dt;
        if (e.life <= 0) {
          e.alive = false;
        } else {
          e.spin = (e.spin + dt * 12) % (Math.PI * 2);
          e.vy += HAMMER_GRAVITY * dt;
          applyMagnusForce(e, dt);
          e.x += e.vx * dt;
          e.y += e.vy * dt;
          // collisions with tiles
          const tx0 = Math.floor(e.x / TILE);
          const tx1 = Math.floor((e.x + e.w - 1) / TILE);
          const ty0 = Math.floor(e.y / TILE);
          const ty1 = Math.floor((e.y + e.h - 1) / TILE);
          let collided = false;
          for (let ty = ty0; ty <= ty1; ty++) {
            for (let tx = tx0; tx <= tx1; tx++) {
              const t = getTile(tx, ty);
              if (isSolid(t)) {
                if (t === "B" || t === "I") {
                  breakDestructible(tx, ty);
                }
                collided = true;
                break;
              }
            }
            if (collided) break;
          }
          if (collided) e.alive = false;
        }
      }

      // Interactions with player
      if (e.alive && e.type === "mushroom") {
        if (aabb(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)) {
          e.alive = false;
          setPlayerForm(PowerUpForm.Super);
          spawnCoinBurst(e.x + e.w/2, e.y + e.h/2);
          score += 200;
        }
      }

      if (e.alive && e.type === "goon") {
        if (aabb(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)) {
          // stomp check: player coming from above with feet near enemy top
          const playerFeet = player.y + player.h;
          const enemyTop = e.y;
          const wasAboveEnemy = prevFeet <= enemyTop + 1;
          const descending = player.vy >= 0;
          const stomp = wasAboveEnemy && descending && (playerFeet - enemyTop) < 10;

          if (stomp) {
            e.alive = false;
            player.vy = -260; // bounce
            spawnCoinBurst(e.x + e.w/2, e.y + e.h/2);
          } else {
            handlePlayerHit();
          }
        }
      }

      if (e.alive && e.type === "fireball") {
        for (const target of entities) {
          if (!target.alive || target.type !== "goon") continue;
          if (aabb(e.x, e.y, e.w, e.h, target.x, target.y, target.w, target.h)) {
            target.alive = false;
            e.alive = false;
            spawnCoinBurst(target.x + target.w / 2, target.y + target.h / 2);
            break;
          }
        }
      }
      if (e.alive && e.type === "hammer") {
        for (const target of entities) {
          if (!target.alive || target.type !== "goon") continue;
          if (aabb(e.x, e.y, e.w, e.h, target.x, target.y, target.w, target.h)) {
            target.alive = false;
            e.alive = false;
            spawnCoinBurst(target.x + target.w / 2, target.y + target.h / 2);
            break;
          }
        }
      }
    }

    // cleanup
    for (let i = entities.length - 1; i >= 0; i--) {
      if (!entities[i].alive) entities.splice(i, 1);
    }

    // particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += GRAVITY * dt * 0.7;
      if (p.life <= 0) particles.splice(i, 1);
    }

    // Fall death
    if (player.y > worldHpx + 120) {
      killPlayer();
    }

    updateCamera();
  }

  // -----------------------------
  // Render
  // -----------------------------
  function drawTile(t, x, y, meta) {
    // x,y in pixels (world)
    const sx = Math.floor(x - cam.x);
    const sy = Math.floor(y - cam.y);
    if (sx < -TILE || sy < -TILE || sx > BASE_W || sy > BASE_H) return;

    if (customTileSprites.has(t)) {
      const img = customTileSprites.get(t);
      if (img && img.complete) {
        g.drawImage(img, sx, sy, TILE, TILE);
        return;
      }
    }
    if (isTerrainTile(t)) {
      drawSmartTerrainFace(g, t, sx, sy, TILE, meta, showTerrainDebug);
      return;
    }
    if (t === "B") { // brick
      g.fillStyle = "#7c3f2a";
      g.fillRect(sx, sy, TILE, TILE);
      g.fillStyle = "rgba(0,0,0,0.25)";
      g.fillRect(sx, sy + 1, TILE, 1);
      g.fillRect(sx, sy + 8, TILE, 1);
      g.fillRect(sx + 7, sy, 1, TILE);
      return;
    }
    if (t === "?") { // question block
      g.fillStyle = "#d1a23a";
      g.fillRect(sx, sy, TILE, TILE);
      g.fillStyle = "#8a6a18";
      g.fillRect(sx, sy + 12, TILE, 4);
      g.fillStyle = "#fff2";
      g.fillRect(sx, sy, TILE, 3);
      g.fillStyle = "#2b1d05";
      g.fillRect(sx + 6, sy + 4, 4, 8); // cheap "?"
      g.fillRect(sx + 8, sy + 4, 3, 3);
      return;
    }
    if (t === "u") { // used block
      g.fillStyle = "#8c8c8c";
      g.fillRect(sx, sy, TILE, TILE);
      g.fillStyle = "#0002";
      g.fillRect(sx, sy + 12, TILE, 4);
      return;
    }
    if (t === "L") { // ladder
      g.fillStyle = "#d6c087";
      g.fillRect(sx + 6, sy, 4, TILE);
      g.fillStyle = "#a98b4d";
      for (let y = 3; y < TILE; y += 4) {
        g.fillRect(sx + 2, sy + y, TILE - 4, 2);
      }
      return;
    }
    if (t === "C") { // coin tile
      // drawn as coin in world
      g.fillStyle = "#f5d000";
      g.fillRect(sx + 6, sy + 4, 4, 8);
      g.fillRect(sx + 5, sy + 6, 6, 4);
      g.fillStyle = "#fff5";
      g.fillRect(sx + 6, sy + 5, 2, 2);
      return;
    }
  }

  function drawJumpGuideOverlay() {}

  function trackJumpDistance(wasGrounded, grounded) {
    const centerTx = Math.floor(jumpCenterTile());
    const footTy = Math.floor((player.y + player.h - 1) / TILE);
    if (!grounded && wasGrounded) {
      startJumpTrack();
    } else if (grounded && !wasGrounded && jumpMetrics.startTx !== null && jumpMetrics.startTy !== null) {
      const dx = centerTx - jumpMetrics.startTx;
      const dy = jumpMetrics.startTy - footTy; // positive means landed higher
      jumpMetrics.lastJump = dx;
      jumpMetrics.lastJumpDx = dx;
      jumpMetrics.lastJumpDy = dy;
      jumpMetrics.maxJump = Math.max(jumpMetrics.maxJump, dx);
      if (Math.abs(dy) > Math.abs(jumpMetrics.maxJumpDy)) jumpMetrics.maxJumpDy = dy;
      jumpMetrics.maxJumpForm = player.form;
      jumpMetrics.startTx = null;
      jumpMetrics.startTy = null;
      if (showJumpMode) {
        const p0 = jumpMetrics.pReachTilesFromZero.toFixed(1);
        pushSystemChat(`Jump: ${dx.toFixed(1)} wide; ${dy.toFixed(1)} high; P=${p0}`);
      }
    }
  }

  function trackPSpeedDistance(grounded, wantsRun, dt) {
    const center = jumpCenterTile();
    const centerTile = Math.floor(center);
    const atPSpeed = player.pCharge >= 1;

    if (grounded && wantsRun) {
      if (jumpMetrics.pBuildStartTx === null) {
        jumpMetrics.pBuildStartTx = center;
        jumpMetrics.pReachTilesFromZero = 0;
        jumpMetrics.pBuildStartTime = performance.now();
        jumpMetrics.pRunStartTile = centerTile;
        jumpMetrics.pRunStartTime = performance.now();
      }
      if (atPSpeed && jumpMetrics.pReachTilesFromZero === 0 && jumpMetrics.pBuildStartTx !== null) {
        const startTile = jumpMetrics.pRunStartTile ?? Math.floor(jumpMetrics.pBuildStartTx);
        jumpMetrics.pReachTilesFromZero = Math.abs(centerTile - startTile);
        if (jumpMetrics.pBuildStartTime) {
          jumpMetrics.pReachTimeFromZero = (performance.now() - jumpMetrics.pBuildStartTime) / 1000;
        }
      }
      if (atPSpeed) {
        if (jumpMetrics.pStartTx === null) jumpMetrics.pStartTx = center;
        jumpMetrics.pDistance = center - (jumpMetrics.pStartTx ?? center);
      } else {
        jumpMetrics.pStartTx = null;
        jumpMetrics.pDistance = 0;
      }
    } else {
      jumpMetrics.pBuildStartTx = null;
      jumpMetrics.pBuildStartTime = null;
      jumpMetrics.pRunStartTile = null;
      jumpMetrics.pRunStartTime = null;
      jumpMetrics.pStartTx = null;
      jumpMetrics.pDistance = 0;
    }
  }

  function drawGridOverlay() {
    if (!showGrid || timelapseCaptureActive) return;
    // Grid locked to world coordinates, not screen overlay
    const step = TILE; // 16px per tile
    const startX = -(cam.x % step);
    const startY = -(cam.y % step);
    g.save();
    g.strokeStyle = "rgba(255,255,255,0.12)";
    g.lineWidth = 1;
    for (let x = startX; x <= BASE_W; x += step) {
      const lx = Math.floor(x) + 0.5;
      g.beginPath();
      g.moveTo(lx, 0);
      g.lineTo(lx, BASE_H);
      g.stroke();
    }
    for (let y = startY; y <= BASE_H; y += step) {
      const ly = Math.floor(y) + 0.5;
      g.beginPath();
      g.moveTo(0, ly);
      g.lineTo(BASE_W, ly);
      g.stroke();
    }
    g.restore();
  }

  function drawLayerDebugOverlay() {
    if (!showTerrainDebug) return;
    const viewTop = cam.y;
    const viewBottom = cam.y + BASE_H;
    const startK = Math.floor((layerOriginY - viewBottom) / LAYER_HEIGHT_PX);
    const endK = Math.ceil((layerOriginY - viewTop) / LAYER_HEIGHT_PX);
    g.save();
    g.lineWidth = 2;
    g.strokeStyle = "rgba(255, 214, 10, 0.9)";
    g.fillStyle = "rgba(0,0,0,0.8)";
    g.font = "10px 'Press Start 2P', 'VT323', monospace";
    g.textBaseline = "middle";
    g.textAlign = "left";
    for (let k = startK; k <= endK; k++) {
      const yWorld = layerOriginY - k * LAYER_HEIGHT_PX;
      const yScreen = Math.floor(yWorld - cam.y);
      if (yScreen < -24 || yScreen > BASE_H + 24) continue;
      const above = layerInfoForY(yWorld - 1).label;
      const below = layerInfoForY(yWorld + 1).label;
      const label = above === below ? above : `${below} → ${above}`;
      g.beginPath();
      g.moveTo(0, yScreen + 0.5);
      g.lineTo(BASE_W, yScreen + 0.5);
      g.stroke();
      const text = `Layer ${k >= 0 ? k : `-${Math.abs(k)}`}: ${label}`;
      const padX = 6;
      const padY = 3;
      const textW = g.measureText(text).width;
      const bx = 8;
      const by = Math.max(padY, Math.min(BASE_H - 18, yScreen - 10));
      g.fillRect(bx - padX, by - padY, textW + padX * 2, 16);
      g.strokeRect(bx - padX, by - padY, textW + padX * 2, 16);
      g.fillStyle = "#f2f5ff";
      g.fillText(text, bx, by + 5);
      g.fillStyle = "rgba(0,0,0,0.8)";
    }
    g.restore();
  }

  function drawSelectionOverlay() {
    if (!editorOpen || !selectedCell) return;
    const { tx, ty } = selectedCell;
    const sx = Math.floor(tx * TILE - cam.x);
    const sy = Math.floor(ty * TILE - cam.y);
    if (sx < -TILE || sy < -TILE || sx > BASE_W || sy > BASE_H) return;
    g.save();
    g.fillStyle = "rgba(0, 255, 170, 0.18)";
    g.fillRect(sx, sy, TILE, TILE);
    g.strokeStyle = "rgba(0, 255, 170, 0.95)";
    g.lineWidth = 2.5;
    g.strokeRect(sx + 0.5, sy + 0.5, TILE - 1, TILE - 1);
    g.strokeStyle = "rgba(0, 0, 0, 0.45)";
    g.lineWidth = 1;
    g.strokeRect(sx + 1.5, sy + 1.5, TILE - 3, TILE - 3);
    g.restore();
  }

  function drawHoverOverlay() {
    if (!editorOpen || !hoverCell) return;
    const { tx, ty } = hoverCell;
    const sx = Math.floor(tx * TILE - cam.x);
    const sy = Math.floor(ty * TILE - cam.y);
    if (sx < -TILE || sy < -TILE || sx > BASE_W || sy > BASE_H) return;
    g.save();
    g.strokeStyle = "rgba(255, 255, 255, 0.7)";
    g.lineWidth = 1;
    g.strokeRect(sx + 0.5, sy + 0.5, TILE - 1, TILE - 1);
    g.restore();
  }

  function drawLabelsOverlay() {
    if (!editorOpen) return;
    g.save();
    g.font = "8px 'Press Start 2P', 'VT323', monospace";
    g.textAlign = "center";
    g.textBaseline = "middle";
    const outline = (text, x, y, color) => {
      g.fillStyle = "rgba(0,0,0,0.8)";
      g.fillText(text, x + 1, y);
      g.fillText(text, x - 1, y);
      g.fillText(text, x, y + 1);
      g.fillText(text, x, y - 1);
      g.fillStyle = color;
      g.fillText(text, x, y);
    };
    const selKey = selectedCell ? `${selectedCell.tx},${selectedCell.ty}` : null;
    const hovKey = hoverCell ? `${hoverCell.tx},${hoverCell.ty}` : null;
    for (const [key, text] of labelMap.entries()) {
      if (!text) continue;
      const [txStr, tyStr] = key.split(",");
      const tx = parseInt(txStr, 10);
      const ty = parseInt(tyStr, 10);
      const sx = Math.floor(tx * TILE - cam.x);
      const sy = Math.floor(ty * TILE - cam.y);
      if (sx < -TILE || sy < -TILE || sx > BASE_W || sy > BASE_H) continue;
      const cx = sx + TILE / 2;
      const cy = sy + TILE / 2;
      if (key === selKey || key === hovKey) {
        outline(text, cx, cy, "#f2f5ff");
      } else {
        // badge in corner
        g.fillStyle = "rgba(0,0,0,0.5)";
        g.fillRect(sx + TILE - 8, sy, 8, 8);
        g.fillStyle = "#f2f5ff";
        g.fillText("T", sx + TILE - 4, sy + 4);
      }
    }
    g.restore();
  }

  function drawEndlessDebugOverlay() {
    if (!ENDLESS_ENABLED || !showEndlessDebug) return;
    const cols = worldBuffer.columns;
    if (!cols.length) return;
    const overlayW = 220;
    const overlayH = 60;
    const ox = 8;
    const oy = 8;
    const minTx = cols[0].tx;
    const maxTx = cols[cols.length - 1].tx;
    const span = Math.max(1, maxTx - minTx + 1);
    const scaleX = overlayW / span;
    const scaleY = overlayH / Math.max(1, mapH);
    g.save();
    g.globalAlpha = 0.92;
    g.fillStyle = "rgba(0,0,0,0.55)";
    g.fillRect(ox - 2, oy - 2, overlayW + 4, overlayH + 22);
    g.strokeStyle = "rgba(255,255,255,0.35)";
    g.strokeRect(ox - 2, oy - 2, overlayW + 4, overlayH + 22);

    for (const col of cols) {
      const cx = ox + (col.tx - minTx) * scaleX;
      if (col.tiles.length === 0) {
        g.fillStyle = "#ff6b6b";
        g.fillRect(cx, oy, Math.max(1, scaleX), overlayH);
      } else {
        const gy = oy + overlayH - col.ground * scaleY;
        g.fillStyle = "#7dd3fc";
        g.fillRect(cx, gy, Math.max(1, scaleX), overlayH - (gy - oy));
      }
    }
    const camTx = cam.x / TILE;
    const playerTx = player.x / TILE;
    const camX = ox + (camTx - minTx) * scaleX;
    const pX = ox + (playerTx - minTx) * scaleX;
    g.fillStyle = "#f2f5ff";
    g.fillRect(camX - 1, oy - 2, 2, overlayH + 4);
    g.fillStyle = "#fbbf24";
    g.fillRect(pX - 1, oy - 2, 2, overlayH + 4);
    g.fillStyle = "#f2f5ff";
    g.font = "8px 'Press Start 2P', 'VT323', monospace";
    g.textAlign = "left";
    g.textBaseline = "top";
    g.fillText(`seed:${worldRng.seed}`, ox, oy + overlayH + 4);
    g.fillText(`d:${Math.floor(difficultyState.distance)}`, ox, oy + overlayH + 14);
    g.restore();
  }

  function render() {
    const inUnderground = cam.y >= undergroundStartPx;
    if (inUnderground) {
      g.fillStyle = UNDERGROUND_BG;
      g.fillRect(0,0,BASE_W,BASE_H);
      g.fillStyle = UNDERGROUND_ACCENT;
      g.fillRect(0,0,BASE_W,16);
    } else {
      // sky
      g.fillStyle = "#4b79ff";
      g.fillRect(0,0,BASE_W,BASE_H);

      // parallax clouds
      const cloudX = -((cam.x * 0.2) % 120);
      g.fillStyle = "rgba(255,255,255,0.65)";
      for (let i = 0; i < 6; i++) {
        const x = cloudX + i * 120;
        g.fillRect(x + 10, 18, 28, 10);
        g.fillRect(x + 0, 22, 40, 12);
        g.fillRect(x + 30, 24, 22, 10);
      }
    }

    // tiles
    const tx0 = Math.floor(cam.x / TILE);
    const tx1 = Math.floor((cam.x + BASE_W) / TILE) + 1;

    for (let y = 0; y < mapH; y++) {
      for (let x = tx0; x <= tx1; x++) {
        const t = getTile(x, y);
        if (t !== ".") {
          const terrainMeta = isTerrainTile(t) ? classifyTerrainTile(x, y) : null;
          drawTile(t, x * TILE, y * TILE, terrainMeta);
        }
      }
    }

    // entities
    for (const e of entities) {
      const sx = Math.floor(e.x - cam.x);
      const sy = Math.floor(e.y - cam.y);
      if (sx < -40 || sy < -40 || sx > BASE_W+40 || sy > BASE_H+40) continue;

      if (e.type === "goon") {
        g.fillStyle = "#6b3b2a";
        g.fillRect(sx, sy, e.w, e.h);
        g.fillStyle = "#000";
        g.fillRect(sx + 3, sy + 5, 2, 2);
        g.fillRect(sx + 9, sy + 5, 2, 2);
        g.fillStyle = "#2a120a";
        g.fillRect(sx + 2, sy + 11, e.w-4, 3);
      }
      if (e.type === "mushroom") {
        g.fillStyle = "#d43c3c";
        g.fillRect(sx, sy, e.w, e.h);
        g.fillStyle = "#f3d9d9";
        g.fillRect(sx + 2, sy + 7, e.w-4, e.h-9);
        g.fillStyle = "#fff7";
        g.fillRect(sx + 3, sy + 3, 3, 3);
        g.fillRect(sx + 9, sy + 2, 3, 3);
      }
      if (e.type === "fireball") {
        g.fillStyle = "#ff7b21";
        g.fillRect(sx, sy, e.w, e.h);
        g.fillStyle = "#ffd19b";
        g.fillRect(sx + 2, sy + 2, Math.max(1, e.w - 4), Math.max(1, e.h - 4));
      }
      if (e.type === "hammer") {
        g.save();
        g.translate(sx + e.w / 2, sy + e.h / 2);
        g.rotate(e.spin || 0);
        g.fillStyle = "#c9c9c9";
        g.fillRect(-e.w / 2, -e.h / 2, e.w, e.h);
        g.fillStyle = "#8a6b2f";
        g.fillRect(-1, -e.h / 2, 2, e.h);
        g.restore();
      }
    }

    // remote players
    for (const peer of peers.values()) {
      const w = 12;
      const isBig = peer.form ? formIsBig(peer.form) : peer.big;
      const h = isBig ? 22 : 14;
      const sx = Math.floor((peer.x ?? peer.targetX ?? 0) - cam.x);
      const sy = Math.floor((peer.y ?? peer.targetY ?? 0) - cam.y);
      if (sx < -40 || sy < -40 || sx > BASE_W+40 || sy > BASE_H+40) continue;
      g.fillStyle = "#2ad4b8"; // shirt
      g.fillRect(sx, sy, w, Math.min(8, h));
      g.fillStyle = "#1c3faa"; // pants
      g.fillRect(sx, sy + 8, w, h - 8);
      g.fillStyle = "#000";
      g.fillRect(sx + (peer.facing > 0 ? 8 : 3), sy + 4, 2, 2);
      if (isBig) {
        g.fillStyle = "#0002";
        g.fillRect(sx, sy, w, h);
      }
    }

    // player
    {
      const blink = player.invuln > 0 && Math.floor(performance.now() / 60) % 2 === 0;
      if (!blink) {
        const sx = Math.floor(player.x - cam.x);
        const sy = Math.floor(player.y - cam.y);
        if (player.statueActive) {
          g.fillStyle = "#5b4c3b";
          g.fillRect(sx, sy, player.w, player.h);
          g.fillStyle = "#2b241d";
          g.fillRect(sx + 2, sy + 2, player.w - 4, player.h - 4);
        } else {
          g.fillStyle = "#e23b2e"; // shirt
          g.fillRect(sx, sy, player.w, Math.min(8, player.h));
          g.fillStyle = "#2a49ff"; // pants
          g.fillRect(sx, sy + 8, player.w, player.h - 8);
          g.fillStyle = "#f2c7a7"; // face
          g.fillRect(sx + 3, sy + 2, 6, 5);
          g.fillStyle = "#000";
          g.fillRect(sx + (player.facing > 0 ? 8 : 3), sy + 4, 2, 2);
        const palette = formPalette(player.form);
        g.fillStyle = palette.shirt;
        g.fillRect(sx, sy, player.w, Math.min(8, player.h));
        g.fillStyle = palette.pants;
        g.fillRect(sx, sy + 8, player.w, player.h - 8);
        g.fillStyle = "#f2c7a7"; // face
        g.fillRect(sx + 3, sy + 2, 6, 5);
        g.fillStyle = "#000";
        g.fillRect(sx + (player.facing > 0 ? 8 : 3), sy + 4, 2, 2);
        if (player.big) {
          g.fillStyle = "#0002";
          g.fillRect(sx, sy, player.w, player.h);
        }
        if (player.form === PowerUpForm.Jetpack) {
          const packX = sx + (player.facing > 0 ? -2 : player.w - 2);
          const packH = Math.min(12, player.h - 4);
          g.fillStyle = "#4a4f59";
          g.fillRect(packX, sy + 4, 4, packH);
          if (player.flightActive) {
            g.fillStyle = "#ffce45";
            g.fillRect(packX, sy + player.h, 4, 3);
            g.fillStyle = "#ff7f11";
            g.fillRect(packX + 1, sy + player.h + 2, 2, 3);
          }
        }
        if (player.tailTimer > 0 && hasTailAbilities()) {
          const dir = player.facing >= 0 ? 1 : -1;
          const tx = sx + (dir > 0 ? player.w : -TAIL_RANGE_X);
          const ty = sy + (player.h - TAIL_RANGE_Y - 4);
          g.fillStyle = "#d18f2c";
            g.fillRect(tx, ty, TAIL_RANGE_X, TAIL_RANGE_Y);
            g.fillStyle = "#ffdd99";
            g.fillRect(tx + (dir > 0 ? 2 : 0), ty + 2, TAIL_RANGE_X - 4, TAIL_RANGE_Y - 4);
          }
        }
      }
    }

    // particles
    for (const p of particles) {
      const sx = Math.floor(p.x - cam.x);
      const sy = Math.floor(p.y - cam.y);
      g.fillStyle = p.color || "#ffe066";
      const size = p.size || 2;
      g.fillRect(sx, sy, size, size);
    }

    drawHudCanvas();
    drawGridOverlay();
    drawLayerDebugOverlay();
    drawHoverOverlay();
    drawSelectionOverlay();
    drawLabelsOverlay();
    drawEndlessDebugOverlay();
    if (clickDebug && clickDebug.timer > 0) {
      const { sx, sy } = clickDebug;
      g.save();
      g.fillStyle = "rgba(255,0,200,0.9)";
      g.fillRect(sx + TILE/2 - 1, sy, 2, TILE);
      g.fillRect(sx, sy + TILE/2 - 1, TILE, 2);
      g.restore();
    }

    // blit scaled to main canvas
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(off, 0, 0, canvas.width, canvas.height);

    // Update DOM name tags (self + peers) aligned to the canvas
    const rect = canvas.getBoundingClientRect();
    const scaleX = rect.width / BASE_W;
    const scaleY = rect.height / BASE_H;
    renderChatPanel(rect, scaleX, scaleY);
    tagLayer.innerHTML = "";
    const addTag = (label, worldX, worldY, color = "#f2f5ff") => {
      const screenX = (worldX - cam.x) * scaleX;
      const screenY = (worldY - cam.y) * scaleY;
      const el = document.createElement("div");
      el.textContent = label;
      el.style.position = "absolute";
      el.style.left = `${rect.left + screenX}px`;
      el.style.top = `${rect.top + screenY}px`;
      el.style.transform = "translate(-50%, -100%)";
      el.style.font = "16px 'Press Start 2P', 'VT323', monospace";
      el.style.color = color;
      el.style.textShadow = "1px 1px 0 #000, -1px 1px 0 #000, 1px -1px 0 #000, -1px -1px 0 #000";
      el.style.pointerEvents = "none";
      tagLayer.appendChild(el);
    };
    const addBubble = (text, worldX, worldY, color = "#f2f5ff") => {
      if (!text) return;
      const screenX = (worldX - cam.x) * scaleX;
      const screenY = (worldY - cam.y) * scaleY;
      const el = document.createElement("div");
      el.textContent = text;
      el.style.position = "absolute";
      el.style.left = `${rect.left + screenX}px`;
      el.style.top = `${rect.top + screenY}px`;
      el.style.transform = "translate(-50%, -120%)";
      el.style.font = "14px 'Press Start 2P', 'VT323', monospace";
      el.style.color = color;
      el.style.background = "rgba(0,0,0,0.75)";
      el.style.border = "1px solid rgba(255,255,255,0.35)";
      el.style.padding = "4px 6px";
      el.style.borderRadius = "6px";
      el.style.maxWidth = "220px";
      el.style.whiteSpace = "normal";
      el.style.wordBreak = "break-word";
      el.style.textAlign = "center";
      el.style.textShadow = "1px 1px 0 #000";
      el.style.pointerEvents = "none";
      tagLayer.appendChild(el);
    };
    const addAreaBadge = (text) => {
      const el = document.createElement("div");
      el.textContent = text;
      el.style.position = "absolute";
      el.style.left = `${rect.left + 10 * scaleX}px`;
      el.style.top = `${rect.top + 10 * scaleY}px`;
      el.style.transform = "translate(0, 0)";
      el.style.font = "14px 'Press Start 2P', 'VT323', monospace";
      el.style.color = "#f2f5ff";
      el.style.background = "rgba(0,0,0,0.82)";
      el.style.border = "1px solid rgba(255,255,255,0.4)";
      el.style.borderRadius = "8px";
      el.style.padding = `${6 * scaleY}px ${10 * scaleX}px`;
      el.style.textShadow = "1px 1px 0 #000";
      el.style.boxShadow = "0 2px 0 rgba(0,0,0,0.45)";
      el.style.pointerEvents = "none";
      tagLayer.appendChild(el);
    };
    // Area badge (top-left)
    const layerInfo = layerInfoForY(player.y + player.h / 2);
    addAreaBadge(layerInfo.label);
    // self
    addTag(`${PLAYER_NAME}`, player.x + player.w / 2, player.y - 4, "#f6d341");
    if (selfChatBubble) addBubble(selfChatBubble.text, player.x + player.w / 2, player.y - 14, "#f6d341");
    // peers
    for (const peer of peers.values()) {
      const px = peer.x ?? peer.targetX ?? 0;
      const py = peer.y ?? peer.targetY ?? 0;
      addTag(`${peer.name || "P"}`, px + 6, py - 4, "#f2f5ff");
      if (peer.bubble) addBubble(peer.bubble.text, px + 6, py - 14, "#f2f5ff");
    }
  }

  function renderChatPanel(rect, scaleX, scaleY) {
    const shouldShowInput = chatInput.style.display !== "none";
    const shouldShowLog = chatLog.length > 0 && (chatVisibleTime > -2 || shouldShowInput);
    if (!shouldShowLog && !shouldShowInput) {
      chatPanel.style.display = "none";
      return;
    }

    chatPanel.style.display = "flex";
    const hudTop = rect.top + (BASE_H - HUD_PX) * scaleY;
    const hudHeight = HUD_PX * scaleY;
    chatPanel.style.left = `${rect.left}px`;
    chatPanel.style.top = `${hudTop}px`;
    chatPanel.style.width = `${rect.width}px`;
    chatPanel.style.height = `${hudHeight}px`;
    chatPanel.style.padding = `${6 * scaleY}px ${12 * scaleX}px`;
    chatPanel.style.background = "linear-gradient(180deg, rgba(6,10,25,0.72), rgba(6,10,25,0.85))";
    chatPanel.style.borderTop = "2px solid rgba(255,255,255,0.4)";
    chatPanel.style.boxShadow = "0 -2px 0 rgba(0,0,0,0.7)";
    chatPanel.style.filter = "drop-shadow(0 2px 0 #000)";
    chatPanel.style.lineHeight = "1.35";
    chatPanel.style.flexDirection = "column";
    chatPanel.style.justifyContent = "flex-end";
    chatPanel.style.alignItems = "stretch";

    chatLogContainer.innerHTML = "";
    if (shouldShowLog) {
      const start = Math.max(0, chatLog.length - 7);
      for (let i = start; i < chatLog.length; i++) {
        const entry = chatLog[i];
        const alpha = entry.pin ? 1 : Math.max(0, Math.min(1, chatVisibleTime / 2));
        if (alpha <= 0) continue;
        const lineEl = document.createElement("div");
        lineEl.style.opacity = alpha.toFixed(3);
        lineEl.style.background = entry.pin ? "rgba(0,0,0,0.92)" : "rgba(0,0,0,0.84)";
        lineEl.style.border = entry.pin ? "1px solid rgba(255,255,255,0.65)" : "1px solid rgba(255,255,255,0.42)";
        lineEl.style.borderRadius = "8px";
        lineEl.style.padding = "6px 8px";
        lineEl.style.color = "#f2f5ff";
        lineEl.style.textShadow = "1px 1px 0 #000";
        lineEl.style.boxShadow = "0 2px 0 rgba(0,0,0,0.55)";
        lineEl.style.display = "flex";
        lineEl.style.alignItems = "center";
        lineEl.style.gap = "6px";
        lineEl.style.whiteSpace = "normal";
        lineEl.style.wordBreak = "break-word";

        const nameEl = document.createElement("span");
        nameEl.textContent = `${entry.name}:`;
        nameEl.style.color = entry.name === "SYSTEM" ? "#f6d341" : "#9ad5ff";
        nameEl.style.flex = "0 0 auto";
        const textEl = document.createElement("span");
        textEl.textContent = entry.text;
        textEl.style.flex = "1 1 auto";

        lineEl.appendChild(nameEl);
        lineEl.appendChild(textEl);
        chatLogContainer.appendChild(lineEl);
      }
      chatLogContainer.scrollTop = chatLogContainer.scrollHeight;
    }

    chatInputWrapper.style.display = shouldShowInput ? "flex" : "none";
    chatInputWrapper.style.marginTop = shouldShowLog ? `${6 * scaleY}px` : "0";
    chatInputWrapper.style.alignItems = "stretch";
    chatInputWrapper.style.gap = `${6 * scaleX}px`;
    chatInputWrapper.style.padding = `${2 * scaleY}px`;
    const chatFontSize = Math.max(10, 12 * scaleY);
    const bubblePadY = Math.max(6, 6 * scaleY);
    const chatPadY = bubblePadY;
    const chatPadX = Math.max(8, 10 * scaleX);
    chatInput.style.fontSize = `${chatFontSize}px`;
    chatInput.style.lineHeight = "1.35";
    chatInput.style.padding = `${chatPadY}px ${chatPadX}px`;
    chatInput.style.boxShadow = "inset 0 0 0 2px rgba(255,255,255,0.08), 0 1px 0 rgba(0,0,0,0.6)";
    const estimatedInputRow = shouldShowInput ? chatFontSize + chatPadY * 2 + 8 * scaleY : 0;
    const logMaxPx = Math.max(0, hudHeight - estimatedInputRow - 12 * scaleY);
    chatLogContainer.style.maxHeight = `${logMaxPx}px`;
    chatLogContainer.style.flex = "1 1 auto";
    chatLogContainer.style.justifyContent = "flex-end";
    chatLogContainer.style.overflow = "hidden";

    chatPanel.style.pointerEvents = shouldShowInput ? "auto" : "none";
  }

  function drawHudCanvas() {
    const hudH = HUD_TILES * TILE;
    const hudY = BASE_H - hudH;
    // background
    g.fillStyle = "#b8e8ff";
    g.fillRect(0, hudY, BASE_W, hudH);
    g.strokeStyle = "#000";
    g.lineWidth = 4;
    g.strokeRect(0, hudY, BASE_W, hudH);
    g.strokeStyle = "#7fb7d6";
    g.lineWidth = 3;
    g.strokeRect(2, hudY + 2, BASE_W - 4, hudH - 4);

    g.save();
    g.translate(6, hudY + 6);
    g.fillStyle = "#000";
    g.font = "8px 'Press Start 2P', 'VT323', monospace";
    g.textBaseline = "top";

    const drawBlock = (lines, x) => {
      const padX = 8, padY = 6;
      const w = 70, h = hudH - 12;
      g.fillStyle = "#b8e8ff";
      g.strokeStyle = "#000";
      g.lineWidth = 3;
      g.beginPath();
      g.rect(x, 0, w, h);
      g.fill();
      g.stroke();
      g.strokeStyle = "#7fb7d6";
      g.lineWidth = 2;
      g.strokeRect(x + 2, 2, w - 4, h - 4);
      g.fillStyle = "#000";
      let y = padY;
      for (const line of lines) {
        g.fillText(line, x + padX, y);
        y += 12;
      }
    };

    drawBlock(["WORLD", "1"], 0);
    drawBlock([`M x ${lives}`, `COIN ${coinCount.toString().padStart(2, "0")}`], 80);
    drawBlock([`SPD ${Math.abs(player.vx).toFixed(0)}`, `ACC ${player.ax.toFixed(0)}`], 160);
    drawBlock([`FORM ${player.form ? player.form.slice(0,2).toUpperCase() : "SM"}`, `T ${Math.max(0, Math.floor(levelTimer)).toString().padStart(3,"0")}`], 240);
    drawBlock([`SCORE`, score.toString().padStart(6,"0")], 320);
    const flyLabel = player.form === PowerUpForm.Jetpack ? "∞" : (player.flightActive ? player.flightTimer.toFixed(1) : "0");
    drawBlock([`FLY ${flyLabel}`, `P ${pMeterDisplaySegs}/${P_METER_SEGMENTS}`], 400);

    g.restore();
  }

  function updateHudDom() {
    const worldEl = document.getElementById("hud-world");
    const livesEl = document.getElementById("hud-lives");
    const coinsEl = document.getElementById("hud-coins");
    const scoreEl = document.getElementById("hud-score");
    const timeEl = document.getElementById("hud-time");
    const accEl = document.getElementById("hud-acc");
    const spdEl = document.getElementById("hud-spd");
    const pMeterEl = document.getElementById("hud-pmeter");
    const formEl = document.getElementById("hud-form");
    const starEl = document.getElementById("hud-star");
    const flyEl = document.getElementById("hud-fly");

    if (!worldEl) return;
    worldEl.textContent = "1";
    livesEl.textContent = Math.max(1, lives);
    coinsEl.textContent = coinCount.toString().padStart(2, "0");
    scoreEl.textContent = score.toString().padStart(6, "0");
    timeEl.textContent = Math.max(0, Math.floor(levelTimer)).toString().padStart(3, "0");
    const ax = player.ax;
    accEl.textContent = `${ax >= 0 ? "+" : ""}${ax.toFixed(0)}`;
    if (spdEl) {
      const spd = Math.abs(player.vx);
      spdEl.textContent = spd.toFixed(0);
    }
    if (formEl) {
      const formLabel = player.form ? player.form.slice(0, 2).toUpperCase() : "SM";
      formEl.textContent = formLabel;
    }
    if (starEl) {
      const starTime = Math.max(0, player.invuln);
      starEl.textContent = starTime > 0 ? starTime.toFixed(1) : "0";
      starEl.style.color = starTime > 0 ? "#ffeb3b" : "#fff";
    }
    if (flyEl) {
      const flyValue = player.form === PowerUpForm.Jetpack ? "∞" : (player.flightActive ? player.flightTimer.toFixed(1) : "0");
      flyEl.textContent = flyValue;
    }

    if (pMeterEl) {
      const filled = pMeterDisplaySegs;
      for (let i = 0; i < pMeterEl.children.length; i++) {
        pMeterEl.children[i].classList.toggle("filled", i < filled);
      }
    }
  }

  function updateDebugOverlay() {
    if (!debugVxEl && !debugAxEl && !debugPChargeEl && !debugPSegsEl) return;
    if (debugVxEl) debugVxEl.textContent = player.vx.toFixed(1);
    if (debugAxEl) debugAxEl.textContent = player.ax.toFixed(1);
    if (debugPChargeEl) debugPChargeEl.textContent = (player.pCharge * 100).toFixed(1);
    if (debugPSegsEl) debugPSegsEl.textContent = `${pMeterDisplaySegs}/${P_METER_SEGMENTS}`;
  }

  function updatePMeterUi(dt) {
    const speedRatio = clamp(Math.abs(player.vx) / P_SPEED_MAX, 0, 1);
    const targetSegs = Math.min(P_METER_SEGMENTS, Math.round(speedRatio * P_METER_SEGMENTS));

    if (targetSegs > pMeterDisplaySegs) {
      pMeterDisplaySegs = targetSegs;
      pMeterDecayHold = P_METER_DECAY_DELAY;
    } else if (targetSegs < pMeterDisplaySegs) {
      if (pMeterDecayHold <= 0) {
        pMeterDecayHold = P_METER_DECAY_DELAY;
      } else {
        pMeterDecayHold = Math.max(0, pMeterDecayHold - dt);
        if (pMeterDecayHold <= 0) pMeterDisplaySegs = targetSegs;
      }
    } else {
      pMeterDecayHold = Math.max(0, pMeterDecayHold - dt);
    }
  }

  // -----------------------------
  // Main loop
  // -----------------------------
  function frame(now) {
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    acc += dt;

    while (acc >= FIXED) {
      step(FIXED);
      acc -= FIXED;
    }

    if (clickDebug && clickDebug.timer > 0) {
      clickDebug.timer -= dt;
      if (clickDebug.timer <= 0) clickDebug = null;
    }

    updateNetwork(dt);

    // consume pressed keys for this frame
    pressed.clear();

    updatePMeterUi(dt);
    updateHudDom();
    updateDebugOverlay();
    // chat fade timer
    if (chatVisibleTime > 0) chatVisibleTime = Math.max(0, chatVisibleTime - dt);
    decayChatBubbles(dt);
    render();
    flushDemoCapture();
    requestAnimationFrame(frame);
  }

  function drawBadge(label, x, y, color = "#f2f5ff") {
    const text = label || "";
    const padding = 4;
    const font = "7px 'Press Start 2P', 'VT323', monospace";
    badgeCtx.font = font;
    badgeCtx.textAlign = "center";
    badgeCtx.textBaseline = "middle";
    const textW = badgeCtx.measureText(text).width;
    const w = Math.max(36, Math.ceil(textW + padding * 2));
    const h = 12;
    badgeCanvas.width = w;
    badgeCanvas.height = h;
    badgeCtx.imageSmoothingEnabled = false;
    badgeCtx.font = font;
    badgeCtx.textAlign = "center";
    badgeCtx.textBaseline = "middle";
    badgeCtx.fillStyle = "rgba(0,0,0,0.55)";
    badgeCtx.fillRect(0, 0, w, h);
    badgeCtx.fillStyle = color;
    badgeCtx.fillText(text, Math.floor(w / 2), Math.floor(h / 2) + 1);
    // blit without scaling for crisp edges
    const destX = Math.round(x - w / 2);
    const destY = Math.round(y);
    g.drawImage(badgeCanvas, destX, destY);
  }

  // Start
  const jumpWalkEl = document.getElementById("jump-walk");
  const jumpRunEl = document.getElementById("jump-run");
  const pMeterEl = document.getElementById("hud-pmeter");
  if (pMeterEl && pMeterEl.children.length === 0) {
    for (let i = 0; i < P_METER_SEGMENTS; i++) {
      const seg = document.createElement("div");
      seg.className = "pmeter-seg";
      pMeterEl.appendChild(seg);
    }
  }
  if (jumpWalkEl && jumpRunEl) {
    jumpWalkEl.textContent = jumpWalkTiles.toFixed(1);
    jumpRunEl.textContent = jumpRunTiles.toFixed(1);
  }

  loadPlayerSnapshot();
  savePlayerSnapshot();
  loadLevelSnapshot();
  updateCamera();
  requestAnimationFrame(frame);

})();
</script>
</body>
</html>



