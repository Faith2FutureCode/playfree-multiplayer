<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Plumber Platformer (SMB3-inspired)</title>
  <style>
    html, body {
      margin:0;
      height:100%;
      background:#0b1020;
      overflow:hidden;
      position: relative;
    }
    :root { --canvas-width: 960px; --canvas-height: 720px; --editor-width: 0px; --tile: 16px; }
    canvas { display:block; margin:0 auto; image-rendering: pixelated; image-rendering: crisp-edges; }
    .app-shell {
      position: absolute;
      left: 50%;
      top: 0;
      bottom: 0;
      transform: translateX(-50%);
      display: flex;
      align-items: flex-start;
      gap: 0;
      margin: 0;
      width: calc(var(--canvas-width) + var(--editor-width));
      transition: width 0.15s ease;
    }
    .editor-panel {
      width: var(--editor-width);
      max-width: 360px;
      background: #0a0f1f;
      border-right: 3px solid #000;
      box-shadow: inset -4px 0 0 rgba(255,255,255,0.08);
      color: #dfe7ff;
      font: 12px/1.3 "Press Start 2P", "VT323", monospace;
      display: none;
      padding: 10px;
      box-sizing: border-box;
      image-rendering: pixelated;
      height: 100%;
      overflow-y: auto;
    }
    body.editor-open .editor-panel { display: block; }
    .editor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 12px;
      letter-spacing: 1px;
    }
    .editor-section {
      margin-bottom: 12px;
    }
    .author-only { display: none; }
    body.author .author-only { display: block; }
    .editor-section h4 {
      margin: 0 0 6px 0;
      font-size: 11px;
      letter-spacing: 1px;
      color: #9fb3ff;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .editor-section h4::after {
      content: "â–¾";
      color: #f6d341;
      font-size: 10px;
    }
    .editor-section.collapsed h4::after { content: "â–¸"; }
    .editor-section.collapsed .editor-grid,
    .editor-section.collapsed .editor-field,
    .editor-section.collapsed .editor-actions,
    .editor-section.collapsed .tilesheet-panel,
    .editor-section.collapsed .editor-hint {
      display: none;
    }
    .editor-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(32px, 1fr));
      gap: 8px;
    }
    .editor-tile {
      width: 38px;
      height: 38px;
      border: 2px solid #000;
      background: #123;
      display: grid;
      place-items: center;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
      position: relative;
      cursor: pointer;
    }
    .editor-tile.selected {
      box-shadow:
        inset 0 0 0 2px rgba(255,255,255,0.08),
        0 0 0 2px #f6d341;
    }
    .tile-preview {
      width: 24px;
      height: 24px;
      image-rendering: pixelated;
      border: 1px solid rgba(0,0,0,0.35);
      background: #0b1629;
    }
    .editor-field {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 11px;
      color: #dfe7ff;
    }
    .editor-field input {
      background: #0f182a;
      border: 2px solid #000;
      color: #dfe7ff;
      padding: 6px 8px;
      font: 12px "Press Start 2P", "VT323", monospace;
      outline: none;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
    }
    .editor-field select {
      background: #0f182a;
      border: 2px solid #000;
      color: #dfe7ff;
      padding: 6px 8px;
      font: 12px "Press Start 2P", "VT323", monospace;
      outline: none;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
    }
    .editor-actions {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 11px;
      color: #dfe7ff;
    }
    .editor-actions button {
      background: #123;
      border: 2px solid #000;
      color: #f6d341;
      padding: 6px 8px;
      font: 12px "Press Start 2P", "VT323", monospace;
      cursor: pointer;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
    }
    .editor-actions button.active {
      background: #1c2f55;
      color: #fff;
      box-shadow: inset 0 0 0 2px #f6d341;
    }
    .editor-hint { margin-top: 10px; font-size: 10px; color: #9fb3ff; }
    .editor-hint[data-state="error"] { color: #ff9b9b; }
    .editor-hint[data-state="success"] { color: #b5f7a1; }
    .tilesheet-panel {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .tilesheet-preview {
      width: 100%;
      max-width: 320px;
      height: 200px;
      border: 2px solid #000;
      background: #0f182a;
      image-rendering: pixelated;
    }
    .tilesheet-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .tilesheet-actions button {
      flex: 1 1 auto;
      min-width: 120px;
    }
    .palette-context-menu {
      position: fixed;
      display: none;
      flex-direction: column;
      gap: 4px;
      padding: 6px;
      background: #0f182a;
      border: 2px solid #000;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
      z-index: 300;
      font: 10px/1.3 "Press Start 2P", "VT323", monospace;
      color: #dfe7ff;
    }
    .palette-context-menu.open { display: flex; }
    .palette-context-menu button {
      background: #123;
      border: 2px solid #000;
      color: #f6d341;
      padding: 4px 6px;
      font: inherit;
      cursor: pointer;
      text-align: left;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
    }
    .palette-context-menu button:hover {
      background: #1c2f55;
      color: #fff;
    }
    body.editor-open .game-shell canvas { cursor: none; }
    /* HUD now rendered on canvas; hide DOM HUD shell */
    .hud { display:none; }
    .hud-icon-coin {
      width: 10px; height: 14px;
      background:#f5d000;
      box-shadow: -1px 2px 0 #000, 1px 2px 0 #000;
    }
    .hud-block { display:flex; align-items:center; gap:6px; }
    .hud small { font-size:10px; }
    .hud-pmeter { display:flex; align-items:center; gap:6px; }
    .pmeter-label { letter-spacing:1px; }
    .pmeter-bar { display:flex; gap:2px; }
    .pmeter-seg {
      width: 10px; height: 12px;
      background:#000;
      box-shadow: inset 0 0 0 2px #fff;
      transition: background 0.12s;
    }
    .pmeter-seg.filled { background:#ffb347; box-shadow: inset 0 0 0 2px #000; }
    .hud-speed-chip {
      display: flex;
      align-items: center;
      gap: 6px;
      background: #b8e8ff;
      border: 4px solid #000;
      padding: 4px 10px;
      box-shadow: inset 0 0 0 3px #7fb7d6;
    }
    .settings-toggle {
      position: fixed;
      top: 12px;
      right: 12px;
      width: 36px;
      height: 36px;
      border-radius: 10px;
      border: 2px solid #000;
      background: rgba(15, 24, 42, 0.9);
      color: #dfe7ff;
      font: 16px/1 "Press Start 2P", "VT323", monospace;
      display: grid;
      place-items: center;
      cursor: pointer;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
      z-index: 260;
    }
    .settings-panel {
      position: fixed;
      top: 56px;
      right: 12px;
      width: 260px;
      background: rgba(10, 15, 31, 0.95);
      border: 2px solid #000;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
      padding: 10px 12px;
      color: #cbd5e1;
      font: 11px/1.45 "Press Start 2P", "VT323", monospace;
      display: none;
      z-index: 260;
    }
    .settings-panel.open { display: block; }
    .settings-panel h5 {
      margin: 0 0 6px 0;
      font-size: 11px;
      color: #f6d341;
      letter-spacing: 1px;
    }
    .settings-panel .settings-row {
      margin-bottom: 8px;
    }
    .debug-panel {
      position: fixed; top: 12px; left: 12px;
      background: rgba(0,0,0,0.6);
      color: #dce4ff;
      font: 12px/1.4 "VT323", monospace;
      padding: 8px 10px;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 8px;
      min-width: 120px;
      pointer-events: none;
    }
    .debug-panel div { display:flex; justify-content: space-between; gap: 8px; }

    /* Inventory overlay (SMB3-style) */
    .inventory-overlay {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(0, 0, 0, 0.6);
      z-index: 200;
      image-rendering: pixelated;
      font-family: "Press Start 2P", "VT323", monospace;
    }
    .inventory-overlay.open { display: grid; }
    .inventory-panel {
      background: #0b74c5;
      border: 4px solid #fff;
      box-shadow:
        inset 0 0 0 3px #000,
        0 0 0 2px #000,
        0 0 12px rgba(0,0,0,0.45);
      padding: 10px 12px 12px;
      width: 560px;
    }
    .inventory-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      color: #ffe28a;
      text-shadow: 1px 0 #000, -1px 0 #000, 0 1px #000, 0 -1px #000;
      font-size: 13px;
    }
    .inventory-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 6px;
    }
    .inventory-slot {
      position: relative;
      background: #0f6cb6;
      border: 3px solid #fff;
      box-shadow: inset 0 0 0 2px #000;
      height: 62px;
      color: #ffe28a;
      display: grid;
      place-items: center;
      text-shadow: 1px 0 #000, -1px 0 #000, 0 1px #000, 0 -1px #000;
    }
    .inventory-slot.empty { background: #0d64a9; color: #2c4f73; }
    .inventory-slot.selected {
      box-shadow:
        inset 0 0 0 2px #000,
        0 0 0 3px #f6d341;
    }
    .inventory-icon {
      font-size: 28px;
      line-height: 1;
      pointer-events: none;
    }
    .inventory-count {
      position: absolute;
      bottom: 4px;
      right: 6px;
      font-size: 11px;
    }
    .inventory-footer {
      margin-top: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #ffe28a;
      text-shadow: 1px 0 #000, -1px 0 #000, 0 1px #000, 0 -1px #000;
      font-size: 12px;
    }
    .inventory-hint {
      color: #fff;
      font-size: 11px;
      opacity: 0.9;
    }
  </style>
</head>
<body>
<div class="app-shell">
  <div id="editor-panel" class="editor-panel" aria-label="Level editor palette">
    <div class="editor-header">
      <span>PALETTE</span>
      <span>Press E</span>
    </div>
    <div class="editor-section">
      <h4>TERRAIN</h4>
      <div class="editor-grid" id="terrain-grid">
        <div class="editor-tile solid" data-tile="#" title="Ground"><canvas class="tile-preview" width="8" height="8" data-tile="#"></canvas></div>
        <div class="editor-tile sand" data-tile="S" title="Sand"><canvas class="tile-preview" width="8" height="8" data-tile="S"></canvas></div>
        <div class="editor-tile ice" data-tile="I" title="Ice"><canvas class="tile-preview" width="8" height="8" data-tile="I"></canvas></div>
      </div>
    </div>
    <div class="editor-section">
      <h4>OBJECTS</h4>
      <div class="editor-grid" id="object-grid">
        <div class="editor-tile" data-tile="B" title="Brick"><canvas class="tile-preview" width="8" height="8" data-tile="B"></canvas></div>
        <div class="editor-tile" data-tile="?" title="? Block"><canvas class="tile-preview" width="8" height="8" data-tile="?"></canvas></div>
        <div class="editor-tile" data-tile="u" title="Used Block"><canvas class="tile-preview" width="8" height="8" data-tile="u"></canvas></div>
        <div class="editor-tile" data-tile="C" title="Coin"><canvas class="tile-preview" width="8" height="8" data-tile="C"></canvas></div>
      </div>
    </div>
    <div class="editor-section">
      <h4>ENEMIES</h4>
      <div class="editor-grid" id="enemy-grid">
        <div class="editor-tile" data-tile="E" title="Enemy Spawn"><canvas class="tile-preview" width="8" height="8" data-tile="E"></canvas></div>
      </div>
    </div>
    <div class="editor-section">
      <h4>SPAWNS</h4>
      <div class="editor-grid" id="spawn-grid">
        <div class="editor-tile" data-tile="P" title="Player Spawn"><canvas class="tile-preview" width="8" height="8" data-tile="P"></canvas></div>
      </div>
    </div>
    <div class="editor-section">
      <h4>UNDEFINED</h4>
      <div class="editor-grid" id="undefined-grid"></div>
    </div>
    <div class="editor-section author-only">
      <h4>TILESHEET CUTTER</h4>
      <div class="tilesheet-panel">
        <input id="tilesheet-upload" type="file" accept="image/png, image/jpeg"/>
        <canvas id="tilesheet-preview" class="tilesheet-preview" width="320" height="200"></canvas>
        <div class="tilesheet-actions">
          <button id="tilesheet-add-button" type="button">Add Tile to Undefined</button>
          <button id="tilesheet-clear-button" type="button">Clear Selection</button>
        </div>
        <div id="tilesheet-status" class="editor-hint" data-state="idle">Load a tilesheet, drag to select any size, save as 16x16.</div>
      </div>
    </div>
    <div class="editor-section author-only">
      <h4>AUTHOR TOOLS</h4>
      <div class="editor-field">
        <label for="sprite-upload">Sprite Upload</label>
        <input id="sprite-upload" type="file" accept="image/png, image/jpeg"/>
      </div>
      <div class="editor-field">
        <label for="sprite-upload-category">Palette Category</label>
        <select id="sprite-upload-category">
          <option value="undefined" selected>Undefined</option>
          <option value="terrain">Terrain</option>
          <option value="objects">Objects</option>
          <option value="enemies">Enemies</option>
          <option value="spawns">Spawns</option>
        </select>
      </div>
      <div class="editor-actions">
        <button id="publish-level-button" type="button">Publish Draft</button>
        <button id="export-level-button" type="button">Export Level</button>
        <button id="import-level-button" type="button">Import Level</button>
        <input id="import-level-input" type="file" accept="application/json" style="display:none"/>
      </div>
      <div id="sprite-upload-status" class="editor-hint" data-state="idle">Upload a square PNG/JPG (max 256x256).</div>
    </div>
    <div class="editor-section">
      <h4>LEVEL</h4>
      <div class="editor-actions">
        <button id="reset-level-button" type="button">Reset Level</button>
      </div>
    </div>
    <div class="editor-field">
      <label for="editor-label-input">Label</label>
      <input id="editor-label-input" type="text" maxlength="24" placeholder="Type to tag block"/>
    </div>
    <div class="editor-field">
      <label for="editor-text-stamp">Stamp Text (uses selected tile)</label>
      <input id="editor-text-stamp" type="text" maxlength="24" placeholder="Enter text"/>
      <div class="editor-actions">
        <button id="editor-stamp-button" type="button">Stamp</button>
      </div>
    </div>
    <div class="editor-hint">Left click paint Â· Right click erase Â· E to toggle</div>
  </div>
  <div id="palette-context-menu" class="palette-context-menu" aria-hidden="true">
    <button type="button" data-category="terrain">Terrain</button>
    <button type="button" data-category="objects">Objects</button>
    <button type="button" data-category="enemies">Enemies</button>
    <button type="button" data-category="spawns">Spawns</button>
    <button type="button" data-category="undefined">Undefined</button>
  </div>
  <div class="game-shell">
    <canvas id="c" width="912" height="816"></canvas>
    <div class="hud" aria-label="HUD">
  <div class="hud-bar">
    <div class="hud-section hud-left">
      <div class="hud-block">
        <span>WORLD</span>
        <span id="hud-world">1</span>
      </div>
      <div class="hud-block">
        <small>M</small>
        <span>x</span>
        <span id="hud-lives">3</span>
      </div>
    </div>
    <div class="hud-section hud-center">
      <div class="hud-speed-chip">
        <span>SPD</span>
        <span id="hud-spd">0</span>
      </div>
      <div class="hud-pmeter" aria-label="P-Meter">
        <span class="pmeter-label">P</span>
        <div class="pmeter-bar" id="hud-pmeter"></div>
      </div>
      <div class="hud-speed-chip">
        <span>FLY</span>
        <span id="hud-fly">0</span>
      </div>
    </div>
    <div class="hud-section hud-right">
      <div class="hud-block">
        <span>FORM</span>
        <span id="hud-form">SM</span>
      </div>
      <div class="hud-block">
        <div class="hud-icon-coin"></div>
        <span>x</span>
        <span id="hud-coins">00</span>
      </div>
      <div class="hud-block">
        <span id="hud-score">000000</span>
      </div>
      <div class="hud-block">
        <span>T</span>
        <span id="hud-time">300</span>
      </div>
      <div class="hud-block">
        <span>ACC</span>
        <span id="hud-acc">0</span>
      </div>
      <div class="hud-block">
        <span>â˜…</span>
        <span id="hud-star">0</span>
      </div>
    </div>
  </div>
</div>
</div>
</div>
<button id="settings-toggle" class="settings-toggle" type="button" aria-label="Game info">
  âš™
</button>
<div id="settings-panel" class="settings-panel" aria-hidden="true">
  <h5>GAME INFO</h5>
  <div class="settings-row">Controls: Arrows move Â· Z jump Â· X run Â· C fire/tail/hammer Â· V statue Â· R restart</div>
  <div class="settings-row">Goal: Collect coins, hit ? blocks, stomp enemies.</div>
  <div class="settings-row">Jump range: Walk <span id="jump-walk">--</span> tiles Â· Run <span id="jump-run">--</span> tiles</div>
</div>
<div class="debug-panel" id="debug-panel" aria-label="Debug overlay">
  <div><span>vx</span><span id="debug-vx">0</span></div>
  <div><span>ax</span><span id="debug-ax">0</span></div>
  <div><span>P</span><span><span id="debug-pcharge">0</span>% (<span id="debug-psegs">0</span>/<span id="debug-pmax">0</span>)</span></div>
</div>

<div class="inventory-overlay" id="inventory-overlay" aria-label="Inventory">
  <div class="inventory-panel">
    <div class="inventory-header">
      <span>ITEM STORAGE</span>
      <span class="inventory-hint">Arrows move Â· Enter uses Â· Esc closes</span>
    </div>
    <div class="inventory-grid" id="inventory-grid" role="grid"></div>
    <div class="inventory-footer">
      <span id="inventory-selected">--</span>
      <span class="inventory-hint" id="inventory-footer-hint">Use</span>
    </div>
  </div>
</div>

<script>
(() => {
  // -----------------------------
  // Config
  // -----------------------------
  const AUTHOR_LOGIN_ENDPOINT = "/api/author-login";
  const AUTHOR_LOGOUT_ENDPOINT = "/api/author-logout";
  const AUTHOR_STATUS_ENDPOINT = "/api/author-status";
  const AUTHOR_DIAGNOSTICS_ENDPOINT = "/api/author-diagnostics";
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });
  const setAuthorClass = (enabled) => {
    document.body.classList.toggle("author", enabled);
  };
  async function refreshAuthorStatus() {
    try {
      const res = await fetch(AUTHOR_STATUS_ENDPOINT, { credentials: "include" });
      if (!res.ok) {
        setAuthorClass(false);
        return false;
      }
      const data = await res.json();
      const enabled = Boolean(data && data.author);
      setAuthorClass(enabled);
      return enabled;
    } catch (err) {
      setAuthorClass(false);
      return false;
    }
  }
  function formatAuthorError(error) {
    if (!error) return "Author login failed.";
    if (error === "server_misconfigured") {
      return "Author login failed: server missing config.";
    }
    if (error === "network_error") {
      return "Author login failed: network error.";
    }
    if (error.startsWith("http_")) {
      const code = error.split("_")[1] || "error";
      return `Author login failed: server error (${code}).`;
    }
    return "Author login failed.";
  }
  async function authorLogin(pass) {
    if (!pass) return { ok: false, error: "empty" };
    try {
      const res = await fetch(AUTHOR_LOGIN_ENDPOINT, {
        method: "POST",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ pass }),
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        setAuthorClass(false);
        const error = data && data.error ? data.error : `http_${res.status}`;
        return { ok: false, error };
      }
      const enabled = Boolean(data && data.author);
      setAuthorClass(enabled);
      return { ok: enabled, error: enabled ? null : data && data.error ? data.error : "login_failed" };
    } catch (err) {
      return { ok: false, error: "network_error" };
    }
  }
  async function authorLogout() {
    try {
      await fetch(AUTHOR_LOGOUT_ENDPOINT, {
        method: "POST",
        credentials: "include",
      });
    } catch (err) {
      // ignore network errors
    }
    setAuthorClass(false);
    return false;
  }
  async function authorDiagnostics() {
    try {
      const res = await fetch(AUTHOR_DIAGNOSTICS_ENDPOINT, { credentials: "include" });
      if (!res.ok) return null;
      return await res.json();
    } catch (err) {
      return null;
    }
  }
  function handleAuthorCommand(text) {
    const raw = text.replace("/author", "").trim();
    if (!raw) {
      beginAuthorPrompt();
      return true;
    }
    const parts = raw.split(/\s+/);
    const action = parts[0].toLowerCase();
    if (action === "logout" || action === "off") {
      authorLogout().then(() => {
        pushSystemChat("Author mode disabled.");
      });
      return false;
    }
    if (action === "status") {
      refreshAuthorStatus().then((enabled) => {
        pushSystemChat(enabled ? "Author mode enabled." : "Author mode disabled.");
      });
      return false;
    }
    if (action === "diag" || action === "diagnostics") {
      authorDiagnostics().then((data) => {
        if (!data) {
          pushSystemChat("Author diagnostics failed.");
          return;
        }
        const pass = data.hasPassphraseHash ? "yes" : "no";
        const token = data.hasTokenSecret ? "yes" : "no";
        pushSystemChat(`Author diagnostics: hash=${pass}, secret=${token}.`);
      });
      return false;
    }
    beginAuthorPrompt();
    return true;
  }
  refreshAuthorStatus();

  // Pixel-art vibe: render at low-res then scale up
  const BASE_W = 304; // 19 tiles wide
  const BASE_H = 272; // 17 tiles tall (14 play + 3 HUD)
  const HUD_TILES = 3;
  let SCALE = 3; // integer-only scaling for crisp pixels
  let showGrid = true;
  let editorOpen = false;
  let editorTile = "#";
  let selectedCell = null; // {tx, ty}
  let hoverCell = null; // {tx, ty}
  let editorClipboard = null;
  let clickDebug = null; // {sx, sy, tx, ty, timer}
  let stampMode = false;
  const undoStack = [];
  const redoStack = [];
  const TEXT_FONT = {
    A: ["0110","1001","1111","1001","1001"],
    B: ["1110","1001","1110","1001","1110"],
    C: ["0111","1000","1000","1000","0111"],
    D: ["1110","1001","1001","1001","1110"],
    E: ["1111","1000","1110","1000","1111"],
    F: ["1111","1000","1110","1000","1000"],
    G: ["0111","1000","1011","1001","0111"],
    H: ["1001","1001","1111","1001","1001"],
    I: ["111","010","010","010","111"],
    J: ["0111","0010","0010","1010","0100"],
    K: ["1001","1010","1100","1010","1001"],
    L: ["1000","1000","1000","1000","1111"],
    M: ["10001","11011","10101","10001","10001"],
    N: ["1001","1101","1011","1001","1001"],
    O: ["0110","1001","1001","1001","0110"],
    P: ["1110","1001","1110","1000","1000"],
    Q: ["0110","1001","1001","1011","0111"],
    R: ["1110","1001","1110","1010","1001"],
    S: ["0111","1000","0110","0001","1110"],
    T: ["111","010","010","010","010"],
    U: ["1001","1001","1001","1001","0110"],
    V: ["1001","1001","1001","0101","0010"],
    W: ["10001","10001","10101","11011","10001"],
    X: ["1001","0110","0100","0110","1001"],
    Y: ["1001","0101","0010","0010","0010"],
    Z: ["1111","0010","0100","1000","1111"],
    "0": ["0110","1001","1001","1001","0110"],
    "1": ["010","110","010","010","111"],
    "2": ["1110","0001","0110","1000","1111"],
    "3": ["1110","0001","0110","0001","1110"],
    "4": ["1001","1001","1111","0001","0001"],
    "5": ["1111","1000","1110","0001","1110"],
    "6": ["0111","1000","1110","1001","0110"],
    "7": ["1111","0001","0010","0100","0100"],
    "8": ["0110","1001","0110","1001","0110"],
    "9": ["0110","1001","0111","0001","1110"],
    " ": ["0","0","0","0","0"],
    ".": ["0","0","0","0","1"],
    "!": ["1","1","1","0","1"],
    "?": ["111","001","011","000","010"],
    "-": ["0","0","111","0","0"],
  };
  const off = document.createElement("canvas");
  off.width = BASE_W;
  off.height = BASE_H;
  const g = off.getContext("2d", { alpha: false });

  const applyLayoutVars = (displayW, displayH) => {
    const cw = displayW ?? (canvas.clientWidth || canvas.width);
    const ch = displayH ?? (canvas.clientHeight || canvas.height);
    const targetWidth = Math.round(ch * (16 / 9));
    const editorTotal = Math.max(0, targetWidth - cw);
    const editorWidth = editorOpen ? editorTotal : 0;
    document.documentElement.style.setProperty("--canvas-width", `${cw}px`);
    document.documentElement.style.setProperty("--canvas-height", `${ch}px`);
    document.documentElement.style.setProperty("--editor-width", `${editorWidth}px`);
  };

  const applyScale = () => {
    // Scale smoothly to fit viewport while preserving aspect ratio (no integer step jumps)
    const scale = Math.min(window.innerWidth / BASE_W, window.innerHeight / BASE_H);
    SCALE = scale;
    canvas.width = BASE_W;
    canvas.height = BASE_H;
    const displayW = BASE_W * scale;
    const displayH = BASE_H * scale;
    canvas.style.width = `${displayW}px`;
    canvas.style.height = `${displayH}px`;
    applyLayoutVars(displayW, displayH);
  };

  applyScale();
  window.addEventListener("resize", applyScale);
  ctx.imageSmoothingEnabled = false;
  g.imageSmoothingEnabled = false;

  let prevGridOn = showGrid;
  function setEditorOpen(next) {
    if (next && !editorOpen) {
      prevGridOn = showGrid;
      showGrid = true; // ensure grid visible in editor
    }
    if (!next && editorOpen) {
      showGrid = prevGridOn; // restore prior state
    }
    editorOpen = next;
    document.body.classList.toggle("editor-open", editorOpen);
    if (!editorOpen) closePaletteContextMenu();
    applyLayoutVars();
  }

  function selectEditorTile(tile, el) {
    editorTile = tile;
    document.querySelectorAll(".editor-tile.selected").forEach(n => n.classList.remove("selected"));
    if (el) el.classList.add("selected");
  }

  const TILE = 16;
  const MAX_UPLOAD_BYTES = 128 * 1024;
  const MAX_UPLOAD_DIM = 256;
  const CUSTOM_TILE_LIMIT = 32;
  const ALLOWED_UPLOAD_TYPES = new Set(["image/png", "image/jpeg"]);
  const tileRegistry = new Map();
  const customTiles = [];
  const builtinTiles = [];
  let customTileCounter = 0;
  const BUILTIN_TILE_MANIFEST = "/sprites/output/smb3_tiles_1_16x16_manifest.json";
  const spriteUploadInput = document.getElementById("sprite-upload");
  const spriteUploadStatus = document.getElementById("sprite-upload-status");
  const spriteUploadCategory = document.getElementById("sprite-upload-category");
  const paletteContextMenu = document.getElementById("palette-context-menu");
  const tilesheetUpload = document.getElementById("tilesheet-upload");
  const tilesheetPreview = document.getElementById("tilesheet-preview");
  const tilesheetAddButton = document.getElementById("tilesheet-add-button");
  const tilesheetClearButton = document.getElementById("tilesheet-clear-button");
  const tilesheetStatus = document.getElementById("tilesheet-status");
  const publishLevelButton = document.getElementById("publish-level-button");
  const exportLevelButton = document.getElementById("export-level-button");
  const importLevelButton = document.getElementById("import-level-button");
  const importLevelInput = document.getElementById("import-level-input");
  const resetLevelButton = document.getElementById("reset-level-button");
  const DRAFT_PAYLOAD_KEY = "playfree.level.draft.v1";
  const PUBLISHED_PAYLOAD_KEY = "playfree.level.published.v1";
  const PAYLOAD_VERSION = 1;
  const CATEGORY_GRID_IDS = {
    terrain: "terrain-grid",
    objects: "object-grid",
    enemies: "enemy-grid",
    spawns: "spawn-grid",
    undefined: "undefined-grid",
  };
  const CATEGORY_LABELS = {
    terrain: "Terrain",
    objects: "Objects",
    enemies: "Enemies",
    spawns: "Spawns",
    undefined: "Undefined",
  };
  let paletteContextEntry = null;

  function setUploadStatus(message, state = "idle") {
    if (!spriteUploadStatus) return;
    spriteUploadStatus.textContent = message;
    spriteUploadStatus.dataset.state = state;
  }

  function setTilesheetStatus(message, state = "idle") {
    if (!tilesheetStatus) return;
    tilesheetStatus.textContent = message;
    tilesheetStatus.dataset.state = state;
  }

  function getPaletteGrid(category) {
    const id = CATEGORY_GRID_IDS[category] || CATEGORY_GRID_IDS.undefined || CATEGORY_GRID_IDS.objects;
    return document.getElementById(id);
  }

  function createPaletteTile(entry, options = {}) {
    const { isCustom = true } = options;
    const tileEl = document.createElement("div");
    tileEl.className = "editor-tile";
    tileEl.dataset.tile = entry.id;
    if (isCustom) tileEl.dataset.custom = "1";
    tileEl.title = entry.name || "Custom";
    const canvasEl = document.createElement("canvas");
    canvasEl.className = "tile-preview";
    canvasEl.width = 8;
    canvasEl.height = 8;
    canvasEl.setAttribute("data-tile", entry.id);
    tileEl.appendChild(canvasEl);
    tileEl.addEventListener("click", () => {
      selectEditorTile(entry.id, tileEl);
    });
    if (isCustom) {
      tileEl.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        e.stopPropagation();
        openPaletteContextMenu(entry, e.clientX, e.clientY);
      });
    }
    return tileEl;
  }

  function addCustomTileToPalette(entry) {
    const grid = getPaletteGrid(entry.category);
    if (!grid) return null;
    const tileEl = createPaletteTile(entry, { isCustom: true });
    grid.appendChild(tileEl);
    renderPalettePreviews();
    return tileEl;
  }

  function addBuiltinTileToPalette(entry) {
    const grid = getPaletteGrid(entry.category);
    if (!grid) return null;
    const tileEl = createPaletteTile(entry, { isCustom: false });
    grid.appendChild(tileEl);
    renderPalettePreviews();
    return tileEl;
  }

  function clearCustomPaletteEntries() {
    document.querySelectorAll(".editor-tile[data-custom='1']").forEach((node) => {
      node.remove();
    });
  }

  function sanitizeTileName(name) {
    const base = (name || "Custom").replace(/\.[^.]+$/, "").trim();
    const safe = base.replace(/[^\w\- ]+/g, "").trim();
    return (safe || "Custom").slice(0, 24);
  }

  function normalizeCategory(raw) {
    if (raw && CATEGORY_GRID_IDS[raw]) return raw;
    return "undefined";
  }

  function categoryLabel(category) {
    return CATEGORY_LABELS[category] || "Objects";
  }

  function closePaletteContextMenu() {
    if (!paletteContextMenu) return;
    paletteContextMenu.classList.remove("open");
    paletteContextMenu.setAttribute("aria-hidden", "true");
    paletteContextEntry = null;
  }

  function openPaletteContextMenu(entry, clientX, clientY) {
    if (!paletteContextMenu || !entry) return;
    paletteContextEntry = entry;
    paletteContextMenu.classList.add("open");
    paletteContextMenu.setAttribute("aria-hidden", "false");
    paletteContextMenu.style.left = "0px";
    paletteContextMenu.style.top = "0px";
    const rect = paletteContextMenu.getBoundingClientRect();
    const maxX = Math.max(8, window.innerWidth - rect.width - 8);
    const maxY = Math.max(8, window.innerHeight - rect.height - 8);
    const left = Math.min(Math.max(8, clientX), maxX);
    const top = Math.min(Math.max(8, clientY), maxY);
    paletteContextMenu.style.left = `${left}px`;
    paletteContextMenu.style.top = `${top}px`;
  }

  function moveCustomTileToCategory(entry, category) {
    if (!entry || entry.source !== "custom") return;
    const nextCategory = normalizeCategory(category);
    if (entry.category === nextCategory) return;
    const wasSelected = editorTile === entry.id;
    entry.category = nextCategory;
    document.querySelectorAll(`.editor-tile[data-custom='1'][data-tile="${entry.id}"]`).forEach((node) => {
      node.remove();
    });
    const tileEl = addCustomTileToPalette(entry);
    if (wasSelected && tileEl) selectEditorTile(entry.id, tileEl);
    setUploadStatus(`Moved ${entry.name || entry.id} to ${categoryLabel(nextCategory)}.`, "success");
    queueDraftSave();
  }

  function nextCustomTileId() {
    customTileCounter += 1;
    return `custom:${String(customTileCounter).padStart(3, "0")}`;
  }

  function estimateDataUrlBytes(dataUrl) {
    if (typeof dataUrl !== "string") return 0;
    const idx = dataUrl.indexOf("base64,");
    if (idx === -1) return 0;
    const base64 = dataUrl.slice(idx + 7);
    return Math.floor((base64.length * 3) / 4);
  }

  function createImageFromSource(source) {
    const img = new Image();
    img.onload = () => {
      renderPalettePreviews();
    };
    img.src = source;
    return img;
  }

  function registerCustomTile(entry, options = {}) {
    const { skipPalette = false } = options;
    entry.image = createImageFromSource(entry.png);
    tileRegistry.set(entry.id, entry);
    customTiles.push(entry);
    const match = /^custom:(\d+)/.exec(entry.id);
    if (match) {
      const num = Number(match[1]);
      if (Number.isFinite(num)) customTileCounter = Math.max(customTileCounter, num);
    }
    if (!skipPalette) addCustomTileToPalette(entry);
  }

  function registerBuiltinTile(entry) {
    entry.image = createImageFromSource(entry.png);
    tileRegistry.set(entry.id, entry);
    builtinTiles.push(entry);
    addBuiltinTileToPalette(entry);
  }

  function loadBuiltinTileManifest() {
    if (!BUILTIN_TILE_MANIFEST) return;
    fetch(BUILTIN_TILE_MANIFEST)
      .then((res) => (res.ok ? res.json() : null))
      .then((data) => {
        if (!data || !Array.isArray(data.entries)) return;
        data.entries.forEach((raw, index) => {
          if (!raw || !raw.id || !raw.png) return;
          const entry = {
            id: String(raw.id),
            name: sanitizeTileName(raw.name || `Tile ${index + 1}`),
            category: normalizeCategory(raw.category || "terrain"),
            source: "builtin",
            w: TILE,
            h: TILE,
            png: String(raw.png),
          };
          registerBuiltinTile(entry);
        });
      })
      .catch(() => {});
  }

  function loadCustomTiles(entries) {
    tileRegistry.clear();
    customTiles.length = 0;
    customTileCounter = 0;
    clearCustomPaletteEntries();
    (entries || []).forEach((entry) => {
      registerCustomTile(entry, { skipPalette: true });
    });
    customTiles.forEach((entry) => addCustomTileToPalette(entry));
  }

  const tilesheetState = {
    image: null,
    scale: 1,
    offsetX: 0,
    offsetY: 0,
    selection: null, // {x, y, w, h} in image coords
    dragging: false,
    dragStart: null,
  };

  function renderTilesheetPreview() {
    if (!tilesheetPreview) return;
    const ctx = tilesheetPreview.getContext("2d", { alpha: false });
    ctx.clearRect(0, 0, tilesheetPreview.width, tilesheetPreview.height);
    ctx.fillStyle = "#0f182a";
    ctx.fillRect(0, 0, tilesheetPreview.width, tilesheetPreview.height);
    const img = tilesheetState.image;
    if (!img) return;
    const scale = Math.min(
      tilesheetPreview.width / img.width,
      tilesheetPreview.height / img.height
    );
    const drawW = Math.floor(img.width * scale);
    const drawH = Math.floor(img.height * scale);
    const offsetX = Math.floor((tilesheetPreview.width - drawW) / 2);
    const offsetY = Math.floor((tilesheetPreview.height - drawH) / 2);
    tilesheetState.scale = scale;
    tilesheetState.offsetX = offsetX;
    tilesheetState.offsetY = offsetY;
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(img, offsetX, offsetY, drawW, drawH);
    if (tilesheetState.selection) {
      const sel = tilesheetState.selection;
      const sx = offsetX + Math.floor(sel.x * scale);
      const sy = offsetY + Math.floor(sel.y * scale);
      const sw = Math.max(1, Math.floor(sel.w * scale));
      const sh = Math.max(1, Math.floor(sel.h * scale));
      ctx.strokeStyle = "#f6d341";
      ctx.lineWidth = 2;
      ctx.strokeRect(sx + 1, sy + 1, sw - 2, sh - 2);
    }
  }

  function tilesheetCanvasToImage(x, y) {
    const img = tilesheetState.image;
    if (!img) return null;
    const relX = x - tilesheetState.offsetX;
    const relY = y - tilesheetState.offsetY;
    if (relX < 0 || relY < 0) return null;
    if (relX > img.width * tilesheetState.scale || relY > img.height * tilesheetState.scale) return null;
    const imgX = Math.max(0, Math.min(img.width, Math.floor(relX / tilesheetState.scale)));
    const imgY = Math.max(0, Math.min(img.height, Math.floor(relY / tilesheetState.scale)));
    return { x: imgX, y: imgY };
  }

  function setTilesheetSelection(start, end) {
    const x1 = Math.min(start.x, end.x);
    const y1 = Math.min(start.y, end.y);
    const x2 = Math.max(start.x, end.x);
    const y2 = Math.max(start.y, end.y);
    tilesheetState.selection = {
      x: x1,
      y: y1,
      w: Math.max(1, x2 - x1),
      h: Math.max(1, y2 - y1),
    };
    renderTilesheetPreview();
  }

  function loadImageFromFile(file) {
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => {
        URL.revokeObjectURL(url);
        resolve(img);
      };
      img.onerror = () => {
        URL.revokeObjectURL(url);
        reject(new Error("image_load_failed"));
      };
      img.src = url;
    });
  }

  async function handleSpriteUpload(file) {
    if (!file) return;
    const ext = (file.name || "").toLowerCase().split(".").pop();
    const typeOk = ALLOWED_UPLOAD_TYPES.has(file.type) || ["png", "jpg", "jpeg"].includes(ext);
    if (!typeOk) {
      setUploadStatus("Only PNG or JPG files are allowed.", "error");
      return;
    }
    if (file.size > MAX_UPLOAD_BYTES) {
      setUploadStatus(`File too large (max ${Math.round(MAX_UPLOAD_BYTES / 1024)} KB).`, "error");
      return;
    }
    if (customTiles.length >= CUSTOM_TILE_LIMIT) {
      setUploadStatus("Custom tile limit reached.", "error");
      return;
    }
    let img;
    try {
      img = await loadImageFromFile(file);
    } catch (err) {
      setUploadStatus("Could not read image file.", "error");
      return;
    }
    const w = img.naturalWidth || img.width;
    const h = img.naturalHeight || img.height;
    if (!w || !h) {
      setUploadStatus("Invalid image dimensions.", "error");
      return;
    }
    if (w !== h) {
      setUploadStatus("Image must be square.", "error");
      return;
    }
    if (w > MAX_UPLOAD_DIM) {
      setUploadStatus(`Max size is ${MAX_UPLOAD_DIM}x${MAX_UPLOAD_DIM}.`, "error");
      return;
    }
    const canvas = document.createElement("canvas");
    canvas.width = TILE;
    canvas.height = TILE;
    const c = canvas.getContext("2d", { alpha: true });
    c.imageSmoothingEnabled = false;
    c.clearRect(0, 0, TILE, TILE);
    c.drawImage(img, 0, 0, TILE, TILE);
    const png = canvas.toDataURL("image/png");
    const category = normalizeCategory(spriteUploadCategory ? spriteUploadCategory.value : "undefined");
    const entry = {
      id: nextCustomTileId(),
      name: sanitizeTileName(file.name),
      category,
      source: "custom",
      w: TILE,
      h: TILE,
      png,
    };
    registerCustomTile(entry);
    setUploadStatus(`Uploaded ${entry.name} (${entry.id}).`, "success");
    queueDraftSave();
  }

  if (paletteContextMenu) {
    paletteContextMenu.addEventListener("click", (e) => {
      const button = e.target.closest("button[data-category]");
      if (!button || !paletteContextEntry) return;
      moveCustomTileToCategory(paletteContextEntry, button.getAttribute("data-category"));
      closePaletteContextMenu();
    });
  }
  document.addEventListener("mousedown", (e) => {
    if (!paletteContextMenu || !paletteContextMenu.classList.contains("open")) return;
    if (!paletteContextMenu.contains(e.target)) closePaletteContextMenu();
  });
  window.addEventListener("blur", () => {
    closePaletteContextMenu();
  });
  window.addEventListener("keydown", (e) => {
    if (e.code === "Escape") closePaletteContextMenu();
  });

  if (spriteUploadInput) {
    spriteUploadInput.addEventListener("change", () => {
      const file = spriteUploadInput.files && spriteUploadInput.files[0];
      spriteUploadInput.value = "";
      handleSpriteUpload(file);
    });
  }
  if (tilesheetUpload && tilesheetPreview) {
    tilesheetUpload.addEventListener("change", () => {
      if (!document.body.classList.contains("author")) {
        setTilesheetStatus("Author mode required.", "error");
        return;
      }
      const file = tilesheetUpload.files && tilesheetUpload.files[0];
      tilesheetUpload.value = "";
      if (!file) return;
      const ext = (file.name || "").toLowerCase().split(".").pop();
      const typeOk = ALLOWED_UPLOAD_TYPES.has(file.type) || ["png", "jpg", "jpeg"].includes(ext);
      if (!typeOk) {
        setTilesheetStatus("Only PNG or JPG files are allowed.", "error");
        return;
      }
      loadImageFromFile(file)
        .then((img) => {
          tilesheetState.image = img;
          tilesheetState.selection = null;
          setTilesheetStatus("Drag to select a region, then add it as 16x16.", "success");
          renderTilesheetPreview();
        })
        .catch(() => {
          setTilesheetStatus("Could not read image file.", "error");
        });
    });
    tilesheetPreview.addEventListener("mousedown", (e) => {
      if (!document.body.classList.contains("author")) return;
      if (!tilesheetState.image) return;
      const rect = tilesheetPreview.getBoundingClientRect();
      const pos = tilesheetCanvasToImage(e.clientX - rect.left, e.clientY - rect.top);
      if (!pos) return;
      tilesheetState.dragging = true;
      tilesheetState.dragStart = pos;
      tilesheetState.selection = { x: pos.x, y: pos.y, w: 1, h: 1 };
      renderTilesheetPreview();
    });
    window.addEventListener("mousemove", (e) => {
      if (!document.body.classList.contains("author")) return;
      if (!tilesheetState.dragging || !tilesheetState.dragStart) return;
      if (!tilesheetState.image) return;
      const rect = tilesheetPreview.getBoundingClientRect();
      const pos = tilesheetCanvasToImage(e.clientX - rect.left, e.clientY - rect.top);
      if (!pos) return;
      setTilesheetSelection(tilesheetState.dragStart, pos);
    });
    window.addEventListener("mouseup", () => {
      tilesheetState.dragging = false;
      tilesheetState.dragStart = null;
    });
  }
  if (tilesheetAddButton) {
    tilesheetAddButton.addEventListener("click", () => {
      if (!document.body.classList.contains("author")) {
        setTilesheetStatus("Author mode required.", "error");
        return;
      }
      if (!tilesheetState.image || !tilesheetState.selection) {
        setTilesheetStatus("Select a region first.", "error");
        return;
      }
      if (customTiles.length >= CUSTOM_TILE_LIMIT) {
        setTilesheetStatus("Custom tile limit reached.", "error");
        return;
      }
      const sel = tilesheetState.selection;
      if (sel.w < 1 || sel.h < 1) {
        setTilesheetStatus("Selection too small.", "error");
        return;
      }
      const canvas = document.createElement("canvas");
      canvas.width = TILE;
      canvas.height = TILE;
      const c = canvas.getContext("2d", { alpha: true });
      c.imageSmoothingEnabled = false;
      c.clearRect(0, 0, TILE, TILE);
      c.drawImage(
        tilesheetState.image,
        sel.x, sel.y, sel.w, sel.h,
        0, 0, TILE, TILE
      );
      const png = canvas.toDataURL("image/png");
      const entry = {
        id: nextCustomTileId(),
        name: `Tilesheet ${customTileCounter}`,
        category: "undefined",
        source: "custom",
        w: TILE,
        h: TILE,
        png,
      };
      registerCustomTile(entry);
      setTilesheetStatus(`Added ${entry.name}.`, "success");
      queueDraftSave();
    });
  }
  if (tilesheetClearButton) {
    tilesheetClearButton.addEventListener("click", () => {
      if (!document.body.classList.contains("author")) {
        setTilesheetStatus("Author mode required.", "error");
        return;
      }
      tilesheetState.selection = null;
      renderTilesheetPreview();
      setTilesheetStatus("Selection cleared.", "idle");
    });
  }
  if (publishLevelButton) {
    publishLevelButton.addEventListener("click", () => {
      publishDraftPayload();
    });
  }
  if (exportLevelButton) {
    exportLevelButton.addEventListener("click", () => {
      exportLevelPayload();
    });
  }
  if (importLevelButton && importLevelInput) {
    importLevelButton.addEventListener("click", () => {
      importLevelInput.click();
    });
  }
  if (importLevelInput) {
    importLevelInput.addEventListener("change", () => {
      const file = importLevelInput.files && importLevelInput.files[0];
      importLevelInput.value = "";
      if (file) importLevelPayload(file);
    });
  }
  if (resetLevelButton) {
    resetLevelButton.addEventListener("click", () => {
      resetLevelToGolden();
    });
  }
  const params = new URLSearchParams(location.search);
  const MP_ENABLED = params.get("mp") !== "0";
  // Default to shared lobby relay; override via ?mpUrl=ws://localhost:3001 for local dev
  const MP_SERVER = params.get("mpUrl") || "wss://ws.playfree.dev";
  const MP_ROOM = params.get("room") || "lobby";
  let PLAYER_NAME = (params.get("name") || `P${Math.floor(Math.random() * 900 + 100)}`).slice(0, 20);
  const STATE_SEND_INTERVAL = 0.05; // seconds
  const PEER_STALE_TIME = 6; // seconds
  const GRAVITY = 1400;      // px/s^2
  const MAX_FALL = 900;
  const WALK_ACCEL_CURVE = { high: 1700, low: 900 }; // higher out of standstill, softer near cap
  const RUN_ACCEL_CURVE = { high: 2200, low: 1200 };
  const FRICTION_DECEL = 1700;
  const BRAKE_DECEL = 2800;
  const AIR_ACCEL_SCALE = 0.55;
  const AIR_FRICTION_DECEL = 400;
  const AIR_BRAKE_DECEL = 750;
  const SKID_SPEED_THRESHOLD = 140;
  const SKID_TIME = 0.25;
  const SKID_ACCEL_SCALE = 0.25;
  const SKID_FRICTION_DECEL = 600;
  const SKID_BRAKE_DECEL = 1400;
  const SKID_DUST_INTERVAL = 0.06;
  const SKID_BOOST_AMOUNT = 0.1; // 10% max speed bump
  const SKID_BOOST_DECAY = 1.8;  // per second decay back to 0
  const WALK_MAX = 120;
  const RUN_MAX = 185;
  const P_SPEED_MAX = 240;
  const P_SPEED_CHARGE_TIME = 1.2; // seconds of run-hold to reach full P-speed
  const P_SPEED_ENTRY_SPEED = RUN_MAX - 8; // must be near run cap before charge progresses
  const P_SPEED_DECAY_RATE = 1.5; // how quickly P-speed charge drains when not qualifying
  const P_METER_SEGMENTS = 6;
  const P_METER_DECAY_DELAY = 0.12; // brief hold before the HUD meter drops a tier
  const JUMP_V = 420;
  const COYOTE_TIME = 0.08;  // seconds
  const JUMP_BUFFER = 0.1;   // seconds
  const HUD_TIMER_START = 300; // seconds
  const DAMAGE_INVULN_TIME = 1.0;
  const FIREBALL_COOLDOWN = 0.35; // seconds between shots
  const FIREBALL_SPEED = 320;
  const FIREBALL_GRAVITY = 900;
  const FIREBALL_BOUNCE_V = 340;
  const FIREBALL_LIFETIME = 3.5;
  const GLIDE_GRAVITY_SCALE = 0.35;
  const TAIL_SWING_TIME = 0.2;
  const TAIL_COOLDOWN = 0.6;
  const TAIL_RANGE_X = 18;
  const TAIL_RANGE_Y = 12;
  const FLIGHT_TIME = 2.6;
  const FLIGHT_LIFT = 180;
  const STATUE_DURATION = 2.5;
  const STATUE_COOLDOWN = 4.5;
  const STATUE_INVULN_TOPUP = 0.12;
  const WATER_GRAVITY_SCALE = 0.28;
  const WATER_MAX_FALL = 220;
  const WATER_SWIM_IMPULSE = 320;
  const FROG_LAND_ACCEL_SCALE = 0.7;
  const FROG_LAND_DECEL_SCALE = 0.65;
  const HAMMER_COOLDOWN = 0.3;
  const HAMMER_SPEED = 190;
  const HAMMER_GRAVITY = 1200;
  const HAMMER_LIFETIME = 0.9;
  const HAMMER_LAUNCH_ANGLE = (20 * Math.PI) / 180;
  const PowerUpForm = Object.freeze({
    Small: "small",
    Super: "super",
    Fire: "fire",
    Raccoon: "raccoon",
    Tanooki: "tanooki",
    Frog: "frog",
    Hammer: "hammer",
  });
  const BIG_FORMS = new Set([
    PowerUpForm.Super,
    PowerUpForm.Fire,
    PowerUpForm.Raccoon,
    PowerUpForm.Tanooki,
    PowerUpForm.Frog,
    PowerUpForm.Hammer,
  ]);
  const PLAYER_SAVE_KEY = "smb3-player-state";
  const SURFACE_MODS = {
    ice: { accel: 0.9, friction: 0.35, brake: 0.6 },
    sand: { accel: 0.65, friction: 1.35, brake: 1.15 },
  };

  // -----------------------------
  // Inventory UI (overlay)
  // -----------------------------
  const inventoryOverlay = document.getElementById("inventory-overlay");
  const inventoryGrid = document.getElementById("inventory-grid");
  const inventorySelected = document.getElementById("inventory-selected");
  const inventoryFooterHint = document.getElementById("inventory-footer-hint");
  const inventoryFeedback = document.createElement("div");
  inventoryFeedback.className = "inventory-hint";
  inventoryFeedback.id = "inventory-feedback";
  const settingsToggle = document.getElementById("settings-toggle");
  const settingsPanel = document.getElementById("settings-panel");

  const INVENTORY_COLS = 7;
  const INVENTORY_ROWS = 4;
  const INVENTORY_SLOTS = INVENTORY_COLS * INVENTORY_ROWS;

  // Demo data; replace with real inventory view model wiring.
  const inventorySlots = Array(INVENTORY_SLOTS).fill(null);
  inventorySlots[0] = { name: "Fire Flower", icon: "ðŸ”¥", count: 1, type: "fire-flower" };
  inventorySlots[1] = { name: "Super Leaf", icon: "ðŸ‚", count: 1, type: "super-leaf" };
  inventorySlots[2] = { name: "Hammer Suit", icon: "ðŸ”¨", count: 1, type: "hammer-suit" };
  inventorySlots[3] = { name: "Frog Suit", icon: "ðŸ¸", count: 1, type: "frog-suit" };

  let inventoryOpen = false;
  let inventoryCursor = 0;
  const slotEls = [];

  function setSettingsOpen(open) {
    if (!settingsPanel || !settingsToggle) return;
    settingsPanel.classList.toggle("open", open);
    settingsPanel.setAttribute("aria-hidden", open ? "false" : "true");
  }

  if (settingsToggle && settingsPanel) {
    settingsToggle.addEventListener("click", () => {
      setSettingsOpen(!settingsPanel.classList.contains("open"));
    });
    document.addEventListener("mousedown", (e) => {
      if (!settingsPanel.classList.contains("open")) return;
      if (settingsPanel.contains(e.target) || settingsToggle.contains(e.target)) return;
      setSettingsOpen(false);
    });
    window.addEventListener("keydown", (e) => {
      if (e.code === "Escape") setSettingsOpen(false);
    });
  }

  function buildInventoryGrid() {
    inventoryGrid.innerHTML = "";
    slotEls.length = 0;
    for (let i = 0; i < INVENTORY_SLOTS; i++) {
      const el = document.createElement("div");
      el.className = "inventory-slot empty";
      const icon = document.createElement("div");
      icon.className = "inventory-icon";
      const count = document.createElement("div");
      count.className = "inventory-count";
      el.appendChild(icon);
      el.appendChild(count);
    inventoryGrid.appendChild(el);
    slotEls.push({ el, icon, count });
  }
  inventoryGrid.insertAdjacentElement("afterend", inventoryFeedback);
  }

  function renderInventory() {
    inventoryOverlay.classList.toggle("open", inventoryOpen);
    inventorySelected.textContent = "--";
    inventoryFooterHint.textContent = "Use";
    inventoryFeedback.textContent = "";
    for (let i = 0; i < INVENTORY_SLOTS; i++) {
      const slot = inventorySlots[i];
      const { el, icon, count } = slotEls[i];
      const isSelected = i === inventoryCursor;
      if (slot) {
        el.className = "inventory-slot" + (isSelected ? " selected" : "");
        icon.textContent = slot.icon || "â—";
        count.textContent = slot.count > 1 ? `x${slot.count}` : "";
        if (isSelected) {
          inventorySelected.textContent = slot.name;
          inventoryFooterHint.textContent = "Use";
        }
      } else {
        el.className = "inventory-slot empty" + (isSelected ? " selected" : "");
        icon.textContent = "";
        count.textContent = "";
        if (isSelected) {
          inventorySelected.textContent = "(empty)";
          inventoryFooterHint.textContent = "Close";
        }
      }
    }
  }

  function moveInventoryCursor(dx, dy) {
    const col = inventoryCursor % INVENTORY_COLS;
    const row = Math.floor(inventoryCursor / INVENTORY_COLS);
    const nextCol = (col + dx + INVENTORY_COLS) % INVENTORY_COLS;
    const nextRow = (row + dy + INVENTORY_ROWS) % INVENTORY_ROWS;
    inventoryCursor = nextRow * INVENTORY_COLS + nextCol;
    renderInventory();
  }

  function toggleInventory(forceOpen) {
    const next = typeof forceOpen === "boolean" ? forceOpen : !inventoryOpen;
    inventoryOpen = next;
    renderInventory();
  }

  const inventoryUseHandlers = {
    "fire-flower": () => setPlayerForm(PowerUpForm.Fire),
    "super-leaf": () => setPlayerForm(PowerUpForm.Raccoon),
    "hammer-suit": () => setPlayerForm(PowerUpForm.Hammer),
    "frog-suit": () => setPlayerForm(PowerUpForm.Frog),
    mushroom: () => setPlayerForm(PowerUpForm.Super),
  };

  function useSelectedInventoryItem() {
    const slot = inventorySlots[inventoryCursor];
    if (!slot) {
      inventoryFeedback.textContent = "Empty slot";
      toggleInventory(false);
      return;
    }
    const handler = slot.type ? inventoryUseHandlers[slot.type] : null;
    if (handler) {
      handler();
      inventoryFeedback.textContent = `${slot.name} equipped`;
      if (slot.count && slot.count > 1) {
        slot.count -= 1;
      } else {
        inventorySlots[inventoryCursor] = null;
      }
      toggleInventory(false);
    } else {
      inventoryFeedback.textContent = `Cannot use ${slot.name}`;
      console.log("Cannot use item:", slot.name);
    }
  }

  function handleInventoryKey(e) {
    if (e.code === "KeyI") {
      toggleInventory();
      e.preventDefault();
      return true;
    }
    if (!inventoryOpen) return false;
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", "Space", "Escape"].includes(e.code)) {
      e.preventDefault();
      if (e.code === "ArrowUp") moveInventoryCursor(0, -1);
      else if (e.code === "ArrowDown") moveInventoryCursor(0, 1);
      else if (e.code === "ArrowLeft") moveInventoryCursor(-1, 0);
      else if (e.code === "ArrowRight") moveInventoryCursor(1, 0);
      else if (e.code === "Enter" || e.code === "Space") useSelectedInventoryItem();
      else if (e.code === "Escape") toggleInventory(false);
      return true;
    }
    return false;
  }

  buildInventoryGrid();
  renderInventory();

  // Precompute jump guide numbers (tiles traveled during a full jump)
  const jumpFlightTime = (2 * JUMP_V) / GRAVITY;
  const jumpWalkTiles = (WALK_MAX * jumpFlightTime) / TILE;
  const jumpRunTiles = (RUN_MAX * jumpFlightTime) / TILE;

  // -----------------------------
  // Input
  // -----------------------------
  const keys = new Set();
  const pressed = new Set();
  const chatInput = document.createElement("input");
  chatInput.type = "text";
  chatInput.maxLength = 200;
  chatInput.placeholder = "Enter chat (/name newname)";
  chatInput.style.position = "fixed";
  chatInput.style.left = "12px";
  chatInput.style.bottom = "12px";
  chatInput.style.width = "280px";
  chatInput.style.padding = "8px 10px";
  chatInput.style.border = "2px solid #000";
  chatInput.style.background = "#0f182a";
  chatInput.style.color = "#dfe7ff";
  chatInput.style.font = "12px 'Press Start 2P', 'VT323', monospace";
  chatInput.style.boxShadow = "inset 0 0 0 2px rgba(255,255,255,0.08)";
  chatInput.style.zIndex = "500";
  chatInput.style.display = "none";
  document.body.appendChild(chatInput);
  let authorPromptActive = false;
  const chatPlaceholderDefault = chatInput.placeholder;

  function toggleChatInput(show) {
    chatInput.style.display = show ? "block" : "none";
    if (show) {
      chatInput.value = "";
      chatInput.focus();
    } else {
      chatInput.blur();
    }
  }
  function beginAuthorPrompt() {
    authorPromptActive = true;
    chatInput.type = "password";
    chatInput.placeholder = "Author passphrase";
    chatInput.value = "";
    toggleChatInput(true);
    pushSystemChat("Enter author passphrase.");
  }
  function endAuthorPrompt() {
    authorPromptActive = false;
    chatInput.type = "text";
    chatInput.placeholder = chatPlaceholderDefault;
  }
  function submitAuthorPass(pass) {
    const raw = pass ?? "";
    endAuthorPrompt();
    toggleChatInput(false);
    if (!raw) {
      pushSystemChat("Author login cancelled.");
      return;
    }
    authorLogin(raw).then(({ ok, error }) => {
      pushSystemChat(ok ? "Author mode enabled." : formatAuthorError(error));
    });
  }
  window.addEventListener("keydown", (e) => {
    if (e.target && e.target.tagName === "INPUT" && e.target !== chatInput) return;
    if (e.target === chatInput) {
      if (e.code === "Escape") {
        if (authorPromptActive) endAuthorPrompt();
        toggleChatInput(false);
        e.preventDefault();
      } else if (e.code === "Enter") {
        if (authorPromptActive) {
          submitAuthorPass(chatInput.value);
          e.preventDefault();
          return;
        }
        const text = chatInput.value.trim();
        if (text.startsWith("/name")) {
          const next = text.replace("/name", "").trim().slice(0, 20);
          if (next) PLAYER_NAME = next;
        } else if (text.startsWith("/author")) {
          const keepOpen = handleAuthorCommand(text);
          chatInput.value = "";
          if (!keepOpen) toggleChatInput(false);
          e.preventDefault();
          return;
        } else {
          sendChat(text);
        }
        chatInput.value = "";
        toggleChatInput(false);
        e.preventDefault();
      }
      return;
    }
    // Open chat with Enter only if inventory is closed
    if (e.code === "Enter" && !inventoryOpen) {
      toggleChatInput(chatInput.style.display === "none");
      e.preventDefault();
      return;
    }
    if (handleInventoryKey(e)) return;
    if (editorOpen && handleEditorClipboard(e)) {
      e.preventDefault();
      return;
    }
    if (editorOpen && e.ctrlKey && e.code === "KeyZ") {
      e.preventDefault();
      undoAction();
      return;
    }
    if (editorOpen && e.ctrlKey && e.code === "KeyY") {
      e.preventDefault();
      redoAction();
      return;
    }
    if (e.code === "KeyE") {
      setEditorOpen(!editorOpen);
      e.preventDefault();
      return;
    }
    if (e.code === "KeyG") {
      showGrid = !showGrid;
      e.preventDefault();
      return;
    }
    if (!keys.has(e.code)) pressed.add(e.code);
    keys.add(e.code);
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
  }, { passive:false });

  window.addEventListener("keyup", (e) => {
    if (e.target && e.target.tagName === "INPUT") return;
    keys.delete(e.code);
  });

  // Clear keys when focus is lost to avoid stuck inputs causing auto actions
  window.addEventListener("blur", () => {
    keys.clear();
    pressed.clear();
  });

  const down = (code) => keys.has(code);
  const tap = (code) => pressed.has(code);

  // -----------------------------
  // Editor palette interactions
  // -----------------------------
  const terrainGrid = document.getElementById("terrain-grid");
  const objectGrid = document.getElementById("object-grid");
  const enemyGrid = document.getElementById("enemy-grid");
  const spawnGrid = document.getElementById("spawn-grid");
  const undefinedGrid = document.getElementById("undefined-grid");
  document.querySelectorAll(".editor-section h4").forEach((header) => {
    header.addEventListener("click", () => {
      const section = header.closest(".editor-section");
      if (!section) return;
      section.classList.toggle("collapsed");
    });
  });
  const labelInput = document.getElementById("editor-label-input");
  const textStampInput = document.getElementById("editor-text-stamp");
  const textStampButton = document.getElementById("editor-stamp-button");
  function updateStampButtonUI() {
    if (!textStampButton) return;
    textStampButton.classList.toggle("active", stampMode);
    textStampButton.textContent = stampMode ? "Stamp Mode ON" : "Stamp Mode OFF";
  }

  function updateLabelInput() {
    if (!labelInput) return;
    if (selectedCell) {
      const current = getLabel(selectedCell.tx, selectedCell.ty) || "";
      labelInput.value = current;
    } else {
      labelInput.value = "";
    }
  }

  function wirePaletteGrid(gridEl) {
    if (!gridEl) return;
    gridEl.querySelectorAll(".editor-tile").forEach(tileEl => {
      tileEl.addEventListener("click", () => {
        const tile = tileEl.getAttribute("data-tile") || "#";
        selectEditorTile(tile, tileEl);
      });
    });
  }

  wirePaletteGrid(terrainGrid);
  wirePaletteGrid(objectGrid);
  wirePaletteGrid(enemyGrid);
  wirePaletteGrid(spawnGrid);
  wirePaletteGrid(undefinedGrid);
  // default select ground
  const first = (terrainGrid || objectGrid || enemyGrid || spawnGrid || undefinedGrid)?.querySelector(".editor-tile");
  if (first) selectEditorTile(first.getAttribute("data-tile") || "#", first);
  if (labelInput) {
    // prevent global hotkeys from interfering while typing
    ["keydown", "keyup", "mousedown"].forEach(ev => {
      labelInput.addEventListener(ev, (e) => {
        e.stopPropagation();
      });
    });
    labelInput.addEventListener("input", () => {
      if (!selectedCell) return;
      const prevTile = getTile(selectedCell.tx, selectedCell.ty);
      const prevLabel = getLabel(selectedCell.tx, selectedCell.ty);
      const nextLabel = labelInput.value.trim();
      if (prevLabel === nextLabel) return;
      setLabel(selectedCell.tx, selectedCell.ty, nextLabel);
      broadcastEditChange(selectedCell.tx, selectedCell.ty, prevTile, nextLabel);
      recordAction([{
        tx: selectedCell.tx, ty: selectedCell.ty,
        prevTile, prevLabel,
        nextTile: prevTile, nextLabel,
      }]);
    });
    updateLabelInput();
  }
  if (textStampInput) {
    ["keydown", "keyup", "mousedown"].forEach(ev => {
      textStampInput.addEventListener(ev, (e) => {
        e.stopPropagation();
      });
    });
  }
  if (textStampButton) {
    textStampButton.addEventListener("click", () => {
      stampMode = !stampMode;
      updateStampButtonUI();
    });
    updateStampButtonUI();
  }
  renderPalettePreviews();
  loadBuiltinTileManifest();

  function setSelection(tx, ty) {
    ensureBounds(tx, ty);
    selectedCell = { tx, ty };
    updateLabelInput();
  }

  function recordAction(changes) {
    if (!changes || changes.length === 0) return;
    undoStack.push(changes);
    redoStack.length = 0;
    queueDraftSave();
  }

  function applyChanges(changes, useNext=true) {
    for (const c of changes) {
      if (c.prevTile === undefined && c.nextTile === undefined && c.prevLabel === undefined && c.nextLabel === undefined) continue;
      if (useNext) {
        if (c.nextTile !== undefined) setTileRaw(c.tx, c.ty, c.nextTile);
        if (c.nextLabel !== undefined) setLabelRaw(c.tx, c.ty, c.nextLabel);
        broadcastEditChange(c.tx, c.ty, c.nextTile, c.nextLabel);
      } else {
        if (c.prevTile !== undefined) setTileRaw(c.tx, c.ty, c.prevTile);
        if (c.prevLabel !== undefined) setLabelRaw(c.tx, c.ty, c.prevLabel);
        broadcastEditChange(c.tx, c.ty, c.prevTile, c.prevLabel);
      }
    }
    queueDraftSave();
  }

  function undoAction() {
    if (undoStack.length === 0) return;
    const changes = undoStack.pop();
    applyChanges(changes, false);
    redoStack.push(changes);
    updateLabelInput();
  }

  function redoAction() {
    if (redoStack.length === 0) return;
    const changes = redoStack.pop();
    applyChanges(changes, true);
    undoStack.push(changes);
    updateLabelInput();
  }

  function drawTilePreview(ctx, t) {
    ctx.imageSmoothingEnabled = false;
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    const custom = tileRegistry.get(t);
    if (custom && custom.image && custom.image.complete) {
      ctx.drawImage(custom.image, 0, 0, w, h);
      return;
    }
    if (t === "#") {
      ctx.fillStyle = "#3b2f2f";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#2a2020";
      ctx.fillRect(0, h - Math.ceil(h * 0.25), w, Math.ceil(h * 0.25));
      ctx.fillStyle = "#4a3a3a";
      ctx.fillRect(0, 0, w, Math.max(1, Math.round(h * 0.15)));
      return;
    }
    if (t === "S") {
      ctx.fillStyle = "#d8c28f";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#b89f6b";
      ctx.fillRect(0, h - Math.ceil(h * 0.3), w, Math.ceil(h * 0.3));
      ctx.fillStyle = "#f7e7b8";
      ctx.fillRect(0, 0, w, Math.max(1, Math.round(h * 0.2)));
      return;
    }
    if (t === "I") {
      ctx.fillStyle = "#b0e0ff";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#d8f4ff";
      ctx.fillRect(0, 0, w, Math.max(1, Math.round(h * 0.2)));
      ctx.fillStyle = "#8bbbd6";
      ctx.fillRect(0, h - Math.ceil(h * 0.25), w, Math.ceil(h * 0.25));
      return;
    }
    if (t === "B") {
      ctx.fillStyle = "#7c3f2a";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(0, 1, w, 1);
      ctx.fillRect(0, Math.max(1, Math.floor(h / 2)), w, 1);
      ctx.fillRect(Math.floor(w / 2), 0, 1, h);
      return;
    }
    if (t === "?") {
      ctx.fillStyle = "#d1a23a";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#8a6a18";
      ctx.fillRect(0, h - Math.ceil(h * 0.25), w, Math.ceil(h * 0.25));
      ctx.fillStyle = "#fff2";
      ctx.fillRect(0, 0, w, Math.max(1, Math.round(h * 0.2)));
      ctx.fillStyle = "#2b1d05";
      ctx.fillRect(Math.floor(w/2) - 1, Math.floor(h/2) - 1, 2, 2);
      return;
    }
    if (t === "u") {
      ctx.fillStyle = "#8c8c8c";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#0002";
      ctx.fillRect(0, h - Math.ceil(h * 0.25), w, Math.ceil(h * 0.25));
      return;
    }
    if (t === "C") {
      ctx.fillStyle = "#0b1629";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#f5d000";
      ctx.fillRect(Math.floor(w/2) - 1, 1, 2, h - 2);
      ctx.fillRect(Math.floor(w/2) - 2, Math.floor(h/2) - 1, 4, 2);
      ctx.fillStyle = "#fff5";
      ctx.fillRect(Math.floor(w/2), 1, 1, 2);
      return;
    }
    if (t === "E") {
      ctx.fillStyle = "#0b1629";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#6b3b2a";
      ctx.fillRect(1, 1, w-2, h-2);
      ctx.fillStyle = "#000";
      ctx.fillRect(2, Math.floor(h/2), w-4, 1);
      return;
    }
    if (t === "P") {
      ctx.fillStyle = "#0b1629";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "#2a49ff";
      ctx.fillRect(2, 2, w-4, h-4);
      ctx.fillStyle = "#f00";
      ctx.fillRect(2, 0, w-4, 2);
      return;
    }
  }

  function stampText(raw) {
    if (!selectedCell || !raw) return;
    const startX = selectedCell.tx;
    const startY = selectedCell.ty;
    const text = raw.toUpperCase();
    let cursorX = startX;
    const changes = [];
    for (const ch of text) {
      const glyph = TEXT_FONT[ch] || TEXT_FONT["?"];
      const glyphW = glyph[0].length;
      for (let y = 0; y < glyph.length; y++) {
        for (let x = 0; x < glyphW; x++) {
          if (glyph[y][x] === "1") {
            const tx = cursorX + x;
            const ty = startY + y;
            const prevTile = getTile(tx, ty);
            const prevLabel = getLabel(tx, ty);
            if (prevTile === editorTile) continue;
            setTile(tx, ty, editorTile);
            changes.push({
              tx, ty,
              prevTile, prevLabel,
              nextTile: editorTile,
              nextLabel: prevLabel,
            });
          }
        }
      }
      cursorX += glyphW + 1; // 1 tile gap
    }
    recordAction(changes);
  }

  function renderPalettePreviews() {
    document.querySelectorAll(".tile-preview").forEach(canvasEl => {
      const t = canvasEl.getAttribute("data-tile") || "#";
      const ctx = canvasEl.getContext("2d", { alpha: false });
      ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
      drawTilePreview(ctx, t);
    });
  }

  function screenToCell(screenX, screenY, fromEvent=false, evt=null) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const px = (fromEvent && evt ? evt.offsetX : (screenX - rect.left)) * scaleX;
    const py = (fromEvent && evt ? evt.offsetY : (screenY - rect.top)) * scaleY;
    const worldX = px + cam.x;
    const worldY = py + cam.y;
    return { tx: Math.floor(worldX / TILE), ty: Math.floor(worldY / TILE) };
  }

  function applyEditorPaint(screenX, screenY, remove=false) {
    if (!editorOpen) return;
    const cell = screenToCell(screenX, screenY);
    if (!cell) return;
    const prevTile = getTile(cell.tx, cell.ty);
    const prevLabel = getLabel(cell.tx, cell.ty);
    ensureBounds(cell.tx, cell.ty);
    setSelection(cell.tx, cell.ty);
    const nextTile = remove ? "." : editorTile;
    if (prevTile === nextTile) return;
    setTile(cell.tx, cell.ty, nextTile);
    broadcastEditChange(cell.tx, cell.ty, nextTile, prevLabel);
    recordAction([{
      tx: cell.tx, ty: cell.ty,
      prevTile, prevLabel,
      nextTile, nextLabel: prevLabel,
    }]);
  }

  let paintingButton = null;
  canvas.addEventListener("mousedown", (e) => {
    if (!editorOpen) return;
    const cell = screenToCell(e.clientX, e.clientY, true, e);
    if (cell) setSelection(cell.tx, cell.ty);
    if (cell) {
      const sx = Math.floor(cell.tx * TILE - cam.x);
      const sy = Math.floor(cell.ty * TILE - cam.y);
      clickDebug = { sx, sy, tx: cell.tx, ty: cell.ty, timer: 0.5 };
    }
    if (stampMode && e.button === 0) {
      e.preventDefault();
      stampText(textStampInput ? textStampInput.value : "");
      return;
    }
    if (e.button === 0 || e.button === 2) {
      e.preventDefault();
      paintingButton = e.button;
      applyEditorPaint(e.clientX, e.clientY, e.button === 2);
    }
  });
  canvas.addEventListener("mousemove", (e) => {
    if (!editorOpen) return;
    const cell = screenToCell(e.clientX, e.clientY, true, e);
    hoverCell = (cell && inBounds(cell.tx, cell.ty)) ? cell : null;
    if (paintingButton !== null) {
      applyEditorPaint(e.clientX, e.clientY, paintingButton === 2);
    }
  });
  canvas.addEventListener("mouseup", () => {
    paintingButton = null;
  });
  canvas.addEventListener("mouseleave", () => {
    paintingButton = null;
    hoverCell = null;
  });
  canvas.addEventListener("contextmenu", (e) => {
    if (!editorOpen) return;
    e.preventDefault();
  });

  function handleEditorClipboard(e) {
    if (!editorOpen || !selectedCell) return false;
    const { tx, ty } = selectedCell;
    const tile = getTile(tx, ty);
    const hasTile = tile && tile !== ".";
    if (e.code === "KeyC" && e.ctrlKey) {
      if (hasTile) editorClipboard = tile;
      return true;
    }
    if (e.code === "KeyX" && e.ctrlKey) {
      if (hasTile) editorClipboard = tile;
      const prevLabel = getLabel(tx, ty);
      setTile(tx, ty, ".");
      recordAction([{
        tx, ty,
        prevTile: tile, prevLabel,
        nextTile: ".", nextLabel: prevLabel,
      }]);
      return true;
    }
    if (e.code === "KeyV" && e.ctrlKey) {
      if (editorClipboard) {
        const prevLabel = getLabel(tx, ty);
        const prevTile = getTile(tx, ty);
        setTile(tx, ty, editorClipboard);
        recordAction([{
          tx, ty,
          prevTile, prevLabel,
          nextTile: editorClipboard,
          nextLabel: prevLabel,
        }]);
      }
      return true;
    }
    return false;
  }

  // -----------------------------
  // Level
  // Legend:
  //  . empty
  //  # solid ground
  //  B solid brick
  //  I ice (slippery)
  //  S sand (heavy)
  //  W water (swimmable)
  //  ? question block
  //  u used block
  //  C coin (pickup, not solid)
  //  E enemy spawn
  //  P player spawn
  // -----------------------------
  const LEVEL = [
    "................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "......................C.............?...........C...............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "..............?............................?....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    ".............BBB.........................BBB....................C...............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    ".....................................................E..........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "....P......................IIIIII...............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "########################SSSSSS############################.....#################................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................",
    "########################SSSSSS############################.....#################................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................"
  ];

  let mapH = LEVEL.length;
  let mapW = LEVEL[0].length;
  const tiles = LEVEL.map(row => row.split(""));
  const labelMap = new Map(); // key: "tx,ty" -> string
  let worldWpx = mapW * TILE;
  let worldHpx = mapH * TILE;
  const GOLDEN_PAYLOAD = {
    version: PAYLOAD_VERSION,
    map: {
      width: mapW,
      height: mapH,
      grid: LEVEL.map(row => row.split("")),
    },
    labels: [],
    customTiles: [],
  };

  function cloneGrid(grid) {
    return grid.map(row => row.slice());
  }

  function serializeLabels() {
    const out = [];
    for (const [key, text] of labelMap.entries()) {
      if (!text) continue;
      const parts = key.split(",");
      const tx = Number(parts[0]);
      const ty = Number(parts[1]);
      if (!Number.isFinite(tx) || !Number.isFinite(ty)) continue;
      out.push({ tx, ty, text: String(text).slice(0, 24) });
    }
    return out;
  }

  function buildLevelPayload() {
    return {
      version: PAYLOAD_VERSION,
      map: {
        width: mapW,
        height: mapH,
        grid: cloneGrid(tiles),
      },
      labels: serializeLabels(),
      customTiles: customTiles.map((entry) => ({
        id: entry.id,
        name: entry.name,
        category: normalizeCategory(entry.category),
        w: entry.w || TILE,
        h: entry.h || TILE,
        png: entry.png,
      })),
    };
  }

  function normalizeGrid(raw) {
    if (!raw) return null;
    let grid = raw.grid;
    if (!grid && Array.isArray(raw.rows)) grid = raw.rows;
    if (!Array.isArray(grid) || grid.length === 0) return null;
    if (typeof grid[0] === "string") {
      grid = grid.map(row => String(row).split(""));
    }
    if (!Array.isArray(grid[0])) return null;
    const cleaned = grid.map(row => row.map(cell => (typeof cell === "string" ? cell : ".")));
    const width = Math.max(1, ...cleaned.map(row => row.length));
    const normalized = cleaned.map(row => {
      if (row.length < width) return row.concat(new Array(width - row.length).fill("."));
      if (row.length > width) return row.slice(0, width);
      return row;
    });
    return { grid: normalized, width, height: normalized.length };
  }

  function normalizeLabels(raw) {
    if (!Array.isArray(raw)) return [];
    const out = [];
    for (const item of raw) {
      if (!item || typeof item !== "object") continue;
      const tx = Number(item.tx);
      const ty = Number(item.ty);
      if (!Number.isFinite(tx) || !Number.isFinite(ty)) continue;
      const text = String(item.text || "").trim();
      if (!text) continue;
      out.push({ tx, ty, text: text.slice(0, 24) });
    }
    return out;
  }

  function normalizeCustomTiles(raw) {
    if (!raw) return { ok: true, tiles: [] };
    if (!Array.isArray(raw)) return { ok: false, error: "Invalid custom tiles." };
    if (raw.length > CUSTOM_TILE_LIMIT) {
      return { ok: false, error: "Too many custom tiles." };
    }
    const out = [];
    const seen = new Set();
    for (const item of raw) {
      if (!item || typeof item !== "object") continue;
      const id = String(item.id || "");
      if (!id.startsWith("custom:")) {
        return { ok: false, error: "Custom tile id must start with custom:." };
      }
      if (seen.has(id)) {
        return { ok: false, error: "Duplicate custom tile id." };
      }
      const png = String(item.png || "");
      if (!png.startsWith("data:image/")) {
        return { ok: false, error: "Custom tile PNG is invalid." };
      }
      const size = estimateDataUrlBytes(png);
      if (size <= 0) {
        return { ok: false, error: "Custom tile PNG is invalid." };
      }
      if (size > MAX_UPLOAD_BYTES) {
        return { ok: false, error: "Custom tile PNG is too large." };
      }
      const category = normalizeCategory(item.category);
      const name = sanitizeTileName(item.name || "Custom");
      out.push({
        id,
        name,
        category,
        source: "custom",
        w: TILE,
        h: TILE,
        png,
      });
      seen.add(id);
    }
    return { ok: true, tiles: out };
  }

  function normalizePayload(raw) {
    if (!raw || typeof raw !== "object") return { ok: false, error: "Invalid payload." };
    const gridInfo = normalizeGrid(raw.map || raw);
    if (!gridInfo) return { ok: false, error: "Invalid map grid." };
    const labels = normalizeLabels(raw.labels);
    const customTilesResult = normalizeCustomTiles(raw.customTiles || []);
    if (!customTilesResult.ok) return customTilesResult;
    const customIds = new Set(customTilesResult.tiles.map(tile => tile.id));
    for (const row of gridInfo.grid) {
      for (const cell of row) {
        if (typeof cell === "string" && cell.startsWith("custom:") && !customIds.has(cell)) {
          return { ok: false, error: "Map references missing custom tile." };
        }
      }
    }
    return {
      ok: true,
      payload: {
        version: Number(raw.version) || PAYLOAD_VERSION,
        map: {
          width: gridInfo.width,
          height: gridInfo.height,
          grid: gridInfo.grid,
        },
        labels,
        customTiles: customTilesResult.tiles,
      },
    };
  }

  function applyLevelPayload(payload, options = {}) {
    if (!payload || !payload.map || !payload.map.grid) return;
    const { resetPlayer = false } = options;
    mapH = payload.map.grid.length;
    mapW = payload.map.width || (payload.map.grid[0] ? payload.map.grid[0].length : 0);
    tiles.length = 0;
    payload.map.grid.forEach(row => tiles.push(row.slice()));
    updateWorldSize();
    labelMap.clear();
    (payload.labels || []).forEach((label) => {
      if (!Number.isFinite(label.tx) || !Number.isFinite(label.ty)) return;
      if (!label.text) return;
      labelMap.set(labelKey(label.tx, label.ty), String(label.text));
    });
    loadCustomTiles(payload.customTiles || []);
    const selectedEl = document.querySelector(`.editor-tile[data-tile="${editorTile}"]`);
    if (!selectedEl) {
      const fallback = document.querySelector(".editor-tile");
      if (fallback) selectEditorTile(fallback.getAttribute("data-tile") || "#", fallback);
    }
    updateSpawnFromTiles();
    if (resetPlayer && typeof resetPlayerToSpawn === "function") {
      resetPlayerToSpawn();
    }
    if (typeof updateLabelInput === "function") {
      updateLabelInput();
    }
  }

  function getStoredPayload(key) {
    if (typeof localStorage === "undefined") return null;
    const raw = localStorage.getItem(key);
    if (!raw) return null;
    try {
      const data = JSON.parse(raw);
      const normalized = normalizePayload(data);
      if (!normalized.ok) {
        localStorage.removeItem(key);
        return null;
      }
      return normalized.payload;
    } catch (err) {
      localStorage.removeItem(key);
      return null;
    }
  }

  function saveDraftPayload() {
    if (typeof localStorage === "undefined") return;
    try {
      const payload = buildLevelPayload();
      localStorage.setItem(DRAFT_PAYLOAD_KEY, JSON.stringify(payload));
    } catch (err) {
      // ignore persistence errors
    }
  }

  let draftSaveTimer = null;
  function queueDraftSave() {
    if (draftSaveTimer) clearTimeout(draftSaveTimer);
    draftSaveTimer = setTimeout(() => {
      saveDraftPayload();
      draftSaveTimer = null;
    }, 300);
  }

  function publishDraftPayload() {
    if (typeof localStorage === "undefined") return;
    try {
      const payload = buildLevelPayload();
      localStorage.setItem(PUBLISHED_PAYLOAD_KEY, JSON.stringify(payload));
      localStorage.removeItem(DRAFT_PAYLOAD_KEY);
      if (draftSaveTimer) {
        clearTimeout(draftSaveTimer);
        draftSaveTimer = null;
      }
      setUploadStatus("Published draft locally. Export to share.", "success");
    } catch (err) {
      setUploadStatus("Publish failed.", "error");
    }
  }

  function exportLevelPayload() {
    const payload = buildLevelPayload();
    const data = JSON.stringify(payload, null, 2);
    const blob = new Blob([data], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "playfree-level.json";
    document.body.appendChild(link);
    link.click();
    link.remove();
    URL.revokeObjectURL(url);
    setUploadStatus("Exported level JSON.", "success");
  }

  async function importLevelPayload(file) {
    try {
      const text = await file.text();
      const data = JSON.parse(text);
      const normalized = normalizePayload(data);
      if (!normalized.ok) {
        setUploadStatus(normalized.error || "Import failed.", "error");
        return;
      }
      applyLevelPayload(normalized.payload, { resetPlayer: true });
      queueDraftSave();
      setUploadStatus("Imported level JSON.", "success");
    } catch (err) {
      setUploadStatus("Import failed: invalid JSON.", "error");
    }
  }

  function resetLevelToGolden() {
    if (typeof localStorage !== "undefined") {
      localStorage.removeItem(DRAFT_PAYLOAD_KEY);
    }
    if (draftSaveTimer) {
      clearTimeout(draftSaveTimer);
      draftSaveTimer = null;
    }
    const published = getStoredPayload(PUBLISHED_PAYLOAD_KEY);
    const base = published || JSON.parse(JSON.stringify(GOLDEN_PAYLOAD));
    applyLevelPayload(base, { resetPlayer: true });
    pushSystemChat("Level reset to original.");
  }

  function loadInitialPayload() {
    const published = getStoredPayload(PUBLISHED_PAYLOAD_KEY);
    const draft = getStoredPayload(DRAFT_PAYLOAD_KEY);
    const base = draft || published || JSON.parse(JSON.stringify(GOLDEN_PAYLOAD));
    applyLevelPayload(base);
  }

  function ensureBounds(tx, ty) {
    let grew = false;
    let grewX = false;
    while (ty >= tiles.length) {
      tiles.push(new Array(mapW).fill("."));
      grew = true;
    }
    if (grew) mapH = tiles.length;
    if (tx >= mapW) {
      const add = tx - mapW + 1;
      for (const row of tiles) {
        for (let i = 0; i < add; i++) row.push(".");
      }
      mapW = tiles[0].length;
      grewX = true;
    }
    if (grew || grewX) updateWorldSize();
  }

  function inBounds(tx, ty) { return tx >= 0 && ty >= 0 && tx < mapW && ty < mapH; }

  function getTile(tx, ty) {
    if (!inBounds(tx, ty)) return "#"; // treat out-of-bounds as solid wall
    return tiles[ty][tx];
  }
  function setTileRaw(tx, ty, v) {
    ensureBounds(tx, ty);
    tiles[ty][tx] = v;
  }
  function setTile(tx, ty, v) {
    setTileRaw(tx, ty, v);
  }
  function labelKey(tx, ty) { return `${tx},${ty}`; }
  function getLabel(tx, ty) {
    return labelMap.get(labelKey(tx, ty));
  }
  function setLabelRaw(tx, ty, text) {
    const key = labelKey(tx, ty);
    if (!text) {
      labelMap.delete(key);
    } else {
      labelMap.set(key, text);
    }
  }
  function setLabel(tx, ty, text) {
    setLabelRaw(tx, ty, text);
  }
  function isSolid(t) { return t === "#" || t === "B" || t === "?" || t === "u" || t === "I" || t === "S"; }
  function isQuestion(t){ return t === "?"; }
  function isCoinTile(t){ return t === "C"; }
  function surfaceType(t) {
    if (t === "I") return "ice";
    if (t === "S") return "sand";
    return null;
  }

  function isWaterTile(t) {
    return t === "W";
  }

  // Find spawns
  function findChar(ch) {
    for (let y = 0; y < mapH; y++) {
      for (let x = 0; x < mapW; x++) {
        if (tiles[y][x] === ch) return { x, y };
      }
    }
    return null;
  }

  const playerSpawn = { x: 2, y: 2 };

  function updateSpawnFromTiles() {
    const found = findChar("P");
    if (found) {
      playerSpawn.x = found.x;
      playerSpawn.y = found.y;
    } else {
      playerSpawn.x = 2;
      playerSpawn.y = 2;
    }
    for (let y = 0; y < mapH; y++) {
      for (let x = 0; x < mapW; x++) {
        if (tiles[y][x] === "P") tiles[y][x] = ".";
      }
    }
  }

  loadInitialPayload();

  // Entities
  const entities = [];
  const particles = [];
  const peers = new Map(); // peerId -> state snapshot for rendering
  const chatLog = [];
  const chatMax = 30;
  let chatVisibleTime = 0;
  function pushSystemChat(text) {
    if (!text) return;
    chatLog.push({ name: "SYSTEM", text, ts: Date.now(), seq: chatLog.length });
    while (chatLog.length > chatMax) chatLog.shift();
    chatVisibleTime = 6;
  }
  const tagLayer = document.createElement("div");
  tagLayer.style.position = "fixed";
  tagLayer.style.left = "0";
  tagLayer.style.top = "0";
  tagLayer.style.width = "100%";
  tagLayer.style.height = "100%";
  tagLayer.style.pointerEvents = "none";
  tagLayer.style.zIndex = "400";
  document.body.appendChild(tagLayer);
  let netSocket = null;
  let clientId = null;
  let reconnectTimer = 0;
  let stateSendTimer = STATE_SEND_INTERVAL;
  let audioCtx = null;

  function playSkidSound() {
    try {
      if (!audioCtx) audioCtx = new AudioContext();
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "square";
      osc.frequency.setValueAtTime(320, now);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.08);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.09);
    } catch (e) {
      // ignore audio init errors (e.g., autoplay restrictions)
    }
  }

  function playFireballSound() {
    try {
      if (!audioCtx) audioCtx = new AudioContext();
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "square";
      osc.frequency.setValueAtTime(520, now);
      gain.gain.setValueAtTime(0.06, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.2);
    } catch (e) {
      // ignore audio init errors
    }
  }

  function playTailSound() {
    try {
      if (!audioCtx) audioCtx = new AudioContext();
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(280, now);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.14);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.16);
    } catch (e) {
      // ignore audio init errors
    }
  }

  function playHammerSound() {
    try {
      if (!audioCtx) audioCtx = new AudioContext();
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "square";
      osc.frequency.setValueAtTime(340, now);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.2);
    } catch (e) {
      // ignore audio init errors
    }
  }

  function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  const mix = (a, b, t) => a + (b - a) * t;
  function isOnGround(body) {
    // Check for solid tiles just below the feet with a 1px tolerance
    const footY = body.y + body.h + 1;
    const ty = Math.floor(footY / TILE);
    const x0 = Math.floor(body.x / TILE);
    const x1 = Math.floor((body.x + body.w - 1) / TILE);
    for (let tx = x0; tx <= x1; tx++) {
      if (isSolid(getTile(tx, ty))) return true;
    }
    return false;
  }

  // -----------------------------
  // Multiplayer (client)
  // -----------------------------
  function openSocket() {
    try {
      netSocket = new WebSocket(MP_SERVER);
    } catch (err) {
      netSocket = null;
      reconnectTimer = 1.5;
      return;
    }

    netSocket.addEventListener("open", () => {
      stateSendTimer = STATE_SEND_INTERVAL;
      netSocket.send(JSON.stringify({ type: "join", room: MP_ROOM, name: PLAYER_NAME }));
    });

    netSocket.addEventListener("message", (ev) => handleNetMessage(ev.data));

    const handleClose = () => {
      clientId = null;
      netSocket = null;
      reconnectTimer = 1.5;
    };
    netSocket.addEventListener("close", handleClose);
    netSocket.addEventListener("error", handleClose);
  }

  function handleNetMessage(raw) {
    let msg;
    try {
      msg = JSON.parse(raw);
    } catch (e) {
      return;
    }
    if (msg.type === "welcome") {
      clientId = msg.id || null;
      if (Array.isArray(msg.players)) {
        for (const p of msg.players) {
          recordPeerState(p.id, p, p.name);
        }
      }
      if (Array.isArray(msg.tiles)) {
        for (const t of msg.tiles) {
          if (typeof t.tx === "number" && typeof t.ty === "number") {
            setTile(t.tx, t.ty, t.value ?? ".");
          }
        }
      }
      if (Array.isArray(msg.labels)) {
        for (const t of msg.labels) {
          if (typeof t.tx === "number" && typeof t.ty === "number") {
            setLabel(t.tx, t.ty, t.label ?? "");
          }
        }
      }
      return;
    }
    if (msg.type === "state" && msg.id && msg.state) {
      recordPeerState(msg.id, msg.state, msg.name);
      return;
    }
    if (msg.type === "chat" && typeof msg.text === "string") {
      chatLog.push({ name: msg.name || "Player", text: msg.text, ts: msg.ts || Date.now(), seq: msg.seq || chatLog.length });
      while (chatLog.length > chatMax) chatLog.shift();
      chatVisibleTime = 6;
      return;
    }
    if (msg.type === "leave" && msg.id) {
      peers.delete(msg.id);
      return;
    }
    if (msg.type === "tile" && typeof msg.tx === "number" && typeof msg.ty === "number") {
      setTile(msg.tx, msg.ty, msg.value ?? ".");
    }
    if (msg.type === "edit" && typeof msg.tx === "number" && typeof msg.ty === "number") {
      if (msg.value !== undefined) setTile(msg.tx, msg.ty, msg.value ?? ".");
      if (msg.label !== undefined) setLabel(msg.tx, msg.ty, msg.label ?? "");
    }
  }

  function recordPeerState(id, state, name) {
    if (!id || id === clientId) return;
    const now = performance.now();
    const incomingForm = isValidForm(state.form) ? state.form : null;
    const incomingBig = incomingForm ? formIsBig(incomingForm) : !!state.big;
    const incomingCoins = Number.isFinite(state.coins) ? state.coins : 0;
    const incomingScore = Number.isFinite(state.score) ? state.score : 0;
    const incomingLives = Number.isFinite(state.lives) ? state.lives : 3;
    const incomingTimer = Number.isFinite(state.timer) ? state.timer : HUD_TIMER_START;
    let peer = peers.get(id);
    if (!peer) {
      peer = {
        x: state.x ?? 0,
        y: state.y ?? 0,
        targetX: state.x ?? 0,
        targetY: state.y ?? 0,
        facing: state.facing || 1,
        form: incomingForm ?? (incomingBig ? PowerUpForm.Super : PowerUpForm.Small),
        big: incomingBig,
        name: name || `P-${String(id).slice(0, 4)}`,
        state: state.state || "ground",
        coins: incomingCoins,
        score: incomingScore,
        lives: incomingLives,
        timer: incomingTimer,
        lastSeen: now,
      };
      peers.set(id, peer);
    } else {
      peer.targetX = state.x ?? peer.targetX;
      peer.targetY = state.y ?? peer.targetY;
      peer.facing = state.facing || peer.facing || 1;
      if (incomingForm) peer.form = incomingForm;
      if (!peer.form) peer.form = incomingBig ? PowerUpForm.Super : PowerUpForm.Small;
      peer.big = incomingForm ? formIsBig(incomingForm) : (incomingBig || peer.big);
      peer.state = state.state || peer.state || "ground";
      if (name) peer.name = name;
      peer.coins = incomingCoins;
      peer.score = incomingScore;
      peer.lives = incomingLives;
      peer.timer = incomingTimer;
      peer.lastSeen = now;
    }
    if (peer.x === undefined) peer.x = peer.targetX;
    if (peer.y === undefined) peer.y = peer.targetY;
  }

  function broadcastEditChange(tx, ty, value, label) {
    if (!MP_ENABLED || !netSocket || netSocket.readyState !== WebSocket.OPEN) return;
    const msg = { type: "edit", room: MP_ROOM, tx, ty };
    if (value !== undefined) msg.value = value;
    if (label !== undefined) msg.label = label;
    netSocket.send(JSON.stringify(msg));
  }

  function sendPlayerState() {
    if (!MP_ENABLED || !netSocket || netSocket.readyState !== WebSocket.OPEN) return;
    const payload = {
      type: "state",
      room: MP_ROOM,
      name: PLAYER_NAME,
      state: {
        x: player.x,
        y: player.y,
        vx: player.vx,
        vy: player.vy,
        facing: player.facing,
        big: player.big,
        form: player.form,
        state: player.state,
        coins: coinCount,
        score: score,
        lives: lives,
        timer: levelTimer,
      },
    };
    netSocket.send(JSON.stringify(payload));
  }

  function sendChat(text) {
    if (!MP_ENABLED || !netSocket || netSocket.readyState !== WebSocket.OPEN) return;
    if (!text || !text.trim()) return;
    netSocket.send(JSON.stringify({ type: "chat", room: MP_ROOM, name: PLAYER_NAME, text: text.slice(0, 200) }));
  }

  function smoothPeers(dt) {
    for (const peer of peers.values()) {
      if (peer.targetX === undefined || peer.targetY === undefined) continue;
      const lerp = Math.min(1, dt * 10);
      peer.x = peer.x + (peer.targetX - peer.x) * lerp;
      peer.y = peer.y + (peer.targetY - peer.y) * lerp;
    }
  }

  function updateNetwork(dt) {
    if (!MP_ENABLED) return;
    if (!netSocket) {
      if (reconnectTimer > 0) reconnectTimer -= dt;
      if (reconnectTimer <= 0) openSocket();
      return;
    }
    if (netSocket.readyState === WebSocket.OPEN) {
      stateSendTimer -= dt;
      if (stateSendTimer <= 0) {
        stateSendTimer = STATE_SEND_INTERVAL;
        sendPlayerState();
      }
    }
    const now = performance.now();
    for (const [id, peer] of peers.entries()) {
      if (now - peer.lastSeen > PEER_STALE_TIME * 1000) peers.delete(id);
    }
    smoothPeers(dt);
  }

  // -----------------------------
  // Tile collision
  // -----------------------------
  function moveAndCollide(body, dt) {
    // body: {x,y,w,h,vx,vy,onGround,hitHead}
    body.onGround = false;
    body.hitHead = false;

    // Horizontal
    body.x += body.vx * dt;
    if (body.vx !== 0) {
      const dir = Math.sign(body.vx);
      const aheadX = dir > 0 ? body.x + body.w : body.x;
      const tx = Math.floor(aheadX / TILE);

      const y0 = Math.floor(body.y / TILE);
      const y1 = Math.floor((body.y + body.h - 1) / TILE);

      for (let ty = y0; ty <= y1; ty++) {
        const t = getTile(tx, ty);
        if (isSolid(t)) {
          if (dir > 0) body.x = tx * TILE - body.w;
          else body.x = (tx + 1) * TILE;
          body.vx = 0;
          break;
        }
      }
    }

    // Vertical
    body.y += body.vy * dt;
    if (body.vy !== 0) {
      const dir = Math.sign(body.vy);

      const ty = Math.floor((dir > 0 ? (body.y + body.h) : body.y) / TILE);
      const x0 = Math.floor(body.x / TILE);
      const x1 = Math.floor((body.x + body.w - 1) / TILE);

      for (let tx = x0; tx <= x1; tx++) {
        const t = getTile(tx, ty);
        if (isSolid(t)) {
          if (dir > 0) {
            body.y = ty * TILE - body.h;
            body.onGround = true;
          } else {
            const brokeBrick = t === "B" && canBreakBricks();
            if (brokeBrick) {
              breakBrick(tx, ty);
            } else if (isQuestion(t)) {
              bumpQuestionBlock(tx, ty);
            }
            body.y = (ty + 1) * TILE;
            body.hitHead = true;
          }
          body.vy = 0;
          break;
        }
      }
    }
  }

  // -----------------------------
  // Game logic: blocks / pickups
  // -----------------------------
  let coinCount = 0;
  let score = 0;
  let lives = 3;
  let levelTimer = HUD_TIMER_START;

  function spawnCoinBurst(x, y) {
    for (let i = 0; i < 8; i++) {
      particles.push({
        x, y,
        vx: (Math.random() * 2 - 1) * 120,
        vy: -(Math.random() * 220 + 100),
        life: 0.5 + Math.random() * 0.25,
      });
    }
  }

  function spawnSkidDust(x, y, dir) {
    for (let i = 0; i < 3; i++) {
      particles.push({
        x: x + (Math.random() * 4 - 2),
        y: y + (Math.random() * 2 - 1),
        vx: (Math.random() * 50 + 60) * dir * -1,
        vy: -(Math.random() * 70 + 30),
        life: 0.25 + Math.random() * 0.12,
        color: "#d8d8d8",
        size: 2
      });
    }
  }

  function spawnMushroom(px, py) {
    entities.push({
      type: "mushroom",
      x: px, y: py,
      w: 14, h: 14,
      vx: 70, vy: 0,
      alive: true,
    });
  }

  function spawnFireball() {
    const dir = player.facing >= 0 ? 1 : -1;
    const startX = player.x + (dir > 0 ? player.w : -6);
    const startY = player.y + 6;
    entities.push({
      type: "fireball",
      x: startX,
      y: startY,
      w: 6,
      h: 6,
      vx: FIREBALL_SPEED * dir,
      vy: -60,
      alive: true,
      life: FIREBALL_LIFETIME,
      bounces: 0,
    });
    player.fireCooldown = FIREBALL_COOLDOWN;
    playFireballSound();
  }

  function performTailAttack() {
    const dir = player.facing >= 0 ? 1 : -1;
    const hitbox = {
      x: player.x + (dir > 0 ? player.w : -TAIL_RANGE_X),
      y: player.y + (player.h - TAIL_RANGE_Y - 4),
      w: TAIL_RANGE_X,
      h: TAIL_RANGE_Y,
    };
    for (const target of entities) {
      if (!target.alive || target.type !== "goon") continue;
      if (aabb(hitbox.x, hitbox.y, hitbox.w, hitbox.h, target.x, target.y, target.w, target.h)) {
        target.alive = false;
        spawnCoinBurst(target.x + target.w / 2, target.y + target.h / 2);
      }
    }
    playTailSound();
  }

  function countHammers() {
    return entities.filter((e) => e.alive && e.type === "hammer").length;
  }

  function spawnHammer() {
    if (countHammers() >= 2) return;
    const dir = player.facing >= 0 ? 1 : -1;
    const vx = Math.cos(HAMMER_LAUNCH_ANGLE) * HAMMER_SPEED * dir;
    const vy = -Math.sin(HAMMER_LAUNCH_ANGLE) * HAMMER_SPEED;
    const startX = player.x + (dir > 0 ? player.w : -6);
    const startY = player.y + 4;
    entities.push({
      type: "hammer",
      x: startX,
      y: startY,
      w: 6,
      h: 6,
      vx,
      vy,
      alive: true,
      life: HAMMER_LIFETIME,
      spin: 0,
    });
    player.hammerCooldown = HAMMER_COOLDOWN;
    playHammerSound();
  }

  function startStatue() {
    player.statueActive = true;
    player.statueTimer = STATUE_DURATION;
    player.statueCooldown = STATUE_COOLDOWN;
    player.vx = 0;
    player.ax = 0;
    player.pCharge = 0;
    playTailSound();
  }

  // Alternate between coin and mushroom spawns (simple demo)
  let questionHits = 0;

  function bumpQuestionBlock(tx, ty) {
    setTile(tx, ty, "u");
    broadcastEditChange(tx, ty, "u");
    questionHits++;
    const cx = tx * TILE + TILE/2;
    const cy = ty * TILE;

    if (questionHits % 2 === 1) {
      coinCount++;
      score += 200;
      spawnCoinBurst(cx, cy);
    } else {
      spawnMushroom(tx * TILE + 1, ty * TILE - 14);
    }
  }

  function breakBrick(tx, ty) {
    setTile(tx, ty, ".");
    broadcastEditChange(tx, ty, ".");
    const cx = tx * TILE + TILE / 2;
    const cy = ty * TILE + TILE / 2;
    for (let i = 0; i < 6; i++) {
      particles.push({
        x: cx,
        y: cy,
        vx: (Math.random() * 2 - 1) * 160,
        vy: -(Math.random() * 200 + 80),
        life: 0.35 + Math.random() * 0.2,
        color: "#b46a3a",
        size: 2 + Math.floor(Math.random() * 2),
      });
    }
  }

  function breakIce(tx, ty) {
    setTile(tx, ty, ".");
    broadcastEditChange(tx, ty, ".");
    const cx = tx * TILE + TILE / 2;
    const cy = ty * TILE + TILE / 2;
    for (let i = 0; i < 4; i++) {
      particles.push({
        x: cx,
        y: cy,
        vx: (Math.random() * 2 - 1) * 120,
        vy: -(Math.random() * 140 + 60),
        life: 0.35 + Math.random() * 0.2,
        color: "#b0e0ff",
        size: 2,
      });
    }
  }

  function breakDestructible(tx, ty) {
    const t = getTile(tx, ty);
    if (t === "B") return breakBrick(tx, ty);
    if (t === "I") return breakIce(tx, ty);
  }

  function collectCoinTileAtPlayer(player) {
    // check tiles overlapped by player for 'C'
    const x0 = Math.floor(player.x / TILE);
    const x1 = Math.floor((player.x + player.w - 1) / TILE);
    const y0 = Math.floor(player.y / TILE);
    const y1 = Math.floor((player.y + player.h - 1) / TILE);

      for (let ty = y0; ty <= y1; ty++) {
        for (let tx = x0; tx <= x1; tx++) {
          if (getTile(tx, ty) === "C") {
            setTile(tx, ty, ".");
            broadcastEditChange(tx, ty, ".");
            coinCount++;
            score += 100;
            spawnCoinBurst(tx*TILE + TILE/2, ty*TILE + TILE/2);
          }
        }
    }
  }

  // -----------------------------
  // Player
  // -----------------------------
  const player = {
    type: "player",
    x: playerSpawn.x * TILE,
    y: playerSpawn.y * TILE,
    w: 12,
    h: 14,
    vx: 0,
    vy: 0,
    facing: 1,
    onGround: false,
    hitHead: false,
    state: "ground",
    coyote: 0,
    jumpBuf: 0,
    form: PowerUpForm.Small,
    big: formIsBig(PowerUpForm.Small),
    invuln: 0,
    ax: 0,
    pCharge: 0,
    skidTimer: 0,
    skidDust: 0,
    skidBoost: 0,
    airCarryMax: 0,
    fireCooldown: 0,
    hammerCooldown: 0,
    tailTimer: 0,
    tailCooldown: 0,
    flightTimer: 0,
    flightActive: false,
    statueActive: false,
    statueTimer: 0,
    statueCooldown: 0,
  };
  function resetPlayerToSpawn() {
    player.x = playerSpawn.x * TILE;
    player.y = playerSpawn.y * TILE;
    player.vx = 0;
    player.vy = 0;
    player.onGround = false;
    player.hitHead = false;
    player.state = "ground";
    player.coyote = 0;
    player.jumpBuf = 0;
  }
  let pMeterDisplaySegs = 0;
  let pMeterDecayHold = 0;
  const debugVxEl = document.getElementById("debug-vx");
  const debugAxEl = document.getElementById("debug-ax");
  const debugPChargeEl = document.getElementById("debug-pcharge");
  const debugPSegsEl = document.getElementById("debug-psegs");
  const debugPMaxEl = document.getElementById("debug-pmax");
  if (debugPMaxEl) debugPMaxEl.textContent = P_METER_SEGMENTS;

  function isValidForm(form) {
    return Object.values(PowerUpForm).includes(form);
  }

  function formIsBig(form) {
    return BIG_FORMS.has(form);
  }

  function formPalette(form) {
    switch (form) {
      case PowerUpForm.Fire:
        return { shirt: "#ff6b35", pants: "#ffd166" };
      case PowerUpForm.Raccoon:
        return { shirt: "#d66f4a", pants: "#7f5539" };
      case PowerUpForm.Tanooki:
        return { shirt: "#a97155", pants: "#5b4636" };
      case PowerUpForm.Frog:
        return { shirt: "#2dd36f", pants: "#0a8a4a" };
      case PowerUpForm.Hammer:
        return { shirt: "#5d78ff", pants: "#2d3142" };
      case PowerUpForm.Super:
        return { shirt: "#e23b2e", pants: "#2a49ff" };
      default:
        return { shirt: "#e23b2e", pants: "#2a49ff" };
    }
  }

  function setPlayerForm(form, options = {}) {
    const { skipSave = false } = options;
    const nextForm = isValidForm(form) ? form : PowerUpForm.Small;
    const willBeBig = formIsBig(nextForm);
    player.form = nextForm;
    player.big = willBeBig;
    // adjust hitbox height; keep feet position stable when size changes
    const oldH = player.h;
    player.h = willBeBig ? 22 : 14;
    player.y += (oldH - player.h);
    if (!skipSave) savePlayerSnapshot();
  }

  let autoSaveCooldown = 0;

  function serializePlayerSnapshot() {
    return {
      form: player.form,
      levelTimer,
      invuln: player.invuln,
      fireCooldown: player.fireCooldown,
      hammerCooldown: player.hammerCooldown,
      tailCooldown: player.tailCooldown,
      flightTimer: player.flightTimer,
      flightActive: player.flightActive,
      statueActive: player.statueActive,
      statueTimer: player.statueTimer,
      statueCooldown: player.statueCooldown,
    };
  }

  function savePlayerSnapshot() {
    if (typeof localStorage === "undefined") return;
    try {
      localStorage.setItem(PLAYER_SAVE_KEY, JSON.stringify(serializePlayerSnapshot()));
    } catch (err) {
      // ignore persistence failures (e.g., storage disabled)
    }
  }

  function loadPlayerSnapshot() {
    if (typeof localStorage === "undefined") return false;
    const raw = localStorage.getItem(PLAYER_SAVE_KEY);
    if (!raw) return false;
    try {
      const data = JSON.parse(raw);
      if (isValidForm(data.form)) {
        setPlayerForm(data.form, { skipSave: true });
      }
      if (typeof data.levelTimer === "number") {
        levelTimer = clamp(data.levelTimer, 0, HUD_TIMER_START);
      }
      if (typeof data.invuln === "number") {
        player.invuln = clamp(data.invuln, 0, DAMAGE_INVULN_TIME);
      }
      if (typeof data.fireCooldown === "number") {
        player.fireCooldown = clamp(data.fireCooldown, 0, FIREBALL_COOLDOWN);
      }
      if (typeof data.hammerCooldown === "number") {
        player.hammerCooldown = clamp(data.hammerCooldown, 0, HAMMER_COOLDOWN);
      }
      if (typeof data.tailCooldown === "number") {
        player.tailCooldown = clamp(data.tailCooldown, 0, TAIL_COOLDOWN);
      }
      if (typeof data.flightTimer === "number") {
        player.flightTimer = clamp(data.flightTimer, 0, FLIGHT_TIME);
      }
      if (typeof data.flightActive === "boolean") {
        player.flightActive = data.flightActive;
      }
      if (typeof data.statueActive === "boolean") {
        player.statueActive = data.statueActive;
      }
      if (typeof data.statueTimer === "number") {
        player.statueTimer = clamp(data.statueTimer, 0, STATUE_DURATION);
      }
      if (typeof data.statueCooldown === "number") {
        player.statueCooldown = clamp(data.statueCooldown, 0, STATUE_COOLDOWN);
      }
      return true;
    } catch (err) {
      return false;
    }
  }

  function maybeAutoSave(dt) {
    autoSaveCooldown = Math.max(0, autoSaveCooldown - dt);
    if (autoSaveCooldown > 0) return;
    savePlayerSnapshot();
    autoSaveCooldown = 1.0;
  }

  function downgradeForm(form) {
    if (form === PowerUpForm.Small) return null;
    if (form === PowerUpForm.Super) return PowerUpForm.Small;
    return PowerUpForm.Super;
  }

  function canBreakBricks() {
    return formIsBig(player.form);
  }

  function canShootFire() {
    return player.form === PowerUpForm.Fire;
  }

  function hasTailAbilities() {
    return player.form === PowerUpForm.Raccoon || player.form === PowerUpForm.Tanooki;
  }

  function getSurfaceModifier(body) {
    if (!body.onGround) return { accel: 1, friction: 1, brake: 1 };
    const footY = body.y + body.h + 0.5;
    const tx = Math.floor((body.x + body.w / 2) / TILE);
    const ty = Math.floor(footY / TILE);
    const type = surfaceType(getTile(tx, ty));
    return type ? SURFACE_MODS[type] : { accel: 1, friction: 1, brake: 1 };
  }

  function isPlayerSwimming() {
    const tx = Math.floor((player.x + player.w / 2) / TILE);
    const ty = Math.floor((player.y + player.h - 2) / TILE);
    return isWaterTile(getTile(tx, ty));
  }

  // -----------------------------
  // Enemies
  // -----------------------------
  function spawnEnemy(tx, ty) {
    entities.push({
      type: "goon",
      x: tx * TILE + 1,
      y: ty * TILE,
      w: 14,
      h: 14,
      vx: -50,
      vy: 0,
      alive: true,
    });
  }

  // Create enemies from map
  for (let y = 0; y < mapH; y++) {
    for (let x = 0; x < mapW; x++) {
      if (tiles[y][x] === "E") {
        tiles[y][x] = ".";
        spawnEnemy(x, y);
      }
    }
  }

  // -----------------------------
  // Camera
  // -----------------------------
  const cam = { x: 0, y: 0 };
  function updateWorldSize() {
    worldWpx = mapW * TILE;
    worldHpx = mapH * TILE;
  }

  function updateCamera() {
    const targetX = player.x + player.w/2 - BASE_W/2;
    cam.x = clamp(targetX, 0, Math.max(0, worldWpx - BASE_W));
    cam.y = 0;
  }

  // -----------------------------
  // Game state
  // -----------------------------
  let deadTimer = 0;
  function restart() {
    const draft = getStoredPayload(DRAFT_PAYLOAD_KEY);
    const published = getStoredPayload(PUBLISHED_PAYLOAD_KEY);
    const base = draft || published || JSON.parse(JSON.stringify(GOLDEN_PAYLOAD));
    applyLevelPayload(base, { resetPlayer: true });
    // reset coins and blocks
    coinCount = 0;
    questionHits = 0;
    entities.length = 0;
    particles.length = 0;

    // respawn enemies from template
    for (let y = 0; y < mapH; y++) {
      for (let x = 0; x < mapW; x++) {
        if (tiles[y][x] === "E") {
          tiles[y][x] = ".";
          spawnEnemy(x, y);
        }
      }
    }

    player.x = playerSpawn.x * TILE;
    player.y = playerSpawn.y * TILE;
    player.vx = 0; player.vy = 0;
    player.invuln = 0;
    player.coyote = 0;
    player.jumpBuf = 0;
    player.ax = 0;
    player.pCharge = 0;
    player.skidTimer = 0;
    player.skidDust = 0;
    player.skidBoost = 0;
    player.airCarryMax = 0;
    player.fireCooldown = 0;
    player.hammerCooldown = 0;
    player.tailTimer = 0;
    player.tailCooldown = 0;
    player.flightTimer = 0;
    player.flightActive = false;
    player.hammerCooldown = 0;
    player.statueActive = false;
    player.statueTimer = 0;
    player.statueCooldown = 0;
    pMeterDisplaySegs = 0;
    pMeterDecayHold = 0;
    setPlayerForm(PowerUpForm.Small, { skipSave: true });
    deadTimer = 0;
    // also clear transient inputs so we don't instantly re-trigger actions
    pressed.clear();
    keys.clear();
    levelTimer = HUD_TIMER_START;
    loadPlayerSnapshot();
    savePlayerSnapshot();
  }

  function killPlayer() {
    deadTimer = 0.8;
    player.vx = 0;
    player.vy = -420;
    setPlayerForm(PowerUpForm.Small);
    player.invuln = 0;
    player.fireCooldown = 0;
    player.hammerCooldown = 0;
    player.tailTimer = 0;
    player.tailCooldown = 0;
    player.flightTimer = 0;
    player.flightActive = false;
    player.hammerCooldown = 0;
    player.statueActive = false;
    player.statueTimer = 0;
    player.statueCooldown = 0;
    levelTimer = HUD_TIMER_START;
    savePlayerSnapshot();
  }

  function handlePlayerHit() {
    if (player.invuln > 0 || deadTimer > 0) return;
    const nextForm = downgradeForm(player.form);
    if (!nextForm) {
      killPlayer();
      return;
    }
    setPlayerForm(nextForm);
    player.invuln = DAMAGE_INVULN_TIME;
    player.vx = -player.facing * 120;
    player.vy = -240;
  }

  // first load: replace initial P in template (already done), but keep everything else
  // NOTE: coins in map are collected as tiles
  // We'll initialize coinCount by counting coins on map (optional). We'll keep it 0 and treat them as pickups.

  // -----------------------------
  // Physics helper for entities
  // -----------------------------
  function entityMoveAndCollide(e, dt) {
    e.onGround = false;

    // Horizontal
    e.x += e.vx * dt;
    if (e.vx !== 0) {
      const dir = Math.sign(e.vx);
      const aheadX = dir > 0 ? e.x + e.w : e.x;
      const tx = Math.floor(aheadX / TILE);

      const y0 = Math.floor(e.y / TILE);
      const y1 = Math.floor((e.y + e.h - 1) / TILE);

      for (let ty = y0; ty <= y1; ty++) {
        const t = getTile(tx, ty);
        if (isSolid(t)) {
          if (dir > 0) e.x = tx * TILE - e.w;
          else e.x = (tx + 1) * TILE;
          e.vx = -e.vx; // bounce back
          break;
        }
      }
    }

    // Vertical
    e.y += e.vy * dt;
    if (e.vy !== 0) {
      const dir = Math.sign(e.vy);
      const ty = Math.floor((dir > 0 ? (e.y + e.h) : e.y) / TILE);

      const x0 = Math.floor(e.x / TILE);
      const x1 = Math.floor((e.x + e.w - 1) / TILE);

      for (let tx = x0; tx <= x1; tx++) {
        const t = getTile(tx, ty);
        if (isSolid(t)) {
          if (dir > 0) {
            e.y = ty * TILE - e.h;
            e.onGround = true;
          } else {
            e.y = (ty + 1) * TILE;
          }
          e.vy = 0;
          break;
        }
      }
    }
  }

  // -----------------------------
  // Update
  // -----------------------------
  let last = performance.now();
  let acc = 0;
  const FIXED = 1/120;

  function step(dt) {
    // Restart key
    if (tap("KeyR")) restart();

    // Death / respawn pause
    if (deadTimer > 0) {
      deadTimer -= dt;
      if (deadTimer <= 0) restart();
      return;
    }

    // Update invuln
    player.invuln = Math.max(0, player.invuln - dt);
    player.tailTimer = Math.max(0, player.tailTimer - dt);
    player.tailCooldown = Math.max(0, player.tailCooldown - dt);
    player.flightTimer = Math.max(0, player.flightTimer - dt);
    player.statueTimer = Math.max(0, player.statueTimer - dt);
    player.statueCooldown = Math.max(0, player.statueCooldown - dt);

    // Jump buffer: remember a tap briefly to fire on next grounded frame
    if (tap("KeyZ")) player.jumpBuf = JUMP_BUFFER;
    else player.jumpBuf = Math.max(0, player.jumpBuf - dt);
    player.fireCooldown = Math.max(0, player.fireCooldown - dt);
    player.hammerCooldown = Math.max(0, player.hammerCooldown - dt);

    const prevVx = player.vx;
    const wasGrounded = player.onGround;

    // Move input
    const left = down("ArrowLeft");
    const right = down("ArrowRight");
    const run = down("KeyX");
    const tailSwing = tap("KeyC");
    const statueToggle = tap("KeyV");
    const surfaceMod = player.onGround ? getSurfaceModifier(player) : { accel: 1, friction: 1, brake: 1 };

    // Tanooki statue toggle
    if (hasTailAbilities() && player.form === PowerUpForm.Tanooki) {
      if (statueToggle && player.statueCooldown <= 0 && !player.statueActive) {
        startStatue();
      }
      if (player.statueActive) {
        if (player.statueTimer <= 0) {
          player.statueActive = false;
        } else {
          player.invuln = Math.max(player.invuln, STATUE_INVULN_TOPUP);
        }
      }
    } else {
      player.statueActive = false;
      player.statueTimer = 0;
    }

    const moveLeft = player.statueActive ? false : left;
    const moveRight = player.statueActive ? false : right;
    const runHeld = player.statueActive ? false : run;
    const accelCurve = runHeld ? RUN_ACCEL_CURVE : WALK_ACCEL_CURVE;
    const wantsRun = runHeld && (moveLeft !== moveRight);
    const hasPSpeed = player.pCharge >= 1;
    const boostMult = 1 + player.skidBoost;
    const baseMax = runHeld ? (hasPSpeed ? P_SPEED_MAX : RUN_MAX) : WALK_MAX;
    const maxSpeed = baseMax * boostMult;
    const speedRatio = clamp(Math.abs(player.vx) / Math.max(1, maxSpeed), 0, 1);
    const accel = mix(accelCurve.high, accelCurve.low, speedRatio);

    const wantDir = (moveLeft ? -1 : 0) + (moveRight ? 1 : 0);
    const vxSign = Math.sign(player.vx);
    // Use previous-frame velocity to decide skid, so friction this frame doesn't block the trigger
    const prevVxSign = Math.sign(prevVx);
    const reversing = player.onGround && wantDir !== 0 && prevVxSign !== 0 && wantDir === -prevVxSign && Math.abs(prevVx) > SKID_SPEED_THRESHOLD;

    // Trigger skid when reversing at speed on ground
    if (reversing && player.skidTimer <= 0) {
      player.skidTimer = SKID_TIME;
      player.skidDust = 0;
      player.skidBoost = Math.max(player.skidBoost, SKID_BOOST_AMOUNT);
      playSkidSound();
      spawnSkidDust(player.x + (player.facing > 0 ? player.w : 0), player.y + player.h, player.facing);
    }

    const isSkidding = player.skidTimer > 0 && player.onGround;
    if (player.skidTimer > 0) player.skidTimer = Math.max(0, player.skidTimer - dt);
    const accelScale = player.onGround ? (isSkidding ? SKID_ACCEL_SCALE : 1) : AIR_ACCEL_SCALE;
    const frogLandAccelScale = player.form === PowerUpForm.Frog && player.onGround ? FROG_LAND_ACCEL_SCALE : 1;
    const frogLandDecelScale = player.form === PowerUpForm.Frog && player.onGround ? FROG_LAND_DECEL_SCALE : 1;

    if (player.statueActive) {
      player.vx = 0;
    } else if (wantDir === 0) {
      // friction
      const mag = Math.abs(player.vx);
      const groundFriction = (isSkidding ? SKID_FRICTION_DECEL : FRICTION_DECEL) * frogLandDecelScale;
      const dec = (player.onGround ? groundFriction * surfaceMod.friction : AIR_FRICTION_DECEL) * dt;
      player.vx = (mag <= dec) ? 0 : (mag - dec) * vxSign;
    } else if (wantDir !== vxSign && player.vx !== 0) {
      // braking when reversing direction
      const mag = Math.abs(player.vx);
      const groundBrake = (isSkidding ? SKID_BRAKE_DECEL : BRAKE_DECEL) * frogLandDecelScale;
      const dec = (player.onGround ? groundBrake * surfaceMod.brake : AIR_BRAKE_DECEL) * dt;
      player.vx = (mag <= dec) ? 0 : (mag - dec) * vxSign;
    } else {
      // accelerate in desired direction
      player.vx += accel * accelScale * surfaceMod.accel * frogLandAccelScale * dt * wantDir;
      player.facing = wantDir;
    }

    player.vx = clamp(player.vx, -maxSpeed, maxSpeed);

    // Gravity (with glide/flight modifiers)
    let gravity = GRAVITY;
    if (player.statueActive) {
      player.flightActive = false;
      player.flightTimer = 0;
    }
    const swimming = isPlayerSwimming();
    const gliding = !swimming && hasTailAbilities() && player.vy > 40 && down("KeyZ") && !player.flightActive;
    if (gliding) gravity *= GLIDE_GRAVITY_SCALE;
    if (swimming) {
      gravity *= WATER_GRAVITY_SCALE;
    }
    if (!swimming && player.flightActive && player.flightTimer > 0 && down("KeyZ")) {
      // keep upward lift while flight lasts
      player.vy = Math.min(player.vy, -FLIGHT_LIFT);
      player.flightTimer = Math.max(0, player.flightTimer - dt);
      if (player.flightTimer <= 0) player.flightActive = false;
    } else if (player.flightActive && player.flightTimer <= 0) {
      player.flightActive = false;
    }
    player.vy += gravity * dt;
    player.vy = Math.min(player.vy, swimming ? WATER_MAX_FALL : MAX_FALL);

    // Collide
    moveAndCollide(player, dt);

    // Track actual acceleration (accounts for collisions and friction)
    player.ax = (player.vx - prevVx) / dt;

    // Grounded tracking and state (adds tolerance check so micro-separations don't kill jumps)
    const grounded = player.onGround || isOnGround(player);
    // Carry takeoff speed in air so P-speed bonus lingers until air friction/braking trims it
    if (!grounded && wasGrounded) {
      player.airCarryMax = Math.max(player.airCarryMax, Math.abs(player.vx));
    } else if (grounded) {
      player.airCarryMax = 0;
    }
    const speedCap = Math.max(maxSpeed, player.airCarryMax || 0);
    player.vx = clamp(player.vx, -speedCap, speedCap);
    player.onGround = grounded;
    player.coyote = grounded ? COYOTE_TIME : Math.max(0, player.coyote - dt);
    const skiddingActive = isSkidding && grounded;
    player.state = grounded ? (skiddingActive ? "skid" : "ground") : "jumping";
    if (player.statueActive) player.state = "statue";

    if (skiddingActive && Math.abs(player.vx) > 20) {
      player.skidDust -= dt;
      if (player.skidDust <= 0) {
        player.skidDust = SKID_DUST_INTERVAL;
        spawnSkidDust(player.x + (player.facing > 0 ? player.w : 0), player.y + player.h, player.facing);
      }
    }

    // Decay skid boost over time
    player.skidBoost = Math.max(0, player.skidBoost - SKID_BOOST_DECAY * dt);

    // P-speed charge only builds while holding run on ground near run cap; drains slowly otherwise
    if (wantsRun && grounded && Math.abs(player.vx) >= P_SPEED_ENTRY_SPEED) {
      player.pCharge = clamp(player.pCharge + dt / P_SPEED_CHARGE_TIME, 0, 1);
    } else if (player.pCharge > 0) {
      const decay = (!wantsRun || !grounded) ? P_SPEED_DECAY_RATE * 0.65 : P_SPEED_DECAY_RATE;
      player.pCharge = Math.max(0, player.pCharge - dt * decay);
    }

    // If jump is held while grounded, refresh the buffer so landing while held triggers another jump
    if (down("KeyZ") && grounded) player.jumpBuf = JUMP_BUFFER;

    // Fireball/Hammer throw
    if (!player.statueActive && tap("KeyC")) {
      if (player.form === PowerUpForm.Hammer && player.hammerCooldown <= 0) {
        spawnHammer();
      } else if (canShootFire() && player.fireCooldown <= 0) {
        spawnFireball();
      }
    }

    // Tail attack (Raccoon/Tanooki)
    if (!player.statueActive && hasTailAbilities() && tailSwing && player.tailCooldown <= 0) {
      player.tailTimer = TAIL_SWING_TIME;
      player.tailCooldown = TAIL_COOLDOWN;
      performTailAttack();
    }

    // Jump: only allow when currently on ground, no buffer
    if (player.jumpBuf > 0 && player.coyote > 0) {
      const swimming = isPlayerSwimming();
      if (swimming) {
        player.vy = -WATER_SWIM_IMPULSE;
        player.onGround = false;
      } else {
        player.vy = -JUMP_V;
        player.onGround = false;
        if (hasTailAbilities() && player.pCharge >= 1) {
          player.flightActive = true;
          player.flightTimer = FLIGHT_TIME;
        } else {
          player.flightActive = false;
          player.flightTimer = 0;
        }
      }
      player.state = "jumping";
      player.coyote = 0;
      player.jumpBuf = 0;
      // Capture takeoff speed so airborne clamp preserves P-speed until air drag/braking trims it
      player.airCarryMax = Math.max(player.airCarryMax || 0, Math.abs(player.vx));
    }

    // Level timer tick
    levelTimer = Math.max(0, levelTimer - dt);
    maybeAutoSave(dt);

    // Collect coin tiles
    collectCoinTileAtPlayer(player);

    // Entity updates
    for (const e of entities) {
      if (!e.alive) continue;

      if (e.type === "goon" || e.type === "mushroom") {
        e.vy += GRAVITY * dt;
        e.vy = Math.min(e.vy, MAX_FALL);
        entityMoveAndCollide(e, dt);

        // If it falls off world, kill it
        if (e.y > worldHpx + 200) e.alive = false;
      }
      if (e.type === "fireball") {
        e.life -= dt;
        if (e.life <= 0) {
          e.alive = false;
        } else {
          // gravity
          e.vy += FIREBALL_GRAVITY * dt;
          e.vy = Math.min(e.vy, MAX_FALL);

          // horizontal move, die on wall hit
          const dirX = Math.sign(e.vx);
          e.x += e.vx * dt;
          if (dirX !== 0) {
            const tx = Math.floor((dirX > 0 ? e.x + e.w : e.x) / TILE);
            const y0 = Math.floor(e.y / TILE);
            const y1 = Math.floor((e.y + e.h - 1) / TILE);
            for (let ty = y0; ty <= y1; ty++) {
              if (isSolid(getTile(tx, ty))) {
                e.alive = false;
                break;
              }
            }
          }

          // vertical move with ground bounce
          const dirY = Math.sign(e.vy);
          e.y += e.vy * dt;
          if (dirY !== 0) {
            const ty = Math.floor((dirY > 0 ? e.y + e.h : e.y) / TILE);
            const x0 = Math.floor(e.x / TILE);
            const x1 = Math.floor((e.x + e.w - 1) / TILE);
            for (let tx = x0; tx <= x1; tx++) {
              if (isSolid(getTile(tx, ty))) {
                if (dirY > 0) {
                  e.y = ty * TILE - e.h;
                  e.vy = -FIREBALL_BOUNCE_V;
                  e.bounces += 1;
                  if (e.bounces > 4) e.alive = false;
                } else {
                  e.alive = false;
                }
                break;
              }
            }
          }
        }
      }
      if (e.type === "hammer") {
        e.life -= dt;
        if (e.life <= 0) {
          e.alive = false;
        } else {
          e.spin = (e.spin + dt * 12) % (Math.PI * 2);
          e.vy += HAMMER_GRAVITY * dt;
          e.x += e.vx * dt;
          e.y += e.vy * dt;
          // collisions with tiles
          const tx0 = Math.floor(e.x / TILE);
          const tx1 = Math.floor((e.x + e.w - 1) / TILE);
          const ty0 = Math.floor(e.y / TILE);
          const ty1 = Math.floor((e.y + e.h - 1) / TILE);
          let collided = false;
          for (let ty = ty0; ty <= ty1; ty++) {
            for (let tx = tx0; tx <= tx1; tx++) {
              const t = getTile(tx, ty);
              if (isSolid(t)) {
                if (t === "B" || t === "I") {
                  breakDestructible(tx, ty);
                }
                collided = true;
                break;
              }
            }
            if (collided) break;
          }
          if (collided) e.alive = false;
        }
      }

      // Interactions with player
      if (e.alive && e.type === "mushroom") {
        if (aabb(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)) {
          e.alive = false;
          setPlayerForm(PowerUpForm.Super);
          spawnCoinBurst(e.x + e.w/2, e.y + e.h/2);
          score += 200;
        }
      }

      if (e.alive && e.type === "goon") {
        if (aabb(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)) {
          // stomp check: player moving downward and feet above enemy top
          const playerFeet = player.y + player.h;
          const enemyTop = e.y;
          const stomp = player.vy > 40 && (playerFeet - enemyTop) < 10;

          if (stomp) {
            e.alive = false;
            player.vy = -260; // bounce
            spawnCoinBurst(e.x + e.w/2, e.y + e.h/2);
          } else {
            handlePlayerHit();
          }
        }
      }

      if (e.alive && e.type === "fireball") {
        for (const target of entities) {
          if (!target.alive || target.type !== "goon") continue;
          if (aabb(e.x, e.y, e.w, e.h, target.x, target.y, target.w, target.h)) {
            target.alive = false;
            e.alive = false;
            spawnCoinBurst(target.x + target.w / 2, target.y + target.h / 2);
            break;
          }
        }
      }
      if (e.alive && e.type === "hammer") {
        for (const target of entities) {
          if (!target.alive || target.type !== "goon") continue;
          if (aabb(e.x, e.y, e.w, e.h, target.x, target.y, target.w, target.h)) {
            target.alive = false;
            e.alive = false;
            spawnCoinBurst(target.x + target.w / 2, target.y + target.h / 2);
            break;
          }
        }
      }
    }

    // cleanup
    for (let i = entities.length - 1; i >= 0; i--) {
      if (!entities[i].alive) entities.splice(i, 1);
    }

    // particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += GRAVITY * dt * 0.7;
      if (p.life <= 0) particles.splice(i, 1);
    }

    // Fall death
    if (player.y > worldHpx + 120) {
      killPlayer();
    }

    updateCamera();
  }

  // -----------------------------
  // Render
  // -----------------------------
  function drawTile(t, x, y) {
    // x,y in pixels (world)
    const sx = Math.floor(x - cam.x);
    const sy = Math.floor(y - cam.y);
    if (sx < -TILE || sy < -TILE || sx > BASE_W || sy > BASE_H) return;

    const custom = tileRegistry.get(t);
    if (custom && custom.image && custom.image.complete) {
      g.drawImage(custom.image, sx, sy, TILE, TILE);
      return;
    }
    if (t === "#") { // ground
      g.fillStyle = "#3b2f2f";
      g.fillRect(sx, sy, TILE, TILE);
      g.fillStyle = "#2a2020";
      g.fillRect(sx, sy + 12, TILE, 4);
      g.fillStyle = "#4a3a3a";
      g.fillRect(sx, sy, TILE, 2);
      return;
    }
    if (t === "B") { // brick
      g.fillStyle = "#7c3f2a";
      g.fillRect(sx, sy, TILE, TILE);
      g.fillStyle = "rgba(0,0,0,0.25)";
      g.fillRect(sx, sy + 1, TILE, 1);
      g.fillRect(sx, sy + 8, TILE, 1);
      g.fillRect(sx + 7, sy, 1, TILE);
      return;
    }
    if (t === "?") { // question block
      g.fillStyle = "#d1a23a";
      g.fillRect(sx, sy, TILE, TILE);
      g.fillStyle = "#8a6a18";
      g.fillRect(sx, sy + 12, TILE, 4);
      g.fillStyle = "#fff2";
      g.fillRect(sx, sy, TILE, 3);
      g.fillStyle = "#2b1d05";
      g.fillRect(sx + 6, sy + 4, 4, 8); // cheap "?"
      g.fillRect(sx + 8, sy + 4, 3, 3);
      return;
    }
    if (t === "u") { // used block
      g.fillStyle = "#8c8c8c";
      g.fillRect(sx, sy, TILE, TILE);
      g.fillStyle = "#0002";
      g.fillRect(sx, sy + 12, TILE, 4);
      return;
    }
    if (t === "C") { // coin tile
      // drawn as coin in world
      g.fillStyle = "#f5d000";
      g.fillRect(sx + 6, sy + 4, 4, 8);
      g.fillRect(sx + 5, sy + 6, 6, 4);
      g.fillStyle = "#fff5";
      g.fillRect(sx + 6, sy + 5, 2, 2);
      return;
    }
    if (t === "I") { // ice
      g.fillStyle = "#b0e0ff";
      g.fillRect(sx, sy, TILE, TILE);
      g.fillStyle = "#d8f4ff";
      g.fillRect(sx, sy, TILE, 3);
      g.fillStyle = "#8bbbd6";
      g.fillRect(sx, sy + 12, TILE, 4);
      return;
    }
    if (t === "S") { // sand
      g.fillStyle = "#d8c28f";
      g.fillRect(sx, sy, TILE, TILE);
      g.fillStyle = "#b89f6b";
      g.fillRect(sx, sy + 11, TILE, 5);
      g.fillStyle = "#f7e7b8";
      g.fillRect(sx, sy, TILE, 2);
      return;
    }
  }

  function drawGridOverlay() {
    if (!showGrid) return;
    // Grid locked to world coordinates, not screen overlay
    const step = TILE; // 16px per tile
    const startX = -(cam.x % step);
    const startY = -(cam.y % step);
    g.save();
    g.strokeStyle = "rgba(255,255,255,0.12)";
    g.lineWidth = 1;
    for (let x = startX; x <= BASE_W; x += step) {
      const lx = Math.floor(x) + 0.5;
      g.beginPath();
      g.moveTo(lx, 0);
      g.lineTo(lx, BASE_H);
      g.stroke();
    }
    for (let y = startY; y <= BASE_H; y += step) {
      const ly = Math.floor(y) + 0.5;
      g.beginPath();
      g.moveTo(0, ly);
      g.lineTo(BASE_W, ly);
      g.stroke();
    }
    g.restore();
  }

  function drawSelectionOverlay() {
    if (!editorOpen || !selectedCell) return;
    const { tx, ty } = selectedCell;
    const sx = Math.floor(tx * TILE - cam.x);
    const sy = Math.floor(ty * TILE - cam.y);
    if (sx < -TILE || sy < -TILE || sx > BASE_W || sy > BASE_H) return;
    g.save();
    g.fillStyle = "rgba(0, 255, 170, 0.18)";
    g.fillRect(sx, sy, TILE, TILE);
    g.strokeStyle = "rgba(0, 255, 170, 0.95)";
    g.lineWidth = 2.5;
    g.strokeRect(sx + 0.5, sy + 0.5, TILE - 1, TILE - 1);
    g.strokeStyle = "rgba(0, 0, 0, 0.45)";
    g.lineWidth = 1;
    g.strokeRect(sx + 1.5, sy + 1.5, TILE - 3, TILE - 3);
    g.restore();
  }

  function drawHoverOverlay() {
    if (!editorOpen || !hoverCell) return;
    const { tx, ty } = hoverCell;
    const sx = Math.floor(tx * TILE - cam.x);
    const sy = Math.floor(ty * TILE - cam.y);
    if (sx < -TILE || sy < -TILE || sx > BASE_W || sy > BASE_H) return;
    g.save();
    g.strokeStyle = "rgba(255, 255, 255, 0.7)";
    g.lineWidth = 1;
    g.strokeRect(sx + 0.5, sy + 0.5, TILE - 1, TILE - 1);
    g.restore();
  }

  function drawLabelsOverlay() {
    if (!editorOpen) return;
    g.save();
    g.font = "8px 'Press Start 2P', 'VT323', monospace";
    g.textAlign = "center";
    g.textBaseline = "middle";
    const outline = (text, x, y, color) => {
      g.fillStyle = "rgba(0,0,0,0.8)";
      g.fillText(text, x + 1, y);
      g.fillText(text, x - 1, y);
      g.fillText(text, x, y + 1);
      g.fillText(text, x, y - 1);
      g.fillStyle = color;
      g.fillText(text, x, y);
    };
    const selKey = selectedCell ? `${selectedCell.tx},${selectedCell.ty}` : null;
    const hovKey = hoverCell ? `${hoverCell.tx},${hoverCell.ty}` : null;
    for (const [key, text] of labelMap.entries()) {
      if (!text) continue;
      const [txStr, tyStr] = key.split(",");
      const tx = parseInt(txStr, 10);
      const ty = parseInt(tyStr, 10);
      const sx = Math.floor(tx * TILE - cam.x);
      const sy = Math.floor(ty * TILE - cam.y);
      if (sx < -TILE || sy < -TILE || sx > BASE_W || sy > BASE_H) continue;
      const cx = sx + TILE / 2;
      const cy = sy + TILE / 2;
      if (key === selKey || key === hovKey) {
        outline(text, cx, cy, "#f2f5ff");
      } else {
        // badge in corner
        g.fillStyle = "rgba(0,0,0,0.5)";
        g.fillRect(sx + TILE - 8, sy, 8, 8);
        g.fillStyle = "#f2f5ff";
        g.fillText("T", sx + TILE - 4, sy + 4);
      }
    }
    g.restore();
  }

  function render() {
    // sky
    g.fillStyle = "#4b79ff";
    g.fillRect(0,0,BASE_W,BASE_H);

    // parallax clouds
    const cloudX = -((cam.x * 0.2) % 120);
    g.fillStyle = "rgba(255,255,255,0.65)";
    for (let i = 0; i < 6; i++) {
      const x = cloudX + i * 120;
      g.fillRect(x + 10, 18, 28, 10);
      g.fillRect(x + 0, 22, 40, 12);
      g.fillRect(x + 30, 24, 22, 10);
    }

    // tiles
    const tx0 = Math.floor(cam.x / TILE);
    const tx1 = Math.floor((cam.x + BASE_W) / TILE) + 1;

    for (let y = 0; y < mapH; y++) {
      for (let x = tx0; x <= tx1; x++) {
        const t = getTile(x, y);
        if (t !== ".") drawTile(t, x * TILE, y * TILE);
      }
    }

    // entities
    for (const e of entities) {
      const sx = Math.floor(e.x - cam.x);
      const sy = Math.floor(e.y - cam.y);
      if (sx < -40 || sy < -40 || sx > BASE_W+40 || sy > BASE_H+40) continue;

      if (e.type === "goon") {
        g.fillStyle = "#6b3b2a";
        g.fillRect(sx, sy, e.w, e.h);
        g.fillStyle = "#000";
        g.fillRect(sx + 3, sy + 5, 2, 2);
        g.fillRect(sx + 9, sy + 5, 2, 2);
        g.fillStyle = "#2a120a";
        g.fillRect(sx + 2, sy + 11, e.w-4, 3);
      }
      if (e.type === "mushroom") {
        g.fillStyle = "#d43c3c";
        g.fillRect(sx, sy, e.w, e.h);
        g.fillStyle = "#f3d9d9";
        g.fillRect(sx + 2, sy + 7, e.w-4, e.h-9);
        g.fillStyle = "#fff7";
        g.fillRect(sx + 3, sy + 3, 3, 3);
        g.fillRect(sx + 9, sy + 2, 3, 3);
      }
      if (e.type === "fireball") {
        g.fillStyle = "#ff7b21";
        g.fillRect(sx, sy, e.w, e.h);
        g.fillStyle = "#ffd19b";
        g.fillRect(sx + 2, sy + 2, Math.max(1, e.w - 4), Math.max(1, e.h - 4));
      }
      if (e.type === "hammer") {
        g.save();
        g.translate(sx + e.w / 2, sy + e.h / 2);
        g.rotate(e.spin || 0);
        g.fillStyle = "#c9c9c9";
        g.fillRect(-e.w / 2, -e.h / 2, e.w, e.h);
        g.fillStyle = "#8a6b2f";
        g.fillRect(-1, -e.h / 2, 2, e.h);
        g.restore();
      }
    }

    // remote players
    for (const peer of peers.values()) {
      const w = 12;
      const isBig = peer.form ? formIsBig(peer.form) : peer.big;
      const h = isBig ? 22 : 14;
      const sx = Math.floor((peer.x ?? peer.targetX ?? 0) - cam.x);
      const sy = Math.floor((peer.y ?? peer.targetY ?? 0) - cam.y);
      if (sx < -40 || sy < -40 || sx > BASE_W+40 || sy > BASE_H+40) continue;
      g.fillStyle = "#2ad4b8"; // shirt
      g.fillRect(sx, sy, w, Math.min(8, h));
      g.fillStyle = "#1c3faa"; // pants
      g.fillRect(sx, sy + 8, w, h - 8);
      g.fillStyle = "#000";
      g.fillRect(sx + (peer.facing > 0 ? 8 : 3), sy + 4, 2, 2);
      if (isBig) {
        g.fillStyle = "#0002";
        g.fillRect(sx, sy, w, h);
      }
    }

    // player
    {
      const blink = player.invuln > 0 && Math.floor(performance.now() / 60) % 2 === 0;
      if (!blink) {
        const sx = Math.floor(player.x - cam.x);
        const sy = Math.floor(player.y - cam.y);
        if (player.statueActive) {
          g.fillStyle = "#5b4c3b";
          g.fillRect(sx, sy, player.w, player.h);
          g.fillStyle = "#2b241d";
          g.fillRect(sx + 2, sy + 2, player.w - 4, player.h - 4);
        } else {
          g.fillStyle = "#e23b2e"; // shirt
          g.fillRect(sx, sy, player.w, Math.min(8, player.h));
          g.fillStyle = "#2a49ff"; // pants
          g.fillRect(sx, sy + 8, player.w, player.h - 8);
          g.fillStyle = "#f2c7a7"; // face
          g.fillRect(sx + 3, sy + 2, 6, 5);
          g.fillStyle = "#000";
          g.fillRect(sx + (player.facing > 0 ? 8 : 3), sy + 4, 2, 2);
        const palette = formPalette(player.form);
        g.fillStyle = palette.shirt;
        g.fillRect(sx, sy, player.w, Math.min(8, player.h));
        g.fillStyle = palette.pants;
        g.fillRect(sx, sy + 8, player.w, player.h - 8);
        g.fillStyle = "#f2c7a7"; // face
        g.fillRect(sx + 3, sy + 2, 6, 5);
        g.fillStyle = "#000";
        g.fillRect(sx + (player.facing > 0 ? 8 : 3), sy + 4, 2, 2);
        if (player.big) {
          g.fillStyle = "#0002";
          g.fillRect(sx, sy, player.w, player.h);
        }
        if (player.tailTimer > 0 && hasTailAbilities()) {
          const dir = player.facing >= 0 ? 1 : -1;
          const tx = sx + (dir > 0 ? player.w : -TAIL_RANGE_X);
          const ty = sy + (player.h - TAIL_RANGE_Y - 4);
          g.fillStyle = "#d18f2c";
            g.fillRect(tx, ty, TAIL_RANGE_X, TAIL_RANGE_Y);
            g.fillStyle = "#ffdd99";
            g.fillRect(tx + (dir > 0 ? 2 : 0), ty + 2, TAIL_RANGE_X - 4, TAIL_RANGE_Y - 4);
          }
        }
      }
    }

    // particles
    for (const p of particles) {
      const sx = Math.floor(p.x - cam.x);
      const sy = Math.floor(p.y - cam.y);
      g.fillStyle = p.color || "#ffe066";
      const size = p.size || 2;
      g.fillRect(sx, sy, size, size);
    }

    drawGridOverlay();
    drawHoverOverlay();
    drawSelectionOverlay();
    drawLabelsOverlay();
    drawHudCanvas();
    // chat overlay
    if (chatLog.length > 0 && chatVisibleTime > -2) {
      g.save();
      g.font = "8px 'Press Start 2P', 'VT323', monospace";
      g.textAlign = "left";
      g.textBaseline = "top";
      const startY = 16;
      const startX = 12;
      let y = startY;
      for (let i = Math.max(0, chatLog.length - 8); i < chatLog.length; i++) {
        const entry = chatLog[i];
        const line = `${entry.name}: ${entry.text}`;
        const alpha = Math.max(0, Math.min(1, chatVisibleTime / 2));
        g.fillStyle = `rgba(0,0,0,${0.5 * alpha})`;
        g.fillRect(startX - 4, y - 2, Math.min(200, line.length * 6 + 8), 12);
        g.fillStyle = `rgba(242,245,255,${alpha})`;
        g.fillText(line.slice(0, 64), startX, y);
        y += 12;
      }
      g.restore();
    }
    if (clickDebug && clickDebug.timer > 0) {
      const { sx, sy } = clickDebug;
      g.save();
      g.fillStyle = "rgba(255,0,200,0.9)";
      g.fillRect(sx + TILE/2 - 1, sy, 2, TILE);
      g.fillRect(sx, sy + TILE/2 - 1, TILE, 2);
      g.restore();
    }

    // blit scaled to main canvas
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(off, 0, 0, canvas.width, canvas.height);

    // Update DOM name tags (self + peers) aligned to the canvas
    const rect = canvas.getBoundingClientRect();
    const scaleX = rect.width / BASE_W;
    const scaleY = rect.height / BASE_H;
    tagLayer.innerHTML = "";
    const addTag = (label, worldX, worldY, color = "#f2f5ff") => {
      const screenX = (worldX - cam.x) * scaleX;
      const screenY = (worldY - cam.y) * scaleY;
      const el = document.createElement("div");
      el.textContent = label;
      el.style.position = "absolute";
      el.style.left = `${rect.left + screenX}px`;
      el.style.top = `${rect.top + screenY}px`;
      el.style.transform = "translate(-50%, -100%)";
      el.style.font = "16px 'Press Start 2P', 'VT323', monospace";
      el.style.color = color;
      el.style.textShadow = "1px 1px 0 #000, -1px 1px 0 #000, 1px -1px 0 #000, -1px -1px 0 #000";
      el.style.pointerEvents = "none";
      tagLayer.appendChild(el);
    };
    // self
    addTag(`${PLAYER_NAME}`, player.x + player.w / 2, player.y - 4, "#f6d341");
    // peers
    for (const peer of peers.values()) {
      const px = peer.x ?? peer.targetX ?? 0;
      const py = peer.y ?? peer.targetY ?? 0;
      addTag(`${peer.name || "P"}`, px + 6, py - 4, "#f2f5ff");
    }
  }

  function drawHudCanvas() {
    const hudH = HUD_TILES * TILE;
    const hudY = BASE_H - hudH;
    // background
    g.fillStyle = "#b8e8ff";
    g.fillRect(0, hudY, BASE_W, hudH);
    g.strokeStyle = "#000";
    g.lineWidth = 4;
    g.strokeRect(0, hudY, BASE_W, hudH);
    g.strokeStyle = "#7fb7d6";
    g.lineWidth = 3;
    g.strokeRect(2, hudY + 2, BASE_W - 4, hudH - 4);

    g.save();
    g.translate(6, hudY + 6);
    g.fillStyle = "#000";
    g.font = "8px 'Press Start 2P', 'VT323', monospace";
    g.textBaseline = "top";

    const drawBlock = (lines, x) => {
      const padX = 8, padY = 6;
      const w = 70, h = hudH - 12;
      g.fillStyle = "#b8e8ff";
      g.strokeStyle = "#000";
      g.lineWidth = 3;
      g.beginPath();
      g.rect(x, 0, w, h);
      g.fill();
      g.stroke();
      g.strokeStyle = "#7fb7d6";
      g.lineWidth = 2;
      g.strokeRect(x + 2, 2, w - 4, h - 4);
      g.fillStyle = "#000";
      let y = padY;
      for (const line of lines) {
        g.fillText(line, x + padX, y);
        y += 12;
      }
    };

    drawBlock(["WORLD", "1"], 0);
    drawBlock([`M x ${lives}`, `COIN ${coinCount.toString().padStart(2, "0")}`], 80);
    drawBlock([`SPD ${Math.abs(player.vx).toFixed(0)}`, `ACC ${player.ax.toFixed(0)}`], 160);
    drawBlock([`FORM ${player.form ? player.form.slice(0,2).toUpperCase() : "SM"}`, `T ${Math.max(0, Math.floor(levelTimer)).toString().padStart(3,"0")}`], 240);
    drawBlock([`SCORE`, score.toString().padStart(6,"0")], 320);
    drawBlock([`FLY ${player.flightActive ? player.flightTimer.toFixed(1) : "0"}`, `P ${pMeterDisplaySegs}/${P_METER_SEGMENTS}`], 400);

    g.restore();
  }

  function updateHudDom() {
    const worldEl = document.getElementById("hud-world");
    const livesEl = document.getElementById("hud-lives");
    const coinsEl = document.getElementById("hud-coins");
    const scoreEl = document.getElementById("hud-score");
    const timeEl = document.getElementById("hud-time");
    const accEl = document.getElementById("hud-acc");
    const spdEl = document.getElementById("hud-spd");
    const pMeterEl = document.getElementById("hud-pmeter");
    const formEl = document.getElementById("hud-form");
    const starEl = document.getElementById("hud-star");
    const flyEl = document.getElementById("hud-fly");

    if (!worldEl) return;
    worldEl.textContent = "1";
    livesEl.textContent = Math.max(1, lives);
    coinsEl.textContent = coinCount.toString().padStart(2, "0");
    scoreEl.textContent = score.toString().padStart(6, "0");
    timeEl.textContent = Math.max(0, Math.floor(levelTimer)).toString().padStart(3, "0");
    const ax = player.ax;
    accEl.textContent = `${ax >= 0 ? "+" : ""}${ax.toFixed(0)}`;
    if (spdEl) {
      const spd = Math.abs(player.vx);
      spdEl.textContent = spd.toFixed(0);
    }
    if (formEl) {
      const formLabel = player.form ? player.form.slice(0, 2).toUpperCase() : "SM";
      formEl.textContent = formLabel;
    }
    if (starEl) {
      const starTime = Math.max(0, player.invuln);
      starEl.textContent = starTime > 0 ? starTime.toFixed(1) : "0";
      starEl.style.color = starTime > 0 ? "#ffeb3b" : "#fff";
    }
    if (flyEl) {
      flyEl.textContent = player.flightActive ? player.flightTimer.toFixed(1) : "0";
    }

    if (pMeterEl) {
      const filled = pMeterDisplaySegs;
      for (let i = 0; i < pMeterEl.children.length; i++) {
        pMeterEl.children[i].classList.toggle("filled", i < filled);
      }
    }
  }

  function updateDebugOverlay() {
    if (!debugVxEl && !debugAxEl && !debugPChargeEl && !debugPSegsEl) return;
    if (debugVxEl) debugVxEl.textContent = player.vx.toFixed(1);
    if (debugAxEl) debugAxEl.textContent = player.ax.toFixed(1);
    if (debugPChargeEl) debugPChargeEl.textContent = (player.pCharge * 100).toFixed(1);
    if (debugPSegsEl) debugPSegsEl.textContent = `${pMeterDisplaySegs}/${P_METER_SEGMENTS}`;
  }

  function updatePMeterUi(dt) {
    const speedRatio = clamp(Math.abs(player.vx) / P_SPEED_MAX, 0, 1);
    const targetSegs = Math.min(P_METER_SEGMENTS, Math.round(speedRatio * P_METER_SEGMENTS));

    if (targetSegs > pMeterDisplaySegs) {
      pMeterDisplaySegs = targetSegs;
      pMeterDecayHold = P_METER_DECAY_DELAY;
    } else if (targetSegs < pMeterDisplaySegs) {
      if (pMeterDecayHold <= 0) {
        pMeterDecayHold = P_METER_DECAY_DELAY;
      } else {
        pMeterDecayHold = Math.max(0, pMeterDecayHold - dt);
        if (pMeterDecayHold <= 0) pMeterDisplaySegs = targetSegs;
      }
    } else {
      pMeterDecayHold = Math.max(0, pMeterDecayHold - dt);
    }
  }

  // -----------------------------
  // Main loop
  // -----------------------------
  function frame(now) {
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    acc += dt;

    while (acc >= FIXED) {
      step(FIXED);
      acc -= FIXED;
    }

    if (clickDebug && clickDebug.timer > 0) {
      clickDebug.timer -= dt;
      if (clickDebug.timer <= 0) clickDebug = null;
    }

    updateNetwork(dt);

    // consume pressed keys for this frame
    pressed.clear();

    updatePMeterUi(dt);
    updateHudDom();
    updateDebugOverlay();
    // chat fade timer
    if (chatVisibleTime > 0) chatVisibleTime -= dt;
    render();
    requestAnimationFrame(frame);
  }

  function drawBadge(label, x, y, color = "#f2f5ff") {
    const text = label || "";
    const padding = 4;
    const font = "7px 'Press Start 2P', 'VT323', monospace";
    badgeCtx.font = font;
    badgeCtx.textAlign = "center";
    badgeCtx.textBaseline = "middle";
    const textW = badgeCtx.measureText(text).width;
    const w = Math.max(36, Math.ceil(textW + padding * 2));
    const h = 12;
    badgeCanvas.width = w;
    badgeCanvas.height = h;
    badgeCtx.imageSmoothingEnabled = false;
    badgeCtx.font = font;
    badgeCtx.textAlign = "center";
    badgeCtx.textBaseline = "middle";
    badgeCtx.fillStyle = "rgba(0,0,0,0.55)";
    badgeCtx.fillRect(0, 0, w, h);
    badgeCtx.fillStyle = color;
    badgeCtx.fillText(text, Math.floor(w / 2), Math.floor(h / 2) + 1);
    // blit without scaling for crisp edges
    const destX = Math.round(x - w / 2);
    const destY = Math.round(y);
    g.drawImage(badgeCanvas, destX, destY);
  }

  // Start
  const jumpWalkEl = document.getElementById("jump-walk");
  const jumpRunEl = document.getElementById("jump-run");
  const pMeterEl = document.getElementById("hud-pmeter");
  if (pMeterEl && pMeterEl.children.length === 0) {
    for (let i = 0; i < P_METER_SEGMENTS; i++) {
      const seg = document.createElement("div");
      seg.className = "pmeter-seg";
      pMeterEl.appendChild(seg);
    }
  }
  if (jumpWalkEl && jumpRunEl) {
    jumpWalkEl.textContent = jumpWalkTiles.toFixed(1);
    jumpRunEl.textContent = jumpRunTiles.toFixed(1);
  }

  loadPlayerSnapshot();
  savePlayerSnapshot();
  updateCamera();
  requestAnimationFrame(frame);

})();
</script>
</body>
</html>



